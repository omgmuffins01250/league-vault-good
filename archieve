
// popup.js — verbose legacy debug + CSV logs (lineupSlotId-only refactor)

const DEFAULT_APP_URL = "https://dhx744-5173.csb.app/";
const VIEWS =
"view=mMatchup&view=mMatchupScore&view=mScoreboard&view=mLiveScoring&view=mBoxscore&view=mSettings&view=mTeam&view=mRoster&view=mTransactions2&view=mDraftDetail&view=mMembers";



// For sanity/debug only
const ESPN_SLOT_NAME = {
  0: "QB", 2: "RB", 3: "WR", 4: "WR/TE", 5: "RB/WR",
  6: "TE", 7: "OP", 16: "D/ST", 17: "K", 20: "BN", 21: "IR", 23: "FLEX"
};
const ESPN_POS_NAME = { 1: "QB", 2: "RB", 3: "WR", 4: "TE", 5: "K", 16: "D/ST" };
const $ = (sel) => document.querySelector(sel);
const logLine = (s, cls) => {
  const el = $("#msg");
  const div = document.createElement("div");
  if (cls) div.className = cls;
  div.textContent = String(s);
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
};

// ---- storage of app url
async function loadAppUrl() {
  const { fl_app_url } = await chrome.storage.local.get(["fl_app_url"]);
  $("#appUrl").value = fl_app_url || DEFAULT_APP_URL;
}
async function saveAppUrl(url) { await chrome.storage.local.set({ fl_app_url: url }); }

async function getActiveTab() {
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  return tab || null;
}
// ---------- PAGE-SIDE CAPTURE OF PROJECTIONS (per week, per team, per player) ----------
async function fetchPlayerProjByYearViaPage(tabId, leagueId, years, dbg) {
  const [{ result }] = await chrome.scripting.executeScript({
    target: { tabId },
    args: [leagueId, years],
    func: async (lgId, yrs) => {
      const sleep = (ms) => new Promise(r => setTimeout(r, ms));

      function projectAndActualForEntry(entry, week, seasonId) {
        const p = entry?.player || entry?.playerPoolEntry?.player || {};
        const stats = Array.isArray(p?.stats) ? p.stats : [];
        const pick = (src, split) =>
          stats.find(s =>
            Number(s?.seasonId) === Number(seasonId) &&
            Number(s?.scoringPeriodId) === Number(week) &&
            Number(s?.statSourceId) === src &&
            Number(s?.statSplitTypeId) === split
          );
        const projRow   = pick(1, 1);  // start-of-week projection
        const actualRow = pick(0, 1);  // game actuals
        const proj   = Number(projRow?.appliedTotal ?? projRow?.appliedStatTotal ?? 0) || 0;
        const actual = Number(actualRow?.appliedTotal ?? actualRow?.appliedStatTotal ?? 0) || 0;
        return { proj: +proj.toFixed(2), actual: +actual.toFixed(2) };
      }

      function collectFromWeeklyJson(json) {
        const out = {}; // { teamId: { [week]: { [pid]: { proj, actual } } } }
        const seasonId = Number(json?.seasonId);
        const sched = Array.isArray(json?.schedule) ? json.schedule : [];
        for (const g of sched) {
          const w = Number(g?.matchupPeriodId ?? g?.scoringPeriodId ?? 0) || 0;
          if (!w) continue;
          for (const side of [g?.home, g?.away]) {
            const tid = side?.teamId ?? side?.team?.id;
            if (tid == null) continue;

            const roster =
              side?.rosterForCurrentScoringPeriod ??
              side?.rosterForScoringPeriod ??
              side?.rosterForMatchupPeriod ??
              side?.roster ?? {};
            const entries = Array.isArray(roster?.entries)
              ? roster.entries
              : Array.isArray(roster?.players) ? roster.players : [];

            for (const e of entries) {
              const pid =
                Number(e?.playerId) ||
                Number(e?.playerPoolEntry?.player?.id) ||
                Number(e?.player?.id) ||
                Number(e?.id);
              if (!Number.isFinite(pid)) continue;
              const pa = projectAndActualForEntry(e, w, seasonId);
              if (!out[tid]) out[tid] = {};
              if (!out[tid][w]) out[tid][w] = {};
              out[tid][w][pid] = pa;
            }
          }
        }
        return out;
      }

      const playerProjByYear = {}; // { [season]: { [teamId]: { [week]: { [pid]: { proj, actual } } } } }
      const debugCounts = {};      // { [season]: { weeksHit, rows } }

      for (const yr of yrs) {
        let rows = 0;
        let weeksHit = 0;
        const out = {};
        for (let wk = 1; wk <= 22; wk++) {
          const url = `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/${yr}/segments/0/leagues/${lgId}?scoringPeriodId=${wk}&view=mBoxscore`;
          try {
            const res = await fetch(url, { credentials: "include" });
            if (!res.ok) { await sleep(60); continue; }
            const js = await res.json();
            const part = collectFromWeeklyJson(js);
            let wrote = false;
            for (const [tidStr, byW] of Object.entries(part)) {
              const tid = Number(tidStr);
              out[tid] = out[tid] || {};
              for (const [wStr, byPid] of Object.entries(byW)) {
                const w = Number(wStr);
                out[tid][w] = out[tid][w] || {};
                Object.assign(out[tid][w], byPid);
                rows += Object.keys(byPid).length;
                wrote = true;
              }
            }
            if (wrote) weeksHit++;
          } catch {}
          await sleep(60);
        }
        playerProjByYear[yr] = out;
        debugCounts[yr] = { weeksHit, rows };
      }

      return { playerProjByYear, debugCounts };
    },
  });

  const pj = result?.playerProjByYear || {};
  const counts = result?.debugCounts || {};
  Object.entries(counts).forEach(([y, c]) =>
    logLine(`Projections captured ${y} → weeks:${c.weeksHit}, rows:${c.rows.toLocaleString()}`)
  );
  dbg.push("projections-capture", JSON.stringify(counts));

  return pj;
}

// ---------------- CSV helpers ----------------
function makeCsv(headers, rows) {
  const esc = (v) => {
    const s = v == null ? "" : String(v);
    return /[",\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
  };
  const body = rows.map((r) => headers.map((h) => esc(r[h])).join(",")).join("\n");
  return headers.join(",") + "\n" + body;
}
async function downloadCsv(filename, text, mime = "text/csv") {
  const blob = new Blob([text], { type: mime });
  const url = URL.createObjectURL(blob);
  try {
    await chrome.downloads.download({ url, filename, saveAs: true });
  } finally {
    setTimeout(() => URL.revokeObjectURL(url), 10000);
  }
}

// --- PER-PLAYER start-of-week projections & actuals (from weekly mBoxscore) ---
function projectAndActualForEntry(entry, week, seasonId) {
  const p = entry?.player || entry?.playerPoolEntry?.player;
  const stats = Array.isArray(p?.stats) ? p.stats : [];
  const pick = (src, split) =>
    stats.find(s =>
      Number(s?.seasonId) === Number(seasonId) &&
      Number(s?.scoringPeriodId) === Number(week) &&
      Number(s?.statSourceId) === src &&
      Number(s?.statSplitTypeId) === split
    );
  const projRow   = pick(1, 1);  // start-of-week projection
  const actualRow = pick(0, 1);  // game actuals
  const proj   = Number(projRow?.appliedTotal ?? projRow?.appliedStatTotal ?? 0) || 0;
  const actual = Number(actualRow?.appliedTotal ?? actualRow?.appliedStatTotal ?? 0) || 0;
  return { proj: +proj.toFixed(2), actual: +actual.toFixed(2) };
}

function collectPlayerProjActualFromWeeklyJson(json) {
  const out = {}; // { teamId: { [week]: { [pid]: { proj, actual } } } }
  const seasonId = Number(json?.seasonId);
  const sched = Array.isArray(json?.schedule) ? json.schedule : [];
  for (const g of sched) {
    const w = Number(g?.matchupPeriodId ?? g?.scoringPeriodId ?? 0) || 0;
    if (!w) continue;
    for (const sideName of ["home", "away"]) {
      const side = g?.[sideName];
      const tid = side?.teamId ?? side?.team?.id;
      if (tid == null) continue;

      const entries =
        side?.rosterForMatchupPeriod?.entries ||
        side?.rosterForScoringPeriod?.entries ||
        side?.roster?.entries || [];

      for (const e of entries) {
        const pid =
          Number(e?.playerId) ||
          Number(e?.playerPoolEntry?.player?.id) ||
          Number(e?.player?.id) ||
          Number(e?.id);
        if (!Number.isFinite(pid)) continue;
        const pa = projectAndActualForEntry(e, w, seasonId);
        if (!out[tid]) out[tid] = {};
        if (!out[tid][w]) out[tid][w] = {};
        out[tid][w][pid] = pa; // only tiny numbers per player
      }
    }
  }
  return out;
}

async function fetchWeeklyPlayerProjYear(leagueId, yr) {
  const out = {}; // { teamId: { [week]: { [pid]: { proj, actual } } } }
  const weeks = 22;
  for (let wk = 1; wk <= weeks; wk++) {
    const url =
      `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/${yr}/segments/0/leagues/${leagueId}` +
      `?scoringPeriodId=${wk}&view=mBoxscore`;
    try {
      const res = await fetch(url, { credentials: "include" });
      if (!res.ok) { await new Promise(r=>setTimeout(r,60)); continue; }
      const js = await res.json();
      const part = collectPlayerProjActualFromWeeklyJson(js);
      // merge
      for (const [tidStr, byW] of Object.entries(part)) {
        const tid = Number(tidStr);
        out[tid] = out[tid] || {};
        for (const [wStr, byPid] of Object.entries(byW)) {
          const w = Number(wStr);
          out[tid][w] = out[tid][w] || {};
          Object.assign(out[tid][w], byPid);
        }
      }
    } catch {}
    await new Promise(r=>setTimeout(r,60));
  }
  return out;
}

// ---- EXACT-CONSOLE METHOD: Fetch roster acquisitions (mRoster + mTeam) for multiple seasons ----
async function fetchRosterAcqAPIYears(tabId, leagueId, years, dbg) {
  const [{ result }] = await chrome.scripting.executeScript({
    target: { tabId },
    args: [leagueId, years],
    func: async (leagueId, years) => {
   const SLOT = {0:"QB",2:"RB",3:"WR",4:"WR/TE",5:"RB/WR",6:"TE",7:"OP",16:"D/ST",17:"K",20:"BN",21:"IR",23:"FLEX"};

      const teamNameOf = (t) =>
        t?.name ||
        [t?.location, t?.nickname].filter(Boolean).join(" ").trim() ||
        t?.abbrev ||
        `Team ${t?.id}`;

      const out = {};     // { season: { teamId: { playerId: { type, slotId, name } } } }
      const flat = [];    // [{season, teamId, fantasyTeam, playerId, playerName, acquisitionType, slotId, slot}]
      const hist = {};    // { season: { TYPE: count } }

      for (const seasonId of years) {
        try {
          const url =
            `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/${seasonId}` +
            `/segments/0/leagues/${leagueId}?view=mRoster&view=mTeam`;

          const resp = await fetch(url, { credentials: "include" });
          if (!resp.ok) continue;
          const data = await resp.json();

          const teams = Array.isArray(data?.teams) ? data.teams : [];
          out[seasonId] = out[seasonId] || {};
          hist[seasonId] = hist[seasonId] || {};

          for (const team of teams) {
            const teamId = Number(team?.id ?? team?.teamId);
            if (!Number.isFinite(teamId)) continue;

            const fantasyTeam = teamNameOf(team);
            const roster = team?.roster || {};
            const entries = Array.isArray(roster.entries) ? roster.entries
                          : Array.isArray(roster.players) ? roster.players
                          : [];

          for (const entry of entries) {
  const p = entry?.playerPoolEntry?.player || entry?.player || {};
  const playerId   = Number(p?.id);
  const playerName = p?.fullName || p?.name || "";
  const acq = (entry?.acquisitionType || entry?.acqType || "").toString().toUpperCase();

  const readLineup = (x) => Number.isFinite(x) ? Number(x) : null;
  const slotId =
    readLineup(entry?.lineupSlotId) ??
    readLineup(entry?.lineupSlotIdFinal) ??
    readLineup(entry?.playerPoolEntry?.lineupSlotId) ??
    readLineup(entry?.playerPoolEntry?.lineupSlotIdFinal) ?? null;

  const readPos = (x) => Number.isFinite(x) ? Number(x) : null;
  const posId = readPos(p?.defaultPositionId);

  if (!Number.isFinite(playerId) || !acq) continue;

  if (!out[seasonId][teamId]) out[seasonId][teamId] = {};
  if (!out[seasonId][teamId][playerId]) {
    out[seasonId][teamId][playerId] = {
      type: acq,
      slotId: Number.isFinite(slotId) ? slotId : null,
      defaultPositionId: Number.isFinite(posId) ? posId : null,
      name: playerName
    };
  }

  flat.push({
    season: Number(seasonId),
    teamId,
    fantasyTeam,
    playerId,
    playerName,
    acquisitionType: acq,
    slotId: Number.isFinite(slotId) ? slotId : null,
    slot: Number.isFinite(slotId) ? (SLOT[slotId] || String(slotId)) : ""
  });

  hist[seasonId][acq] = (hist[seasonId][acq] || 0) + 1;
}

          }
        } catch {}
      }

      return { map: out, flat, hist };
    },
  });

  const map = result?.map || {};
  const flat = result?.flat || [];
  const hist = result?.hist || {};

  // visible logs + debug lines
  Object.entries(map).forEach(([season, byTeam]) => {
    const cnt = Object.values(byTeam || {}).reduce((s, m) => s + Object.keys(m || {}).length, 0);
    logLine(`· Roster acquisitions ${season} (API console method): ${cnt}`);
  });
  Object.entries(hist).forEach(([season, counts]) => {
    dbg.push(
      "rosters-acq-api",
      Object.entries(counts).map(([t, c]) => `${t}:${c}`).join(" "),
      { season: Number(season) }
    );
  });

  return { map, flat };
}

/* ---------------- ADP helpers ---------------- */
function normName(s) {
  return String(s || "").toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, " ").trim();
}
async function readCachedADP(year) {
  const key = `fp_adp_${year}`;
  const obj = await chrome.storage.local.get([key]);
  const cached = obj[key] || null;
  if (!cached || !cached.data) return null;
  const firstVal = Object.values(cached.data)[0];
  const isNumberMap = typeof firstVal === "number";
  if (isNumberMap) {
    const simple = cached.data;
    const rich = Object.fromEntries(Object.entries(simple).map(([k, v]) => [k, { adp: Number(v), pos: null }]));
    return { simple, rich };
  } else {
    const rich = cached.data;
    const simple = Object.fromEntries(Object.entries(rich).map(([k, v]) => [k, Number(v?.adp)]));
    return { simple, rich };
  }
}
async function writeCachedADP(year, richMap) {
  const key = `fp_adp_${year}`;
  await chrome.storage.local.set({ [key]: { savedAt: Date.now(), data: richMap } });
}
async function fetchFantasyProsADPHTML(year) {
  const candidates = [
    `https://www.fantasypros.com/nfl/adp/ppr-overall.php?year=${year}`,
    `https://www.fantasypros.com/nfl/adp/ppr-overall.php`,
  ];
  for (const url of candidates) {
    try {
      const res = await fetch(url, { credentials: "omit" });
      if (res.ok) {
        const text = await res.text();
        if (text && text.length > 5000) return text;
      }
    } catch {}
  }
  return "";
}
function parseFantasyProsADP(html) {
  const doc = new DOMParser().parseFromString(html, "text/html");
  const tables = Array.from(doc.querySelectorAll("table"));
  let rich = {};
  for (const table of tables) {
    const headers = Array.from(table.querySelectorAll("thead th")).map((th) => th.textContent.trim().toLowerCase());
    if (!headers.length) continue;
    const hasPlayer = headers.some((h) => h.includes("player"));
    const adpIdx = headers.findIndex((h) => h === "adp" || /avg.*draft.*pos/i.test(h));
    const posIdx = headers.findIndex((h) => h === "pos" || /^pos\b/.test(h));
    if (!hasPlayer || adpIdx === -1) continue;
    const rows = Array.from(table.querySelectorAll("tbody tr"));
    for (const tr of rows) {
      const cells = Array.from(tr.children);
      if (!cells.length) continue;
      const a = tr.querySelector('a[href*="/nfl/players/"]') || tr.querySelector("a");
      const player = a ? a.textContent.trim() : cells[0].textContent.trim();
      if (!player) continue;
      const adpTxt = cells[adpIdx] ? cells[adpIdx].textContent.trim() : "";
      const adp = Number(adpTxt.replace(/[^0-9.]/g, ""));
      if (!isFinite(adp) || adp <= 0 || adp > 500) continue;
      const posTxt = posIdx >= 0 && cells[posIdx] ? cells[posIdx].textContent.trim() : null;
      rich[normName(player)] = { adp, pos: posTxt || null };
    }
    if (Object.keys(rich).length > 20) break;
  }
  const simple = Object.fromEntries(Object.entries(rich).map(([k, v]) => [k, Number(v.adp)]));
  return { simple, rich };
}
async function getFantasyProsADPForYear(year) {
  const cached = await readCachedADP(year);
  if (cached?.rich && Object.keys(cached.rich).length > 20) return cached;
  const html = await fetchFantasyProsADPHTML(year);
  if (!html) return { simple: {}, rich: {} };
  const parsed = parseFantasyProsADP(html);
  if (Object.keys(parsed.rich).length > 0) await writeCachedADP(year, parsed.rich);
  return parsed;
}

// ---- Scrape League → Rosters for acquisitionType ("FREE AGENCY" | "TRADE" | "DRAFT" | "WAIVERS") ----
async function scrapeRosterAcquisitionsByYear(tabId, leagueId, years) {
  // returns: { [season]: { [teamId]: { [playerId]: acquisitionType } } }
  const out = {};
  const maxPerSeason = 999999; // no cap

  for (const season of years) {
    try {
      const [{ result }] = await chrome.scripting.executeScript({
        target: { tabId },
        args: [leagueId, season],
        func: async (lgId, yr) => {
          const iframeId = "fl-rosters-scrape";
          let iframe = document.getElementById(iframeId);
          if (!iframe) {
            iframe = document.createElement("iframe");
            iframe.id = iframeId;
            iframe.style.cssText = "position:fixed;left:-99999px;top:-99999px;width:1px;height:1px";
            iframe.setAttribute("sandbox", "allow-same-origin allow-scripts");
            document.body.appendChild(iframe);
          }
          const url = `https://fantasy.espn.com/football/league/rosters?leagueId=${lgId}&seasonId=${yr}`;

// wait for the iframe to finish loading this URL
await new Promise((resolve) => {
  const handler = () => {
    iframe.removeEventListener("load", handler);
    resolve();
  };
  iframe.addEventListener("load", handler);
  iframe.src = url;
});

// give Next.js a moment to hydrate before reading __NEXT_DATA__
await new Promise((r) => setTimeout(r, 120));

// Read Next.js bootstrap JSON
let data = null;
try {
  const sc = iframe.contentDocument?.querySelector("#__NEXT_DATA__");
  data = sc ? JSON.parse(sc.textContent || "{}") : null;
} catch {}

// Guard: if the JSON isn't ready, return a marker so logs show the miss
if (!data) return { season: yr, rows: [], err: "NO_NEXT_DATA" };


          // Walk the JSON and extract {teamId, playerId, acquisitionType}
          const rows = [];
          const walk = (node) => {
            if (!node || typeof node !== "object") return;
// inside the walk(node) function:
const maybePlayer = node.player || node.playerPoolEntry?.player;

const pid =
  node.playerId ??
  maybePlayer?.id ??
  node.id ?? null;

const teamId =
  node.onTeamId ??
  node.teamId ??
  node.team?.id ??
  node.playerPoolEntry?.onTeamId ??   // <-- NEW: many entries store team here
  null;

const name =
  maybePlayer?.fullName ||
  maybePlayer?.name ||
  node.player?.fullName ||
  node.player?.name || "";            // <-- NEW: capture fullName

const acq = node.acquisitionType || node.acqType || null;

if (pid && teamId != null && typeof acq === "string") {
  rows.push({
    teamId: Number(teamId),
    playerId: Number(pid),
    acquisitionType: acq,
    name                                               // <-- keep name (optional if you want)
  });
}

// If this object is a roster with entriesByScoringPeriod, iterate its arrays
if (node?.entriesByScoringPeriod && typeof node.entriesByScoringPeriod === "object") {
  for (const arr of Object.values(node.entriesByScoringPeriod)) {
    if (Array.isArray(arr)) arr.forEach(walk);
  }
}

          };

          // ESPN puts relevant stuff under props.pageProps / props
          const root =
            data?.props?.pageProps ??
            data?.props ??
            data?.pageProps ??
            data;
          walk(root);

          // De-duplicate (playerId, teamId) pairs; prefer first seen
          const seen = new Set();
          const deduped = [];
          for (const r of rows) {
            const key = `${r.teamId}|${r.playerId}`;
            if (seen.has(key)) continue;
            seen.add(key);
            deduped.push(r);
          }

          return {
            season: yr,
            rows: deduped.slice(0, maxPerSeason),
          };
        },
      });

      const arr = Array.isArray(result?.rows) ? result.rows : [];
      out[season] = out[season] || {};
      for (const r of arr) {
        const t = Number(r.teamId);
        const p = Number(r.playerId);
        const acq = String(r.acquisitionType || "").toUpperCase();
        if (!Number.isFinite(t) || !Number.isFinite(p) || !acq) continue;
        if (!out[season][t]) out[season][t] = {};
        // Keep the first non-empty value if multiple exist
        if (!out[season][t][p]) out[season][t][p] = acq;
      }
      // Light log for this season (count of mapped players)
      const seasonCount = Object.values(out[season] || {}).reduce(
        (s, m) => s + Object.keys(m || {}).length,
        0
      );
      logLine(`· Roster acquisitions ${season}: ${seasonCount}`);
    } catch (e) {
      logLine(`· Roster acquisitions ${season}: ERROR (${e.message || e})`, "warn");
    }
  }

  return out;
}

/* ---------------- Legacy helpers ---------------- */
function normalizeLegacySeasonFromLeagueHistory(leagueObj, year, leagueId) {
  const teamMap = new Map();
  const members = leagueObj.members || [];
  const ownerName = members.reduce((m, x) => {
    if (x?.id) m[x.id] = x.displayName || [x.firstName, x.lastName].filter(Boolean).join(" ");
    return m;
  }, {});
  for (const t of (leagueObj.teams || [])) teamMap.set(t.id, t);

  const leagueName =
    leagueObj?.settings?.name || leagueObj?.settings?.leagueName || leagueObj?.settings?.leagueNickname || "";
  const scoring = leagueObj?.settings?.scoringType || "";

  const rows = [];
  for (const m of (leagueObj.schedule || [])) {
    const week = m.matchupPeriodId;
    const home = teamMap.get(m.home?.teamId);
    const away = teamMap.get(m.away?.teamId);
    if (!home || !away) continue;

    const hScore = Number(m.home?.totalPoints ?? m.home?.pointsByScoringPeriod?.[week] ?? 0) || 0;
    const aScore = Number(m.away?.totalPoints ?? m.away?.pointsByScoringPeriod?.[week] ?? 0) || 0;
// NEW: try leagueHistory's winner if present
const win = (m?.winner || "").toString().toUpperCase();
const homeRes = win === "HOME" ? "W" : win === "AWAY" ? "L" : (hScore > aScore ? "W" : hScore < aScore ? "L" : "T");
const awayRes = homeRes === "W" ? "L" : homeRes === "L" ? "W" : "T";

    const teamName = (t) =>
      (t?.location && t?.nickname) ? `${t.location} ${t.nickname}` : (t?.name || t?.abbrev || "");
    const owners = ownerName;
    const ownerFor = (t) => owners[t?.primaryOwner] || (t?.owners || [])[0] || teamName(t) || "—";

    const hName = teamName(home), aName = teamName(away);
    const hOwner = ownerFor(home), aOwner = ownerFor(away);

    const tier  = (m?.playoffTierType || "").toString().toUpperCase();
    const mtype = (m?.matchupType || "").toString().toUpperCase();
    const isPO  = (tier && tier !== "NONE") || /PLAYOFF|CHAMP/.test(mtype);
    const isWB  = isPO && !/LOSER|CONSOLATION/.test(tier) &&
                  (/WINNER|CHAMP/.test(tier) || /WINNER|CHAMP/.test(mtype));

    const hFinal = home?.finalRank ?? home?.rankCalculatedFinal ?? "";
    const aFinal = away?.finalRank ?? away?.rankCalculatedFinal ?? "";

    rows.push({
      season: year, week, manager: hOwner, opponent: aOwner, team_name: hName,
      points_for: hScore, points_against: aScore, result: homeRes,
      final_rank: hFinal, league_id: String(leagueId), league_name: leagueName, platform: "ESPN", scoring,
      is_playoff: !!isPO, is_winners_bracket: !!isWB, playoff_tier: tier || undefined, matchup_type: mtype || undefined,
    });
    rows.push({
      season: year, week, manager: aOwner, opponent: hOwner, team_name: aName,
      points_for: aScore, points_against: hScore, result: awayRes,
      final_rank: aFinal, league_name: leagueName, platform: "ESPN", scoring,
      is_playoff: !!isPO, is_winners_bracket: !!isWB, playoff_tier: tier || undefined, matchup_type: mtype || undefined,
    });
  }
  return rows;
}

/* ---------------- DEBUG CSV buffer ---------------- */
function makeDebug() {
  const lines = [];
  const push = (step, detail, extra = {}) => lines.push({ ts: new Date().toISOString(), step, detail, ...extra });
  const csv = () => {
    const headers = ["ts","step","detail","season","week","url","status","ok","bytes","rows"];
    return makeCsv(headers, lines);
  };
  return { push, csv };
}

async function scrapeSeasonRostersAcquisitionTypes(tabId, leagueId, years, dbg) {
  // Runs in the page to avoid CORS and keep ESPN cookies
  const [{ result }] = await chrome.scripting.executeScript({
    target: { tabId },
    args: [leagueId, years],
    func: async (leagueId, years) => {
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  const ensureIframe = () => {
    const id = "fl-rosters-scrape";
    let el = document.getElementById(id);
    if (!el) {
      el = document.createElement("iframe");
      el.id = id;
      el.style.cssText = "position:fixed;left:-99999px;top:-99999px;width:1px;height:1px";
      el.setAttribute("sandbox", "allow-same-origin allow-scripts");
      document.body.appendChild(el);
    }
    return el;
  };

  const loadRostersJSON = (iframe, season) =>
    new Promise((resolve) => {
      const url = `https://fantasy.espn.com/football/league/rosters?leagueId=${leagueId}&seasonId=${season}`;
      const onload = () => {
        iframe.removeEventListener("load", onload);
        let data = null;
        try {
          const sc = iframe.contentDocument.querySelector("#__NEXT_DATA__");
          data = sc ? JSON.parse(sc.textContent || "{}") : null;
        } catch {}
        resolve(data);
      };
      iframe.addEventListener("load", onload);
      iframe.src = url;
    });

  const out = {}; // { season: { teamId: { playerId: { type, name } } } }
  const hist = {}; // { season: { TYPE: count } }

  const iframe = ensureIframe();

  for (const season of years) {
    const data = await loadRostersJSON(iframe, season);
    const pp = data?.props?.pageProps || data?.pageProps || data?.props || {};

    // ---- TEAMS: handle both shapes ----
    const league = pp.league || pp.data || {};
    const teams =
      (Array.isArray(pp.teams) && pp.teams) ||                  // <— NEW
      (Array.isArray(league.teams) && league.teams) ||
      [];

    for (const t of teams) {
      const teamId =
        Number(t?.id ?? t?.teamId ?? t?.team?.id);
      if (!Number.isFinite(teamId)) continue;

      const roster = t?.roster || {};

      // ---- ENTRIES: handle entriesByScoringPeriod ----
      let entries = [];
      if (Array.isArray(roster.entries)) entries = roster.entries;
      else if (Array.isArray(roster.players)) entries = roster.players;
      else if (roster.entriesByScoringPeriod && typeof roster.entriesByScoringPeriod === "object") {
        for (const arr of Object.values(roster.entriesByScoringPeriod)) {
          if (Array.isArray(arr)) entries.push(...arr);
        }
      }

      for (const e of entries) {
  const pid =
    Number(e?.playerId) ||
    Number(e?.playerPoolEntry?.player?.id) ||
    Number(e?.player?.id) ||
    Number(e?.id);

  // <- NEW: read acquisitionType from playerPoolEntry as well
  const acqRaw =
    e?.acquisitionType ??
    e?.acqType ??
    e?.playerPoolEntry?.acquisitionType ??
    e?.playerPoolEntry?.acqType ??
    null;

  const acq = (acqRaw || "").toString().toUpperCase();
  if (!Number.isFinite(pid) || !acq) continue;

  // prefer onTeamId on the entry; fallback to the parent team
  const onTeam = Number(
    e?.playerPoolEntry?.onTeamId ??
    e?.onTeamId ??
    teamId
  );

  // slotId if present in any common shape
  const slotId = Number(
    (Number.isFinite(e?.lineupSlotId) ? e.lineupSlotId : null) ??
    (Number.isFinite(e?.lineupSlotIdFinal) ? e.lineupSlotIdFinal : null) ??
    (Number.isFinite(e?.playerPoolEntry?.lineupSlotId) ? e.playerPoolEntry.lineupSlotId : null) ??
    (Number.isFinite(e?.playerPoolEntry?.lineupSlotIdFinal) ? e.playerPoolEntry.lineupSlotIdFinal : null)
  );

  const name =
    e?.playerPoolEntry?.player?.fullName ||
    e?.player?.fullName ||
    e?.playerPoolEntry?.player?.name ||
    e?.player?.name || "";

  if (!out[season]) out[season] = {};
  if (!out[season][onTeam]) out[season][onTeam] = {};
  if (!out[season][onTeam][pid]) {
    out[season][onTeam][pid] = {
      type: acq,
      name,
      slotId: Number.isFinite(slotId) ? slotId : null
    };
  }

  if (!hist[season]) hist[season] = {};
  hist[season][acq] = (hist[season][acq] || 0) + 1;
}

    }

    await sleep(60);
  }

  return { out, hist };
}

,
  });

 const map = result?.out || {};
const hist = result?.hist || {};

// Visible per-season counts
Object.entries(map).forEach(([season, byTeam]) => {
  const cnt = Object.values(byTeam || {}).reduce((s, m) => s + Object.keys(m || {}).length, 0);
  logLine(`· Roster acquisitions ${season}: ${cnt}`);
});

// Also keep your debug push
const scrapeCount = Object.values(map || {}).reduce(
  (s, m) => s + Object.values(m || {}).reduce((s2, m2) => s2 + Object.keys(m2 || {}).length, 0),
  0
);
dbg.push("rosters-acq-summary", `rows=${scrapeCount}`);

// push debug rows by type
Object.entries(hist).forEach(([season, counts]) => {
  dbg.push(
    "rosters-acq",
    Object.entries(counts).map(([t, c]) => `${t}:${c}`).join(" "),
    { season: Number(season) }
  );
});

return map;
}

/* ---------------- Helpers to build rows (for the app) ---------------- */
function rowsFromSeasons(seasons) {
  const rows = [];
  if (!Array.isArray(seasons)) return rows;
  for (const season of seasons) {
    const year = Number(season?.seasonId) || new Date().getFullYear();
    const leagueName = season?.settings?.name || season?.settings?.leagueName || season?.settings?.leagueNickname || "";
    const memberMap = new Map();
    (season?.members || []).forEach(m => {
      const dn = m?.displayName || "";
      const fn = m?.firstName || "";
      const ln = m?.lastName || "";
      const best = dn || [fn, ln].filter(Boolean).join(" ").trim() || "Unknown";
      memberMap.set(m?.id, best);
    });
    const teamMap = new Map();
    (season?.teams || []).forEach(t => {
      const tName = `${t.location || ""} ${t.nickname || ""}`.trim() || t.name || `Team ${t.id}`;
      const ownerId = t.primaryOwner || (t.owners && t.owners[0]) || "__unknown__";
      const finalRank = t?.finalRank ?? t?.rankCalculatedFinal ?? "";
      teamMap.set(t.id, { name: tName, ownerId, finalRank });
    });
    const scoringName = season?.scoringSettings?.name || season?.settings?.scoringSettings?.name || undefined;
    (season?.schedule || []).forEach(g => {
      const hId = g?.home?.teamId, aId = g?.away?.teamId;
      if (hId == null || aId == null) return;
      const home = teamMap.get(hId), away = teamMap.get(aId);
      if (!home || !away) return;
     const hPts = Number(g?.home?.totalPoints) || 0;
const aPts = Number(g?.away?.totalPoints) || 0;
const week = Number(g?.matchupPeriodId) || null;

// NEW: prefer ESPN's winner flag; fallback to points compare
const win = (g?.winner || "").toString().toUpperCase();
const homeRes = win === "HOME" ? "W" : win === "AWAY" ? "L" : (hPts > aPts ? "W" : hPts < aPts ? "L" : "T");
const awayRes = homeRes === "W" ? "L" : homeRes === "L" ? "W" : "T";


      const tier  = (g?.playoffTierType || "").toString().toUpperCase();
      const mtype = (g?.matchupType || "").toString().toUpperCase();
      const isPO  = g?.playoffMatchup === true || (tier && tier !== "NONE") || /PLAYOFF|CHAMP/.test(mtype);
      const isWB  = isPO && !/LOSER|CONSOLATION/.test(tier) &&
                    (/WINNER|CHAMP/.test(tier) || /WINNER|CHAMP/.test(mtype));

      const homeOwner = memberMap.get(home.ownerId) || "Unknown";
      const awayOwner = memberMap.get(away.ownerId) || "Unknown";

      rows.push({
        season: year, week, manager: homeOwner, opponent: awayOwner, team_name: home.name,
        points_for: hPts, points_against: aPts,
        result: homeRes,
  proj_for: Number(g?.home?.totalProjectedPointsLive ?? 0) || 0,          // NEW
  proj_against: Number(g?.away?.totalProjectedPointsLive ?? 0) || 0,    
        final_rank: home.finalRank || "", league_name: leagueName, platform: "ESPN", scoring: scoringName,
        is_playoff: !!isPO, is_winners_bracket: !!isWB, playoff_tier: tier || undefined, matchup_type: mtype || undefined,
      });
      rows.push({
        season: year, week, manager: awayOwner, opponent: homeOwner, team_name: away.name,
        points_for: aPts, points_against: hPts,
 proj_for: Number(g?.away?.totalProjectedPointsLive ?? 0) || 0,          // NEW
  proj_against: Number(g?.home?.totalProjectedPointsLive ?? 0) || 0,      // NEW
       result: awayRes,
        final_rank: away.finalRank || "", league_name: leagueName, platform: "ESPN", scoring: scoringName,
        is_playoff: !!isPO, is_winners_bracket: !!isWB, playoff_tier: tier || undefined, matchup_type: mtype || undefined,
      });
    });
  }
  return rows;
}
function rowsFromLegacyArray(arr) {
  if (!Array.isArray(arr)) return [];
  return arr.map((r) => ({
    season: Number(r.season),
    week: r.week == null ? null : Number(r.week),
    manager: r.manager ?? r.manager_name ?? r.owner ?? "",
    opponent: r.opponent ?? "",
    team_name: r.team_name ?? r.team ?? "",
    points_for: Number(r.points_for ?? r.pf ?? 0),
    points_against: Number(r.points_against ?? r.pa ?? 0),
  proj_for: Number(r.proj_for ?? 0),               // NEW
  proj_against: Number(r.proj_against ?? 0),       // NEW
    result: r.result ?? "",
    final_rank: r.final_rank ?? r.rank ?? "",
    league_name: r.league_name ?? r.league ?? r.espn_league ?? "",
    platform: r.platform ?? "ESPN",
    scoring: r.scoring ?? "",
    is_playoff: r.is_playoff === true,
    is_winners_bracket: r.is_winners_bracket === true,
    playoff_tier: r.playoff_tier || undefined,
    matchup_type: r.matchup_type || undefined,
  }));
}

/* ---------------- Legacy fetch (with deep logs) ---------------- */
async function legacyFetchSeasonWithLogs(tabId, leagueId, year, dbg) {
  const [{ result: out }] = await chrome.scripting.executeScript({
    target: { tabId },
    args: [leagueId, year],
    func: async (leagueId, year) => {
      const url =
        `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/leagueHistory/${leagueId}` +
        `?seasonId=${year}&view=mTeam&view=mMatchup&view=mMatchupScore`;
      try {
        const res = await fetch(url, { credentials: "include", headers: { "Accept": "application/json" } });
        const status = res.status;
        if (!res.ok) return { kind: "leagueHistory", url, status, ok: false };
        const data = await res.json();
        const seasonObj = Array.isArray(data) ? data[0] : data;
        const len = JSON.stringify(seasonObj || {}).length;
        return { kind: "leagueHistory", url, status, ok: true, jsonBytes: len, seasonObj };
      } catch (e) {
        return { kind: "leagueHistory", url, status: 0, ok: false, err: String(e) };
      }
    },
  });

  let slim = null;

  if (out?.kind === "leagueHistory") {
    dbg.push("leagueHistory", out.ok ? "HTTP ok" : "HTTP fail", {
      season: year, url: out.url, status: out.status, ok: out.ok ? 1 : 0, bytes: out.jsonBytes || 0,
    });

    if (out.ok && out.seasonObj) {
      slim = {
        seasonId: year,
        members: out.seasonObj.members || [],
        teams: (out.seasonObj.teams || []).map((t) => ({
          id: t?.id,
          primaryOwner: t?.primaryOwner || (t?.owners && t.owners[0]) || null,
          owners: t?.owners || [],
          transactionCounter: t?.transactionCounter || {},
        })),
      };

      if (Array.isArray(out.seasonObj.schedule) && out.seasonObj.schedule.length) {
        const rows = normalizeLegacySeasonFromLeagueHistory(out.seasonObj, year, leagueId);
        dbg.push("normalize", `rows=${rows.length}`, { season: year, rows: rows.length });
        return { rows, slim };
      }
    }
  }

  // scoreboard fallback
  const [{ result: fall }] = await chrome.scripting.executeScript({
    target: { tabId },
    args: [leagueId, year],
    func: async (leagueId, season) => {
      const iframeId = "fl-legacy-scrape";
      let iframe = document.getElementById(iframeId);
      if (!iframe) {
        iframe = document.createElement("iframe");
        iframe.id = iframeId;
        iframe.style.cssText = "position:fixed;left:-99999px;top:-99999px;width:1px;height:1px";
        iframe.setAttribute("sandbox", "allow-same-origin allow-scripts");
        document.body.appendChild(iframe);
      }
      const loadScoreboard = (wk) => new Promise((resolve) => {
        const url = `https://fantasy.espn.com/football/league/scoreboard?seasonId=${season}&leagueId=${leagueId}&matchupPeriodId=${wk}&mSPID=1`;
        const onload = () => { iframe.removeEventListener("load", onload); resolve({ url }); };
        iframe.addEventListener("load", onload);
        iframe.src = url;
      });
      const readNextData = () => {
        try {
          const sc = iframe.contentDocument.querySelector("#__NEXT_DATA__");
          return sc ? JSON.parse(sc.textContent || "{}") : null;
        } catch { return null; }
      };
      const out = [];
      for (let wk = 1; wk <= 20; wk++) {
        const { url } = await loadScoreboard(wk);
        const data = readNextData();
        if (!data) { out.push({ week: wk, url, status: 200, matchups: 0 }); continue; }
        const pp = data?.props?.pageProps || {};
        const matchups =
          pp?.scoreboard?.matchups || pp?.matchups || pp?.data?.matchups || [];
        out.push({ week: wk, url, status: 200, matchups: Array.isArray(matchups) ? matchups.length : 0, data: pp });
      }
      return out;
    },
  });

  let rows = [];
  if (Array.isArray(fall)) {
    for (const wk of fall) {
      dbg.push("scoreboard", `week ${wk.week} matchups=${wk.matchups}`, {
        season: year, week: wk.week, url: wk.url, status: wk.status, rows: wk.matchups
      });
      if (!wk.data || !wk.matchups) continue;

      const pp = wk.data;
      const matchups = pp?.scoreboard?.matchups || pp?.matchups || pp?.data?.matchups || [];
      const owners = (pp?.members || pp?.league?.members || []).reduce((map, m) => {
        if (m?.id) map[m.id] = m.displayName || `${m.firstName || ""} ${m.lastName || ""}`.trim();
        return map;
      }, {});
      const leagueName =
        pp?.league?.settings?.name || pp?.leagueSettings?.name || pp?.league?.settings?.leagueName || "";
      const scoring = pp?.league?.settings?.scoringType || "";

      for (const m of matchups) {
        const homeTeam = m?.homeTeam || m?.home || m?.teams?.find?.((t) => t?.homeAway === "home");
        const awayTeam = m?.awayTeam || m?.away || m?.teams?.find?.((t) => t?.homeAway === "away");
        if (!homeTeam || !awayTeam) continue;

        const tier  = (m?.playoffTierType || "").toString().toUpperCase();
        const mtype = (m?.matchupType || "").toString().toUpperCase();
        const isPO  = (tier && tier !== "NONE") || /PLAYOFF|CHAMP/.test(mtype);
        const isWB  = isPO && !/LOSER|CONSOLATION/.test(tier) &&
                      (/WINNER|CHAMP/.test(tier) || /WINNER|CHAMP/.test(mtype));

const hs = Number(homeTeam?.totalPoints ?? homeTeam?.score ?? homeTeam?.points ?? 0) || 0;
const as = Number(awayTeam?.totalPoints ?? awayTeam?.score ?? awayTeam?.points ?? 0) || 0;

// NEW: capture ESPN live projections (if available)
const hProj = Number(homeTeam?.totalProjectedPointsLive ?? 0) || 0;
const aProj = Number(awayTeam?.totalProjectedPointsLive ?? 0) || 0;

// NEW: winner from scoreboard JSON if provided; fallback to points
const win = (m?.winner || "").toString().toUpperCase();

const homeRes = win === "HOME" ? "W" : win === "AWAY" ? "L" : (hs > as ? "W" : hs < as ? "L" : "T");
const awayRes = homeRes === "W" ? "L" : homeRes === "L" ? "W" : "T";

        const tn = (t) => (t?.team?.location && t?.team?.nickname)
            ? `${t.team.location} ${t.team.nickname}`
            : (t?.team?.name || t?.name || "");
        const hName = tn(homeTeam), aName = tn(awayTeam);

        const getOwner = (t) =>
          owners[t?.team?.primaryOwner] || owners[(t?.team?.owners || [])[0]] || t?.owner || "";

        const hOwner = getOwner(homeTeam), aOwner = getOwner(awayTeam);

      rows.push({
  season: year, week: wk.week, manager: hOwner, opponent: aOwner, team_name: hName,
  points_for: hs, points_against: as, proj_for: hProj, proj_against: aProj,  // NEW
  result: homeRes,
  final_rank: "", league_name: leagueName, platform: "ESPN", scoring,
  is_playoff: !!isPO, is_winners_bracket: !!isWB, playoff_tier: tier || undefined, matchup_type: mtype || undefined,
});
    rows.push({
  season: year, week: wk.week, manager: aOwner, opponent: hOwner, team_name: aName,
  points_for: as, points_against: hs, proj_for: aProj, proj_against: hProj,  // NEW
  result: awayRes,
  final_rank: "", league_name: leagueName, platform: "ESPN", scoring,
  is_playoff: !!isPO, is_winners_bracket: !!isWB, playoff_tier: tier || undefined, matchup_type: mtype || undefined,
});

      }
    }
  }
  dbg.push("scoreboard-summary", `rows=${rows.length}`, { season: year, rows: rows.length });
  return { rows, slim };
}

/* ---------------- UI bindings ---------------- */
document.addEventListener("DOMContentLoaded", () => {
  loadAppUrl().catch(() => {});
  $("#go").addEventListener("click", () =>
    run().catch((e) => logLine(e.message || String(e), "err"))
  );
});

async function run() {
  $("#msg").textContent = "";

  // app url
  let appUrl = $("#appUrl").value.trim() || DEFAULT_APP_URL;
  if (!/^https?:\/\//i.test(appUrl)) return logLine("Please enter a valid App URL", "err");
  if (!appUrl.endsWith("/")) appUrl += "/";
  await saveAppUrl(appUrl);

  // tab guard
  const tab = await getActiveTab();
  if (!tab) return logLine("No active tab.", "err");
  if (!/^https:\/\/fantasy\.espn\.com\//.test(tab.url)) {
    return logLine("Current tab is not an ESPN league page.", "err");
  }

  // read league meta + cookies status from page
  logLine("Detecting leagueId & season…");
  const [{ result: meta }] = await chrome.scripting.executeScript({
    target: { tabId: tab.id },
    func: () => {
      const url = new URL(location.href);
      const leagueId =
        url.searchParams.get("leagueId") || (location.href.match(/leagueId=(\d+)/) || [])[1] || null;
      const currentSeason =
        Number(url.searchParams.get("seasonId")) || new Date().getFullYear();
      const swid = (document.cookie.match(/(?:^|;\s*)SWID=([^;]+)/) || [])[1] || "";
      const swidMasked = swid ? swid.replace(/\{?([0-9A-F-]{6}).+([0-9A-F-]{6})\}?/i, "{$1…$2}") : "";
      return { leagueId, currentSeason, swidMasked };
    },
  });
  if (!meta?.leagueId) return logLine("Could not detect leagueId.", "err");
  logLine(`leagueId=${meta.leagueId}, currentSeason=${meta.currentSeason}`);
  logLine(`SWID (mask): ${meta.swidMasked || "(not found)"}`);

  // quick cookie sanity check
  logLine("Verifying espn_s2 (by hitting API with credentials) …");
  const [{ result: cookieProbe }] = await chrome.scripting.executeScript({
    target: { tabId: tab.id },
    args: [meta.leagueId, meta.currentSeason, VIEWS],
    func: async (leagueId, yr, views) => {
      const url =
        `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/${yr}/segments/0/leagues/${leagueId}?${views}`;
      try {
        const res = await fetch(url, { credentials: "include" });
        return { url, status: res.status, ok: res.ok };
      } catch (e) {
        return { url, status: 0, ok: false, err: String(e) };
      }
    },
  });
  logLine(`Cookie probe → ${cookieProbe.status} (${cookieProbe.ok ? "OK" : "FAIL"})`);
  if (!cookieProbe.ok) logLine("If this is 401/403, espn_s2 may be missing/expired.", "err");

  // legacy options
  const wantLegacy = $("#legacyOpt")?.checked;
  const earliest = Number($("#legacyEarliest")?.value || 2013);
  const wantDebugCsv = $("#downloadLegacyCsv")?.checked;

  // debug buffer
  const dbg = makeDebug();
  dbg.push("meta", "start", { season: meta.currentSeason });

  // --------------- LEGACY (≤2017) ---------------
  let legacyRows = [];
  const legacySlims = [];
  if (wantLegacy) {
    const start = Math.min(Math.max(earliest || 2013, 2010), 2017);
    const end = 2017;
    logLine(`Legacy ON: seasons ${start} → ${end}`);

    for (let y = end; y >= start; y--) {
      logLine(`· ${y}: leagueHistory + fallback`);
      const { rows, slim } = await legacyFetchSeasonWithLogs(tab.id, meta.leagueId, y, dbg);
      if (Array.isArray(rows) && rows.length) legacyRows.push(...rows);
      if (slim) legacySlims.push(slim);
      dbg.push("season-summary", `done rows=${Array.isArray(rows) ? rows.length : 0}`, {
        season: y, rows: Array.isArray(rows) ? rows.length : 0
      });
      await new Promise((r) => setTimeout(r, 120));
    }

    logLine(`Legacy total rows: ${legacyRows.length}`);
    if (wantDebugCsv) {
      if (legacyRows.length) {
        const headers = [
          "season","week","manager","opponent","team_name",
          "points_for","points_against","result","final_rank",
          "league_name","platform","scoring","is_playoff","is_winners_bracket","playoff_tier","matchup_type"
        ];
        const csv = makeCsv(headers, legacyRows);
        await downloadCsv(`espn_legacy_${meta.leagueId}_pre2018.csv`, csv);
        logLine("Downloaded legacy rows CSV.");
      }
      const dbgCsv = dbg.csv();
      await downloadCsv(`espn_legacy_debug_${meta.leagueId}.csv`, dbgCsv);
      logLine("Downloaded legacy DEBUG CSV.");
    }
  } else {
    logLine("Legacy OFF — skipping.");
  }

  // ---------------- ESPN API (2018+) ----------------
  logLine("Collecting seasons from ESPN API (2018+) …");

  const [{ result: handoff }] = await chrome.scripting.executeScript({
    target: { tabId: tab.id },
    args: [meta.leagueId, meta.currentSeason, VIEWS],
    func: async (leagueId, currentSeason, views) => {
      // ---------- helpers ----------
      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

      const inferWeekFromDate = (epochMs, seasonYear) => {
        try {
          const d = new Date(epochMs);
          const approxSeasonStart = new Date(seasonYear, 8, 1); // Sept 1
          const diffDays = Math.max(0, Math.floor((d - approxSeasonStart) / 86400000));
          const week = Math.floor(diffDays / 7) + 1;
          return Math.max(1, Math.min(22, week));
        } catch { return 0; }
      };

      // Build per-team rosters by week from a full-season schedule JSON (fast baseline)
      function buildRostersByTeamByWeekFromSchedule(json) {
        const byTeam = {};
        const seasonId = Number(json?.seasonId) || null;

        const put = (tid, wk, entry) => {
          const t = Number(tid), w = Number(wk);
          if (!Number.isFinite(t) || !Number.isFinite(w)) return;
          if (!byTeam[t]) byTeam[t] = {};
          if (!byTeam[t][w]) byTeam[t][w] = [];
          byTeam[t][w].push(entry);
        };

        const readPid = (e) => {
          const pe = e?.playerPoolEntry || e;
          const p  = pe?.player || pe;
          const id = p?.id ?? e?.playerId ?? pe?.id ?? e?.playerPoolEntryId ?? e?.player?.id ?? e?.playerPoolEntry?.player?.id ?? null;
          return Number.isFinite(Number(id)) ? Number(id) : null;
        };

        const readLineupSlotId = (e) => {
          if (Number.isFinite(e?.lineupSlotId)) return Number(e.lineupSlotId);
          if (Number.isFinite(e?.lineupSlotIdFinal)) return Number(e.lineupSlotIdFinal);
          const pe = e?.playerPoolEntry || e;
          if (Number.isFinite(pe?.lineupSlotId)) return Number(pe.lineupSlotId);
          if (Number.isFinite(pe?.lineupSlotIdFinal)) return Number(pe.lineupSlotIdFinal);
          return null;
        };
const readDefaultPosId = (e) => {
  const pe = e && (e.playerPoolEntry || e);
  const p  = pe && (pe.player || pe);
  const n  = Number(p && p.defaultPositionId);
  return Number.isFinite(n) && n > 0 ? n : null;
};



        // ADD — choose the “real” weekly row when duplicates exist for the same pid
        function pickBestWeeklyEntry(candidates, sideTeamId, week, seasonId) {
          const score = (e) => {
            const pe = e?.playerPoolEntry || e;
            const p  = pe?.player || pe;
            const ls = readLineupSlotId(e);
            const hasRealSlot = Number.isFinite(ls) && ls !== 0;

            // does player's stats include an actual (statSourceId = 1) row for this week?
            const stats = Array.isArray(p?.stats) ? p.stats : [];
            const hasActual = stats.some(s =>
              Number(s?.seasonId) === Number(seasonId) &&
              Number(s?.scoringPeriodId) === Number(week) &&
              Number(s?.statSourceId) === 1
            );

            const w = (b, pts) => (b ? pts : 0);
            return (
              w(e?.lineupLocked === true, 8) +
              w((e?.onTeamId ?? pe?.onTeamId) === sideTeamId, 4) +
              w(hasRealSlot, 16) +
              w(hasActual, 2)
            );
          };

          let best = null, bestScore = -1;
          for (const e of candidates) {
            const s = score(e);
            if (s > bestScore) { best = e; bestScore = s; }
          }
          return best || candidates[0];
        }

        const readName = (e) => {
          const pe = e?.playerPoolEntry || e;
          const p  = pe?.player || pe;
          return p?.fullName || (p?.firstName && p?.lastName ? `${p.firstName} ${p.lastName}`.trim() : (p?.name || ""));
        };

        const pointsFor = (e, week) => {
          let pts = Number(
            e?.appliedTotal ??
            e?.appliedStatTotal ??
            e?.playerPoints?.appliedTotal ??
            (e?.playerPoolEntry ? e.playerPoolEntry.appliedStatTotal : undefined) ??
            e?.totalPoints ?? 0
          );
          if (Number.isFinite(pts) && pts !== 0) return pts;

          const pe = e?.playerPoolEntry || e;
          const p  = pe?.player || pe;
          const stats = Array.isArray(p?.stats) ? p.stats : [];
          const srow = stats.find(s => Number(s?.scoringPeriodId) === Number(week) && Number(s?.seasonId) === Number(seasonId));
          if (srow) {
            pts = Number(srow?.appliedTotal ?? srow?.appliedStatTotal ?? srow?.total ?? 0);
            if (Number.isFinite(pts)) return pts;
          }
          return 0;
        };
// NEW: read start-of-week projection from same entry
const projectionFor = (e, week, seasonId) => {
  const pe = e?.playerPoolEntry || e;
  const p  = pe?.player || pe;
  const stats = Array.isArray(p?.stats) ? p.stats : [];
  const s = stats.find(
    (st) =>
      Number(st?.seasonId) === Number(seasonId) &&
      Number(st?.scoringPeriodId) === Number(week) &&
      Number(st?.statSourceId) === 1 &&  // projection
      Number(st?.statSplitTypeId) === 1
  );
  return Number(s?.appliedTotal ?? s?.appliedStatTotal ?? 0) || 0;
};
        // per-slot counters so WR1/WR2, FLEX1/FLEX2, etc. are stable
        const counters = {};
        const nextOrder = (tid, wk, slotId) => {
          const t = Number(tid), w = Number(wk);
          if (!counters[t]) counters[t] = {};
          if (!counters[t][w]) counters[t][w] = {};
          const key = Number.isFinite(slotId) ? slotId : -1;
          counters[t][w][key] = (counters[t][w][key] || 0) + 1;
          return counters[t][w][key];
        };

        const schedule = Array.isArray(json?.schedule) ? json.schedule : [];
        for (const g of schedule) {
          const week = Number(g?.matchupPeriodId ?? g?.scoringPeriodId ?? 0) || null;
          if (!week) continue;

          for (const side of [g?.home, g?.away]) {
            const teamId = side?.teamId ?? side?.team?.id ?? null;
            if (teamId == null) continue;

            const roster =
  side?.rosterForCurrentScoringPeriod ??   // <-- prefer this
  side?.rosterForScoringPeriod ??          // then generic scoring period
  side?.rosterForMatchupPeriod ??          // lastly matchup period (often placeholder)
  side?.roster ?? {};


            const entries = Array.isArray(roster?.entries)
              ? roster.entries
              : Array.isArray(roster?.players)
              ? roster.players
              : [];

            // AFTER — group duplicates per pid, pick the “real” one, then write
            const byPid = new Map();
            for (const e of entries) {
              const pid = readPid(e);
              if (!pid) continue;
              if (!byPid.has(pid)) byPid.set(pid, []);
              byPid.get(pid).push(e);
            }

            for (const [pid, cand] of byPid.entries()) {
              const chosen = pickBestWeeklyEntry(cand, teamId, week, seasonId);
              const rowSlotId = readLineupSlotId(chosen);        // <- only lineupSlotId variants
              const name      = readName(chosen) || `Player ${pid}`;
              const posId     = readDefaultPosId(chosen);
              const pts       = pointsFor(chosen, week);

              const slotOrder = Number.isFinite(rowSlotId) ? nextOrder(teamId, week, rowSlotId) : 1;

              const proj = projectionFor(chosen, week, seasonId);
put(teamId, week, {
  pid,
  name,
  lineupSlotId: Number.isFinite(rowSlotId) ? rowSlotId : null,
  slotOrder,
  pts: Number.isFinite(pts) ? pts : 0,
  proj: Number.isFinite(proj) ? proj : 0,
  defaultPositionId: Number.isFinite(posId) ? posId : null
});

            }
          }
        }
        return byTeam;
      }

      // Slow but complete weekly calls (2019+ only)
      async function fetchWeeklyRostersYear(leagueId, yr) {
        const out = {};
        const weeks = 22;
        for (let wk = 1; wk <= weeks; wk++) {
          const url =
            `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/${yr}/segments/0/leagues/${leagueId}` +
            `?scoringPeriodId=${wk}&view=mRoster&view=mBoxscore&view=mTeam`;
          try {
            const res = await fetch(url, { credentials: "include" });
            if (!res.ok) { await sleep(60); continue; }
            const js = await res.json();
            const part = buildRostersByTeamByWeekFromSchedule(js);
            for (const [tidStr, wkMap] of Object.entries(part)) {
              const tid = Number(tidStr);
              out[tid] = out[tid] || {};
              for (const [wStr, arr] of Object.entries(wkMap)) {
                const w = Number(wStr);
                out[tid][w] = out[tid][w] || [];
                const seen = new Set(out[tid][w].map(r => `${r.pid}|${r.lineupSlotId??-1}`));
                for (const r of arr) {
                  const key = `${r.pid}|${r.lineupSlotId??-1}`;
                  if (!seen.has(key)) {
                    out[tid][w].push(r);
                    seen.add(key);
                  }
                }
              }
            }
          } catch {}
          await sleep(60);
        }
        return out;
      }

      // Convert map → ESPN-like team roster so your app can render immediately
      function convertRostersMapToTeamRoster(rostersMap) {
        const out = {};
        for (const [tidStr, wkMap] of Object.entries(rostersMap || {})) {
          const tid = Number(tidStr);
          const entriesByScoringPeriod = {};

          for (const [wkStr, arr] of Object.entries(wkMap || {})) {
            const wk = Number(wkStr);
            const sorted = [...(arr || [])].sort((a, b) => {
              const sa = Number.isFinite(a?.lineupSlotId) ? a.lineupSlotId : 999;
              const sb = Number.isFinite(b?.lineupSlotId) ? b.lineupSlotId : 999;
              if (sa !== sb) return sa - sb;
              if ((b.pts || 0) !== (a.pts || 0)) return (b.pts || 0) - (a.pts || 0);
              return String(a.name).localeCompare(String(b.name));
            });

           entriesByScoringPeriod[wk] = sorted.map((r) => ({
  lineupSlotId: Number.isFinite(r?.lineupSlotId) ? r.lineupSlotId : null,
  playerPoolEntry: { player: { id: Number(r?.pid), fullName: r?.name || `Player ${r?.pid}`, defaultPositionId:
    Number.isFinite(r?.defaultPositionId) && r.defaultPositionId > 0 ? r.defaultPositionId : null
  } },
  playerPoints: { appliedTotal: Number.isFinite(r?.pts) ? r.pts : 0 },
  appliedTotal: Number.isFinite(r?.pts) ? r.pts : 0,     // actual
  projectedStart: Number.isFinite(r?.projStart) ? r.projStart : null, // <— add this
  slotOrder: Number.isFinite(r?.lineupOrder) ? r.lineupOrder : undefined,
}));

          }
          out[tid] = { roster: { entriesByScoringPeriod } };
        }
        return out;
      }

      // Transactions slim (unchanged)
      const buildTransactionsSlimFromAPI = (json, seasonYear) => {
        const txArr = Array.isArray(json?.transactions) ? json.transactions : [];
        const out = [];
        const addSet = new Set();
        const seen = new Set();

        for (const tx of txArr) {
          const items = Array.isArray(tx?.items) ? tx.items : [];
          for (const it of items) {
            const t = (it?.type || tx?.type || "").toString().toUpperCase();
            if (t !== "ADD") continue;

            const playerId =
              it?.playerId ?? it?.playerPoolEntryId ?? it?.player?.id ??
              it?.playerPoolEntry?.player?.id ?? it?.id ?? null;

            const toTeamId = it?.toTeamId ?? it?.toTeam?.id ?? tx?.toTeamId ?? tx?.teamId ?? null;

            const scoringPeriodId =
              Number(tx?.scoringPeriodId ?? tx?.matchupPeriodId ?? it?.scoringPeriodId ?? 0) ||
              (tx?.executionDate ? inferWeekFromDate(tx.executionDate, seasonYear) : 0);

            const exec = tx?.executionDate || null;
            if (!playerId || !toTeamId || !scoringPeriodId) continue;

            const key = `${playerId}|${toTeamId}|${scoringPeriodId}|${exec||0}`;
            if (seen.has(key)) continue;
            seen.add(key);

            out.push({
              type: "ADD", playerId, toTeamId, teamId: toTeamId,
              scoringPeriodId, week: scoringPeriodId,
              executionDate: exec,
              pickupType: tx?.subType || tx?.type || null,
              bidAmount: Number(tx?.bidAmount ?? tx?.waiverBidAmount ?? tx?.faabBidAmount ?? 0) || null,
            });
            addSet.add(playerId);
          }
        }
        out.sort((a, b) => (a.week || 0) - (b.week || 0));
        return { txSlim: out, addSet };
      };

      // Current-season-only: scrape 2 pages of Recent Activity for FAAB/waivers
      async function scrapeRecentActivityAdds(seasonYear) {
        const iframeId = "fl-activity-scrape";
        let iframe = document.getElementById(iframeId);
        if (!iframe) {
          iframe = document.createElement("iframe");
          iframe.id = iframeId;
          iframe.style.cssText = "position:fixed;left:-99999px;top:-99999px;width:1px;height:1px";
          iframe.setAttribute("sandbox", "allow-same-origin allow-scripts");
          document.body.appendChild(iframe);
        }
        const pages = 2;
        const out = [];
        const seen = new Set();
        const load = (page) => new Promise((resolve) => {
          const url = `https://fantasy.espn.com/football/league/recentactivity?leagueId=${leagueId}&seasonId=${seasonYear}&page=${page}`;
          const onload = () => { iframe.removeEventListener("load", onload); resolve({ url }); };
          iframe.addEventListener("load", onload);
          iframe.src = url;
        });
        const getJSON = () => {
          try {
            const sc = iframe.contentDocument.querySelector("#__NEXT_DATA__");
            return sc ? JSON.parse(sc.textContent || "{}") : null;
          } catch { return null; }
        };
        const walk = (obj) => {
          if (!obj || typeof obj !== "object") return;
          for (const v of Object.values(obj)) {
            if (Array.isArray(v)) {
              for (const a of v) {
                if (a && typeof a === "object" && Array.isArray(a.items)) {
                  const exec = Number(a?.date || a?.executionDate || 0) || null;
                  for (const it of a.items) {
                    const t = (it?.type || a?.type || "").toString().toUpperCase();
                    if (t !== "ADD") continue;
                    const playerId = it?.playerId ?? it?.player?.id ?? it?.playerPoolEntryId ?? it?.id ?? null;
                    const toTeamId = it?.toTeamId ?? it?.toTeam?.id ?? a?.toTeamId ?? null;
                    if (!playerId || !toTeamId) continue;
                    const week = exec ? inferWeekFromDate(exec, seasonYear) : 0;
                    const key = `${playerId}|${toTeamId}|${week}|${exec||0}`;
                    if (seen.has(key)) continue;
                    seen.add(key);
                    out.push({
                      type: "ADD", playerId, toTeamId, teamId: toTeamId,
                      scoringPeriodId: week, week, executionDate: exec,
                      pickupType: a?.subType || a?.type || "ADD",
                      bidAmount: Number(a?.bidAmount ?? a?.faabBidAmount ?? 0) || null,
                    });
                  }
                }
              }
            } else if (v && typeof v === "object") {
              walk(v);
            }
          }
        };
        for (let p = 1; p <= pages; p++) {
          await load(p);
          const data = getJSON();
          if (!data) continue;
          walk(data?.props || data?.pageProps || data);
        }
        out.sort((a, b) => (a.week || 0) - (b.week || 0));
        return out;
      }

      // Draft-aware roster inference (unchanged)
      function inferAddsFromRosters(json, seasonYear) {
        const sched = Array.isArray(json?.schedule) ? json.schedule : [];
        const draftedByTeam = new Map();
        const picks = Array.isArray(json?.draftDetail?.picks) ? json.draftDetail.picks : [];
        for (const p of picks) {
          const pid = p?.playerId ?? p?.player?.id ?? null;
          const tid = p?.teamId ?? p?.team?.id ?? null;
          if (pid && tid != null) {
            if (!draftedByTeam.has(tid)) draftedByTeam.set(tid, new Set());
            draftedByTeam.get(tid).add(pid);
          }
        }
        const firstSeen = new Map();
        for (const g of sched) {
          const week = Number(g?.matchupPeriodId) || 0;
          if (!week) continue;
          for (const side of [g?.home, g?.away]) {
            const teamId = side?.teamId ?? side?.team?.id ?? null;
            if (teamId == null) continue;
            const roster =
              side?.rosterForMatchupPeriod ?? side?.rosterForScoringPeriod ??
              side?.rosterForCurrentScoringPeriod ?? side?.roster ?? {};
            const entries = Array.isArray(roster?.entries) ? roster.entries
                            : (Array.isArray(roster?.players) ? roster.players : []);
            for (const e of entries) {
              const pe = e?.playerPoolEntry || e;
              const pid = pe?.player?.id ?? e?.playerId ?? pe?.id ?? pe?.playerPoolEntryId ?? null;
              if (!pid) continue;
              if (!firstSeen.has(teamId)) firstSeen.set(teamId, new Map());
              const map = firstSeen.get(teamId);
              if (!map.has(pid)) map.set(pid, week);
            }
          }
        }
        const out = [];
        const seen = new Set();
        for (const [teamId, pidMap] of firstSeen.entries()) {
          const drafted = draftedByTeam.get(teamId) || new Set();
          for (const [pid, week] of pidMap.entries()) {
            if (drafted.has(pid) && week <= 1) continue;
            const key = `${pid}|${teamId}|${week}`;
            if (seen.has(key)) continue;
            seen.add(key);
            out.push({
              type: "ADD", playerId: pid, toTeamId: teamId, teamId,
              scoringPeriodId: week, week, executionDate: null,
              pickupType: "INFERRED", bidAmount: null,
            });
          }
        }
        out.sort((a, b) => (a.week || 0) - (b.week || 0));
        return out;
      }

      // weekly points for added players (unchanged)
      const buildWeeklyPointsForAddedPlayers = (json, candidateIds /* Set */) => {
        const out = {};
        const put = (pid, week, pts, name, posId) => {
          if (!pid || !Number.isFinite(week)) return;
          if (!out[pid]) out[pid] = { name: name || `Player ${pid}`, posId: posId || null, weeks: {} };
          out[pid].weeks[week] = Number(out[pid].weeks[week] || 0) + Number(pts || 0);
        };

        const sched = Array.isArray(json?.schedule) ? json.schedule : [];
        for (const g of sched) {
          const week = Number(g?.matchupPeriodId);
          if (!week) continue;
          for (const side of [g?.home, g?.away]) {
            const roster =
              side?.rosterForMatchupPeriod ?? side?.rosterForScoringPeriod ??
              side?.rosterForCurrentScoringPeriod ?? side?.roster ?? {};
            const entries = Array.isArray(roster?.entries) ? roster.entries
                            : (Array.isArray(roster?.players) ? roster.players : []);
            for (const e of entries) {
              const pe = e?.playerPoolEntry || e;
              const pid = pe?.player?.id ?? e?.playerId ?? pe?.id ?? pe?.playerPoolEntryId ?? null;
              if (!pid || (candidateIds && !candidateIds.has(pid))) continue;
              const name = pe?.player?.fullName || pe?.player?.name || "";
              const posId = pe?.player?.defaultPositionId ?? null;
              let pts = Number(
                e?.appliedTotal ?? e?.appliedStatTotal ?? pe?.appliedStatTotal ??
                e?.playerPoints?.appliedTotal ?? e?.totalPoints ?? 0
              );
              if (!isFinite(pts) || pts === 0) {
                const stats = Array.isArray(pe?.player?.stats) ? pe.player.stats : [];
                const wstat = stats.find(s => Number(s?.scoringPeriodId) === week && Number(s?.seasonId) === Number(json?.seasonId));
                if (wstat) pts = Number(wstat?.appliedTotal ?? wstat?.appliedStatTotal ?? wstat?.total) || 0;
              }
              put(pid, week, pts, name, posId);
            }
          }
        }
        return out;
      };

      // lineup slot counts
      function extractLineupSlotsFromAPI(json) {
        const counts = json?.settings?.rosterSettings?.lineupSlotCounts || {};
        const out = {};
        for (const [k, v] of Object.entries(counts)) {
          const sid = Number(k), cnt = Number(v);
          if (Number.isFinite(sid) && Number.isFinite(cnt)) out[sid] = cnt;
        }
        return out;
      }
function extractRosterAcqFromAPI(json) {
  const byTeam = {};
  const teams = Array.isArray(json?.teams) ? json.teams : [];

  for (const t of teams) {
    const tid = Number(t?.id ?? t?.teamId);
    if (!Number.isFinite(tid)) continue;
    const roster = t?.roster || {};

    const entries = [];
    if (Array.isArray(roster.entries)) entries.push(...roster.entries);
    if (Array.isArray(roster.players)) entries.push(...roster.players);
    if (roster.entriesByScoringPeriod && typeof roster.entriesByScoringPeriod === "object") {
      for (const arr of Object.values(roster.entriesByScoringPeriod)) {
        if (Array.isArray(arr)) entries.push(...arr);
      }
    }

    for (const e of entries) {
      const pid = Number(
        e?.playerId ??
        e?.playerPoolEntry?.player?.id ??
        e?.player?.id ??
        e?.id
      );

      const slotId = Number(
        (Number.isFinite(e?.lineupSlotId) ? e.lineupSlotId : null) ??
        (Number.isFinite(e?.lineupSlotIdFinal) ? e.lineupSlotIdFinal : null) ??
        (Number.isFinite(e?.playerPoolEntry?.lineupSlotId) ? e.playerPoolEntry.lineupSlotId : null) ??
        (Number.isFinite(e?.playerPoolEntry?.lineupSlotIdFinal) ? e.playerPoolEntry.lineupSlotIdFinal : null)
      );

      const acq = (e?.acquisitionType || e?.acqType || "").toString().toUpperCase();
      if (!Number.isFinite(pid) || !acq) continue;

      const onTeam = Number(e?.playerPoolEntry?.onTeamId ?? e?.onTeamId ?? tid);
      if (!byTeam[onTeam]) byTeam[onTeam] = {};
      if (!byTeam[onTeam][pid]) {
        // >>> FIX: never coerce missing to 0
        const posRaw =
          e?.player?.defaultPositionId ??
          e?.playerPoolEntry?.player?.defaultPositionId;
        const posId = Number.isFinite(Number(posRaw)) && Number(posRaw) > 0
          ? Number(posRaw)
          : null;

        byTeam[onTeam][pid] = {
          type: acq,
          slotId: Number.isFinite(slotId) ? slotId : null,
          defaultPositionId: posId
        };
      }
    }
  }
  return byTeam;
}
// --- DEBUG: projection sniffer (from schedule → roster entries' player.stats) ---
function sniffProjectionsFromSchedule(json) {
  const out = { projRows: 0, actualRows: 0, sample: null };
  const seasonId = Number(json?.seasonId) || 0;
  const sched = Array.isArray(json?.schedule) ? json.schedule : [];
  outer:
  for (const g of sched) {
    const w = Number(g?.matchupPeriodId ?? g?.scoringPeriodId ?? 0) || 0;
    for (const side of [g?.home, g?.away]) {
      const roster = side?.rosterForCurrentScoringPeriod
        ?? side?.rosterForScoringPeriod
        ?? side?.rosterForMatchupPeriod
        ?? side?.roster
        ?? {};
      const entries = Array.isArray(roster?.entries) ? roster.entries
                    : Array.isArray(roster?.players) ? roster.players
                    : [];
      for (const e of entries) {
        const p = (e?.playerPoolEntry?.player) || e?.player || e;
        const stats = Array.isArray(p?.stats) ? p.stats : [];
        for (const s of stats) {
          if (Number(s?.seasonId) !== seasonId) continue;
          if (Number(s?.statSplitTypeId) !== 1) continue; // weekly totals only
          if (Number(s?.statSourceId) === 1) out.projRows++; // start-of-week projections
          if (Number(s?.statSourceId) === 0) out.actualRows++; // game actuals
          if (!out.sample && (out.projRows || out.actualRows)) {
            out.sample = {
              week: w,
              playerId: Number(p?.id) || null,
              proj: Number(s?.appliedTotal ?? s?.appliedStatTotal ?? 0) || 0,
              sourceId: Number(s?.statSourceId),
            };
            // don't break yet; we want counts too
          }
          if (out.projRows > 50 && out.actualRows > 50) break outer; // good enough
        }
      }
    }
  }
  return out;
}

      // ---------- seasons loop ----------
      const years = [];
      const endYear = Number(currentSeason) || new Date().getFullYear();
      for (let y = endYear; y >= 2018; y--) years.push(y);

      const pickSeason = (json) => {
        if (!json) return null;
        return {
          seasonId: json.seasonId,
          settings: json.settings || {},
          scoringSettings: json.scoringSettings || json.settings?.scoringSettings || {},
          members: json.members || [], teams: json.teams || [], schedule: json.schedule || [],
          draftDetail: json.draftDetail ? {
            draftOrder: json.draftDetail.draftOrder || null,
            picks: Array.isArray(json.draftDetail.picks) ? json.draftDetail.picks : [],
            settings: json.draftDetail.settings || null,
          } : null,
        };
      };

      const seasons = [];
      const rostersByYear = {};
      const lineupSlotsByYear = {};
      const currentWeekByYear = {}; 
      const   rosterAcqByYear = {};
const projectionsDebugByYear = {};
      let totalGames = 0;
let playerProjByYear = {}; // { [season]: { [teamId]: { [week]: { [pid]: { proj, actual } } } } }

      for (const yr of years) {
        const url = `https://lm-api-reads.fantasy.espn.com/apis/v3/games/ffl/seasons/${yr}/segments/0/leagues/${leagueId}?${views}`;
        try {
          const res = await fetch(url, { credentials: "include" });
          if (!res.ok) continue;
          const json = await res.json();
const projSniff = sniffProjectionsFromSchedule(json); 
projectionsDebugByYear[yr] = projSniff; // <— NEW


if (json && json.teams && json.schedule) {
  const slim = pickSeason(json);

  const curWeek =
    Number(json?.status?.currentMatchupPeriod ??
           json?.status?.currentScoringPeriod ??
           json?.status?.currentScoringPeriodId ??
           json?.scoringPeriodId ?? 0) || 0;
  slim.currentWeek = curWeek;         // keep on the season object
  currentWeekByYear[yr] = curWeek;    // keep in a quick lookup map

     const acqMap = extractRosterAcqFromAPI(json);
      if (Object.keys(acqMap).length) rosterAcqByYear[yr] = acqMap;

  if (slim) {
    totalGames += slim.schedule.length;


              // transactions + weekly points
              let { txSlim, addSet } = buildTransactionsSlimFromAPI(json, yr);
              if (!txSlim.length && Number(yr) === Number(currentSeason)) {
                const recovered = await scrapeRecentActivityAdds(yr);
                if (recovered.length) {
                  txSlim = recovered;
                  addSet = new Set(recovered.map(r => r.playerId));
                }
              }
              if (!txSlim.length) {
                const inferred = inferAddsFromRosters(json, yr);
                if (inferred.length) {
                  txSlim = inferred;
                  addSet = new Set(inferred.map(r => r.playerId));
                }
              }
              const weekly = buildWeeklyPointsForAddedPlayers(json, addSet);
              slim.transactionsSlim = txSlim;
              slim.weeklyPointsByPlayer = weekly;

              // --- rosters: schedule baseline + weekly patch for 2019+ ---
              let rostersMap = buildRostersByTeamByWeekFromSchedule(json);

              if (yr >= 2019) {
                const patched = await fetchWeeklyRostersYear(leagueId, yr);

                // Merge: ALWAYS trust weekly lineupSlotId when present
                for (const [tidStr, wkMap] of Object.entries(patched || {})) {
                  const tid = Number(tidStr);
                  rostersMap[tid] = rostersMap[tid] || {};
                  for (const [wkStr, arr] of Object.entries(wkMap || {})) {
                    const wk = Number(wkStr);
                    const cur = rostersMap[tid][wk] || [];
                    const byPid = new Map(cur.map((r, i) => [r.pid, { i, r }]));

                    for (const r of (arr || [])) {
                      const existing = byPid.get(r.pid);
                      const weeklyHasSlot = Number.isFinite(r.lineupSlotId);

                      if (!existing) {
                        byPid.set(r.pid, { i: cur.push(r) - 1, r });
                        continue;
                      }

                      if (weeklyHasSlot) {
                        cur[existing.i] = r; // overwrite with weekly (truth)
                        byPid.set(r.pid, { i: existing.i, r });
                      } else {
                        // keep existing; optionally update points
                        if (Number.isFinite(r.pts) && r.pts !== existing.r.pts) {
                          existing.r.pts = r.pts;
                        }
                      }
                    }

                    rostersMap[tid][wk] = cur;
                  }
                }
              }

              // After merge, recompute per-slot lineupOrder (WR1/WR2, FLEX1/FLEX2, etc.)
              for (const [tidStr, wkMap] of Object.entries(rostersMap || {})) {
                for (const [wkStr, arr] of Object.entries(wkMap || {})) {
                  const bySlot = {};
                  for (const r of arr) {
                    const k = Number.isFinite(r.lineupSlotId) ? r.lineupSlotId : -1;
                    bySlot[k] = (bySlot[k] || 0) + 1;
                    r.lineupOrder = bySlot[k];
                  }
                  // nice stable sort
                  arr.sort((a, b) => {
                    const sa = Number.isFinite(a.lineupSlotId) ? a.lineupSlotId : 999;
                    const sb = Number.isFinite(b.lineupSlotId) ? b.lineupSlotId : 999;
                    if (sa !== sb) return sa - sb;
                    if ((b.pts || 0) !== (a.pts || 0)) return (b.pts || 0) - (a.pts || 0);
                    return String(a.name).localeCompare(String(b.name));
                  });
                }
              }

              // inject ESPN-like roster onto teams[*]
              const teamRosterInject = convertRostersMapToTeamRoster(rostersMap);
              slim.teams = (slim.teams || []).map((t) => {
                const add = teamRosterInject[Number(t?.id)];
                return add ? { ...t, ...add } : t;
              });

              // mirrors
              slim.rostersByTeamByWeek = rostersMap;
              rostersByYear[yr] = rostersMap;

              // lineup slot counts
              let slots = extractLineupSlotsFromAPI(json);
              if (slots && Object.keys(slots).length) {
                lineupSlotsByYear[yr] = slots;
              }

              seasons.push(slim);
            }
          }
        } catch {}
      }
      // --- NEW: Build owner maps from the seasons we already loaded ---
      const ownerByTeamByYear = {};   // { [season]: { [teamId]: "Owner Name" } }
      const teamNamesByOwner = {};    // { "Owner Name": { [season]: "Team Name" } }

      try {
        for (const s of (seasons || [])) {
          const yr = Number(s?.seasonId);
          if (!Number.isFinite(yr)) continue;

          // memberId -> best owner name
          const nameByMemberId = {};
          for (const m of (s?.members || [])) {
            const dn = (m?.displayName || "").trim();
            const fn = (m?.firstName || "").trim();
            const ln = (m?.lastName || "").trim();
            const best = dn || [fn, ln].filter(Boolean).join(" ").trim() || "Unknown";
            if (m?.id != null) nameByMemberId[m.id] = best;
          }

          ownerByTeamByYear[yr] = ownerByTeamByYear[yr] || {};

          for (const t of (s?.teams || [])) {
            const teamId = Number(t?.id);
            if (!Number.isFinite(teamId)) continue;

            const ownerId = t?.primaryOwner || (Array.isArray(t?.owners) && t.owners[0]) || null;
            const owner   = nameByMemberId[ownerId] || `Team ${teamId}`;

            const teamName = (t?.location && t?.nickname)
              ? `${t.location} ${t.nickname}`.trim()
              : (t?.name || `Team ${teamId}`);

            ownerByTeamByYear[yr][teamId] = owner;

            if (!teamNamesByOwner[owner]) teamNamesByOwner[owner] = {};
            teamNamesByOwner[owner][yr] = teamName;
          }
        }
      } catch (e) {
        console.warn("Owner map build failed:", e);
      }

      if (!seasons.length) return { ok: false, msg: "No seasons returned" };
      const leagueName =
        seasons?.[0]?.settings?.name || seasons?.[0]?.settings?.leagueName || seasons?.[0]?.settings?.leagueNickname || "";
      const jsonLen = JSON.stringify({ seasons }).length;
      // AFTER
return {
  ok: true,
  years,
  seasons,
  rostersByYear,
  lineupSlotsByYear,
  leagueId,
  leagueName,
  count: seasons.length,
  totalGames,
  jsonLen,
  currentWeekByYear,   
 ownerByTeamByYear,
        teamNamesByOwner,
  playerProjByYear,          // still empty today
  projectionsDebugByYear,  
};

    },
  });

 if (!handoff?.ok) {
  logLine(handoff?.msg || "Failed to load 2018+ seasons.", "err");
} else {
  logLine(
    `ESPN seasons loaded (2018+): ${handoff.count} seasons, ${handoff.totalGames} games; payload ~${handoff.jsonLen.toLocaleString()} bytes`,
    "ok"
  );
// --- DEBUG: show what we saw for projections ---
try {
  const dbgMap = handoff?.projectionsDebugByYear || {};
  const rollup = Object.entries(dbgMap).map(([y, d]) => {
    const P = Number(d?.projRows || 0);
    const A = Number(d?.actualRows || 0);
    return `${y}: projRows=${P}, actualRows=${A}` + (d?.sample ? " (sample ok)" : "");
  }).join(" | ");
  logLine("Projections sniff summary → " + (rollup || "(none)"));

  // keep one sample on window for quick console inspection
  window.FL_PROJ_SNIFF = dbgMap;
  const newest = Math.max(...Object.keys(dbgMap || {}).map(Number).filter(Number.isFinite));
  if (Number.isFinite(newest)) {
    const s = dbgMap[newest];
    if (s?.sample) {
      logLine(`Sample @ ${newest} → week ${s.sample.week}, playerId ${s.sample.playerId}, src=${s.sample.sourceId}, val=${s.sample.proj}`);
    }
  }
} catch (e) {
  logLine("Projection sniff debug failed: " + (e.message || e), "warn");
}

  // NEW: sanity logs for owner maps
  const ownersSeasons = Object.keys(handoff.ownerByTeamByYear || {}).length;
  const ownerExampleSeason = Math.max(...Object.keys(handoff.ownerByTeamByYear || {}).map(Number).filter(Number.isFinite));
  const exampleTeams = ownerExampleSeason ? Object.keys(handoff.ownerByTeamByYear[ownerExampleSeason] || {}).length : 0;
  logLine(`Owner map seasons=${ownersSeasons}, latest season teams mapped=${exampleTeams}`);
  const md = Object.keys(handoff.teamNamesByOwner || {}).find(k => /michael\s+doto/i.test(k));
  if (md) logLine(`Owner found: ${md} (team in ${ownerExampleSeason}: ${(handoff.teamNamesByOwner[md]||{})[ownerExampleSeason]||"n/a"})`);
}

// ---------- PROJECTIONS now merged directly into roster entries ----------
logLine("Using embedded projections from schedule JSON …");
const combinedRows = [];
for (const [season, byTeam] of Object.entries(handoff?.rostersByYear || {})) {
  for (const [tid, byWeek] of Object.entries(byTeam || {})) {
    for (const [wk, arr] of Object.entries(byWeek || {})) {
      for (const r of arr || []) {
        combinedRows.push({
          season: season,
          teamId: tid,
          week: wk,
          playerId: r.pid,
          name: r.name,
          pts: r.pts ?? 0,
          proj: r.proj ?? 0,
        });
      }
    }
  }
}
const csv = makeCsv(["season","teamId","week","playerId","name","pts","proj"], combinedRows);
await downloadCsv(`espn_roster_with_proj_${handoff?.leagueId || meta.leagueId}.csv`, csv);
logLine(`Downloaded roster+projection CSV (${combinedRows.length.toLocaleString()} rows).`, "ok");

// Pull acquisitions using the EXACT console method across seasons
logLine("Pulling roster acquisitions (console method) …");

const yearsForAcq = (handoff?.years && handoff.years.length)
  ? handoff.years
  : (() => {
      const out = [];
      for (let y = Number(meta.currentSeason); y >= 2018; y--) out.push(y);
      return out;
    })();
// Pull acquisitions using the EXACT console method across seasons
logLine("Pulling roster acquisitions (console method) …");

const { map: apiAcqMap, flat: apiAcqFlat } =
  await fetchRosterAcqAPIYears(
    tab.id,
    handoff?.leagueId || meta.leagueId,
    yearsForAcq,
    dbg
  );

// Normalize to rich map: season -> teamId -> playerId -> { acquisitionType, slotId, slot, name }
const rosterAcqByYear = {};
for (const [season, teams] of Object.entries(apiAcqMap || {})) {
  rosterAcqByYear[season] = {};
  for (const [tid, players] of Object.entries(teams || {})) {
    rosterAcqByYear[season][tid] = {};
    for (const [pid, rec] of Object.entries(players || {})) {
      const acqType = rec && (rec.type || rec.acquisitionType)
        ? String(rec.type || rec.acquisitionType).toUpperCase()
        : "";
      const slotId = Number.isFinite(rec?.slotId) ? rec.slotId : null;
      const slotLabel = Number.isFinite(slotId) ? (ESPN_SLOT_NAME[slotId] || String(slotId)) : "";
      rosterAcqByYear[season][tid][pid] = {
        acquisitionType: acqType,
        slotId,
        slot: slotLabel,
	defaultPositionId:
  (Number.isFinite(rec?.defaultPositionId) && rec.defaultPositionId > 0)
    ? rec.defaultPositionId
    : null,
        name: rec?.name || ""
      };
    }
  }
}

const acqSummary = Object.entries(rosterAcqByYear)
  .map(([y, byTeam]) =>
    `${y}:${Object.values(byTeam).reduce((s, m) => s + Object.keys(m || {}).length, 0)}`
  )
  .join(", ");
logLine("Roster acquisition rows by year (API console method) → " + acqSummary);

// Keep this flat array around for CSV debug
const rosterAcqFlat = apiAcqFlat;
  // Save popup-state so the Download Combined button can read it
  window.FL_STATE = {
    seasons: handoff?.seasons || [],
    legacyRows,
    leagueId: handoff?.leagueId || meta.leagueId,
  };

  if ($("#downloadLegacyCsv")?.checked) {
    try {
      const apiOnly = (handoff?.seasons || []).length;
      logLine(`(debug) seasons in hand-off: ${apiOnly}, legacy rows: ${legacyRows.length}`);
    } catch {}
  }

  // ---------- ADP ----------
  logLine("Fetching FantasyPros PPR ADP (by year) …");
  const adpByYear = {};
  const adpRichByYear = {};
  if (handoff?.years?.length) {
    for (const yr of handoff.years) {
      const { simple, rich } = await getFantasyProsADPForYear(yr);
      adpByYear[yr] = simple || {};
      adpRichByYear[yr] = rich || {};
    }
  }
// Slim a deep copy of rostersByYear to avoid blowing up window.name
const rostersByYearSlim = {};
for (const [season, byTeam] of Object.entries(handoff?.rostersByYear || {})) {
  rostersByYearSlim[season] = {};
  for (const [tid, byWeek] of Object.entries(byTeam || {})) {
    rostersByYearSlim[season][tid] = {};
    for (const [wk, arr] of Object.entries(byWeek || {})) {
    rostersByYearSlim[season][tid][wk] = (arr || []).map(r => ({
  pid: r.pid,
  name: r.name,
  lineupSlotId: Number.isFinite(r?.lineupSlotId) ? r.lineupSlotId : null,
  slotOrder: Number.isFinite(r?.lineupOrder) ? r.lineupOrder : undefined,
  pts: Number.isFinite(r?.pts) ? r.pts : 0,                        // actual
proj: Number.isFinite(r?.proj) ? r.proj : 0,
projStart: Number.isFinite(r?.proj) ? r.proj : null,
  defaultPositionId:
    Number.isFinite(r?.defaultPositionId) && r.defaultPositionId > 0
      ? r.defaultPositionId
      : null
}));

    }
  }
}

const payload = {
  seasons: handoff?.seasons || [],
  adpByYear,
  adpRichByYear,
  leagueId: handoff?.leagueId || meta.leagueId,
  leagueName: handoff?.leagueName || "",
  legacyRows,
  legacySeasonsLite: legacySlims,
  rostersByYear: rostersByYearSlim,
  lineupSlotsByYear: handoff?.lineupSlotsByYear || {},
  currentWeekByYear: handoff?.currentWeekByYear || {},   
  rosterAcqByYear, 
    ownerByTeamByYear: handoff?.ownerByTeamByYear || {},
  teamNamesByOwner: handoff?.teamNamesByOwner || {},
};


  const payloadLen = JSON.stringify(payload).length;
  logLine(`Final handoff size: ~${payloadLen.toLocaleString()} bytes`);

  // quick counts
  const picksByYear = Object.fromEntries((handoff?.seasons || []).map((s) => [s.seasonId, (s?.draftDetail?.picks || []).length]));
  logLine("Draft picks by year → " + Object.entries(picksByYear).map(([y, n]) => `${y}:${n}`).join(", "));

  const adpCounts = Object.fromEntries(Object.entries(adpByYear || {}).map(([y, mapObj]) => [y, Object.keys(mapObj || {}).length]));
  logLine("ADP rows by year → " + Object.entries(adpCounts).map(([y, c]) => `${y}:${c}`).join(", "));

  const posCounts = Object.fromEntries(Object.entries(adpRichByYear || {}).map(([y, mapObj]) => [
    y, Object.values(mapObj || {}).filter((v) => v?.pos).length,
  ]));
  logLine("POS rows by year → " + Object.entries(posCounts).map(([y, c]) => `${y}:${c}`).join(", "));

  const addCounts = Object.fromEntries((handoff?.seasons || []).map((s) => [s.seasonId, (s?.transactionsSlim || []).length]));
  const weeklyPlayerCounts = Object.fromEntries((handoff?.seasons || []).map((s) => [s.seasonId, Object.keys(s?.weeklyPointsByPlayer || {}).length]));
  logLine("ADDs by year → " + Object.entries(addCounts).map(([y, c]) => `${y}:${c}`).join(", "));
  logLine("Weekly-pts players by year → " + Object.entries(weeklyPlayerCounts).map(([y, c]) => `${y}:${c}`).join(", "));

  logLine(
    "Lineup slots by year → " +
    Object.entries(payload.lineupSlotsByYear || {})
      .map(([y, m]) => `${y}:${Object.values(m||{}).reduce((a,b)=>a+Number(b||0),0)} slots`)
      .join(", ")
  );

  await chrome.scripting.executeScript({
    target: { tabId: tab.id },
    args: [payload, appUrl],
    func: (payload, appUrl) => {
      window.name = JSON.stringify(payload);
      location.replace(appUrl.split("?")[0].split("#")[0]);
    },
  });

// ---- DEBUG: Owner/Member mapping CSV (grouped by first+last — MINIMAL: latest season only) ----
(async () => {
  try {
    const seasons = handoff?.seasons || [];
    if (!seasons.length) {
      logLine("No seasons to build owner/member CSV.", "warn");
      return;
    }

    // 1) Build per-team/season rows (so we can pick 'latest' later)
    const teamSeasonRows = [];
    for (const s of seasons) {
      const yr = Number(s.seasonId);
      if (!Number.isFinite(yr)) continue;

      // member lookups
      const displayById = {};
      const firstById   = {};
      const lastById    = {};
      const bestById    = {};
      for (const m of (s.members || [])) {
        const id = m?.id;
        if (id == null) continue;
        const dn = (m?.displayName || "").trim();
        const fn = (m?.firstName   || "").trim();
        const ln = (m?.lastName    || "").trim();
        const best = dn || [fn, ln].filter(Boolean).join(" ").trim() || "Unknown";
        displayById[id] = dn;
        firstById[id]   = fn;
        lastById[id]    = ln;
        bestById[id]    = best;
      }

      for (const t of (s.teams || [])) {
        const teamId = Number(t?.id);
        if (!Number.isFinite(teamId)) continue;
        const teamName = (t?.location && t?.nickname)
          ? `${t.location} ${t.nickname}`.trim()
          : (t?.name || `Team ${t?.id}`);

        const owners = (Array.isArray(t?.owners) && t.owners.length)
          ? t.owners
          : (t?.primaryOwner ? [t.primaryOwner] : []);

        const list = owners.length ? owners : [null];
        for (const oid of list) {
          const ownerDisplay = oid ? (displayById[oid] || "") : "";
          const ownerFirst   = oid ? (firstById[oid]   || "") : "";
          const ownerLast    = oid ? (lastById[oid]    || "") : "";
          const ownerBest    = oid ? (bestById[oid]    || "") : "";

          const mapOwner  = handoff?.ownerByTeamByYear?.[yr]?.[teamId] || "";
          const mapTeamNm = ownerBest ? (handoff?.teamNamesByOwner?.[ownerBest]?.[yr] || "") : "";

          teamSeasonRows.push({
            season: yr,
            teamId,
            teamName,
            ownerId: oid || "",
            ownerDisplayName: ownerDisplay,
            ownerFirstName: ownerFirst,
            ownerLastName: ownerLast,
            ownerNameBest: ownerBest,
            map_ownerByTeamByYear: mapOwner,
            map_teamNamesByOwner: mapTeamNm,
          });
        }
      }
    }

    // 2) Group by First+Last (skip if both missing)
    const keyOf = (fn, ln) => `${(fn||"").toLowerCase().trim()}|${(ln||"").toLowerCase().trim()}`;
    const byPerson = new Map(); // key -> { latestRow, allIds:Set, allDisplays:Set, allBests:Set }

    for (const r of teamSeasonRows) {
      const fn = r.ownerFirstName || "";
      const ln = r.ownerLastName  || "";
      if (!fn && !ln) continue;
      const key = keyOf(fn, ln);
      if (!byPerson.has(key)) {
        byPerson.set(key, {
          latestRow: r,
          allIds: new Set(r.ownerId ? [r.ownerId] : []),
          allDisplays: new Set(r.ownerDisplayName ? [r.ownerDisplayName] : []),
          allBests: new Set(r.ownerNameBest ? [r.ownerNameBest] : []),
        });
      } else {
        const agg = byPerson.get(key);
        // track all seen ids/names (optional but useful)
        if (r.ownerId) agg.allIds.add(r.ownerId);
        if (r.ownerDisplayName) agg.allDisplays.add(r.ownerDisplayName);
        if (r.ownerNameBest) agg.allBests.add(r.ownerNameBest);
        // keep the latest season ONLY
        if (Number(r.season) > Number(agg.latestRow?.season || 0)) {
          agg.latestRow = r;
        }
      }
    }

    // 3) Emit ONE CSV row per person (using the latest season row)
    const rows = [];
    for (const agg of byPerson.values()) {
      const r = agg.latestRow || {};
      rows.push({
        ownerFirstName: r.ownerFirstName || "",
        ownerLastName:  r.ownerLastName || "",
        ownerIds_all:   Array.from(agg.allIds).join(" | "),
        ownerDisplayNames_all: Array.from(agg.allDisplays).join(" | "),
        ownerBestNames_all:    Array.from(agg.allBests).join(" | "),
        // latest season identifiers (compact & explicit)
        season: r.season,
        teamId: r.teamId,
        teamName: r.teamName,
        ownerId_latest: r.ownerId,
        ownerDisplayName_latest: r.ownerDisplayName,
        ownerNameBest_latest: r.ownerNameBest,
        map_ownerByTeamByYear_latest: r.map_ownerByTeamByYear || "",
        map_teamNamesByOwner_latest:  r.map_teamNamesByOwner || ""
      });
    }

    if (!rows.length) {
      logLine("Owner/member (unique latest) map empty — no CSV to download.", "warn");
      return;
    }

    const csv = makeCsv(
      [
        "ownerFirstName",
        "ownerLastName",
        "ownerIds_all",
        "ownerDisplayNames_all",
        "ownerBestNames_all",
        "season",
        "teamId",
        "teamName",
        "ownerId_latest",
        "ownerDisplayName_latest",
        "ownerNameBest_latest",
        "map_ownerByTeamByYear_latest",
        "map_teamNamesByOwner_latest"
      ],
      rows
    );

    await downloadCsv("espn_owner_member_unique_latest.csv", csv);
    logLine(`Downloaded owner/member CSV (unique, latest only) — ${rows.length.toLocaleString()} rows.`, "ok");
  } catch (e) {
    logLine("Owner/member (unique latest) CSV error: " + (e.message || e), "warn");
  }
})();
// ---- DEBUG: auto-download rosterAcqByYear CSV (guarded & non-blocking) ----
(async () => {
  try {
    const acq =
      payload && typeof payload.rosterAcqByYear === "object"
        ? payload.rosterAcqByYear
        : null;

    if (!acq || !Object.keys(acq).length) {
      logLine("No rosterAcqByYear in payload — skipping CSV.", "warn");
      return;
    }

    // Build a (season|pid)->name index from rosters so the CSV has friendly names
    const nameIndex = new Map();
    try {
      for (const [seasonStr, teams] of Object.entries(payload.rostersByYear || {})) {
        for (const weeks of Object.values(teams || {})) {
          for (const arr of Object.values(weeks || {})) {
            for (const r of arr || []) {
              const pid = r && Number(r.pid);
              if (!Number.isFinite(pid)) continue;
              const key = `${seasonStr}|${pid}`;
              if (!nameIndex.has(key) && r?.name) nameIndex.set(key, String(r.name));
            }
          }
        }
      }
    } catch (e) {
      // name index is best-effort
      logLine("Name index build failed (continuing): " + (e.message || e), "warn");
    }

    // Flatten season->team->player map
    const rows = [];
    for (const [seasonStr, byTeam] of Object.entries(acq)) {
      for (const [teamIdStr, byPlayer] of Object.entries(byTeam || {})) {
        for (const [playerIdStr, acqType] of Object.entries(byPlayer || {})) {
          const playerName = nameIndex.get(`${seasonStr}|${playerIdStr}`) || "";
          const rec = (byPlayer && byPlayer[playerIdStr]) || acqType; // back-compat if older format
const acquisitionType = (rec && rec.acquisitionType) ? String(rec.acquisitionType) : String(acqType || "");
const slotId = Number.isFinite(rec?.slotId) ? rec.slotId : null;
const slot = Number.isFinite(slotId) ? (ESPN_SLOT_NAME[slotId] || String(slotId)) : "";

rows.push({
  season: seasonStr,
  teamId: teamIdStr,
  playerId: playerIdStr,
  playerName,
  acquisitionType: acquisitionType.trim(),
  slotId,
  slot,
defaultPositionId:
  (Number.isFinite(rec?.defaultPositionId) && rec.defaultPositionId > 0)
    ? rec.defaultPositionId
    : null,
});

        }
      }
    }

    if (!rows.length) {
      logLine("rosterAcqByYear present but empty — no CSV to download.", "warn");
      return;
    }

    const csv = makeCsv(
  ["season", "teamId", "playerId", "playerName", "acquisitionType", "slotId", "slot", "defaultPositionId"],
  rows
);

    try {
      await downloadCsv("espn_roster_acq_map.csv", csv);
      logLine(
        `Downloaded rosterAcqByYear CSV (${rows.length.toLocaleString()} rows).`,
        "ok"
      );
    } catch (e) {
      logLine("Download failed (continuing): " + (e.message || e), "warn");
    }
  } catch (err) {
    logLine("Acquisition map CSV: non-fatal error: " + (err.message || err), "warn");
  }
})();

  logLine("Hand-off complete — navigating to your app…", "ok");
}


