// All tab components + UploadBox bundled in one module.
// Exports: UploadBox, SetupTab, MembersTab, CareerTab, H2HTab, PlacementsTab, MoneyTab, RecordsTab, TradesTab
import React, { useEffect, useMemo, useState } from "react";
import Papa from "papaparse";
import * as XLSX from "xlsx";
import {
  buildFromRows,
  norm,
} from "/project/workspace/src/Utils/buildFromRows.jsx";
import { Card, TableBox } from "/project/workspace/src/Components/ui.jsx";
import ManagerMergeControl from "/project/workspace/src/Components/ManagerMergeControl.jsx";
import { ownerName } from "/project/workspace/src/ownerMaps.jsx";
// near the top of App.jsx (or tabs.jsx)
import "/project/workspace/src/Data/finishData.jsx";
import { primeOwnerMaps } from "/project/workspace/src/ownerMaps.jsx";
import {
  ResponsiveContainer,
  ComposedChart,
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ReferenceArea,
  BarChart, // + add
  Bar, // + add
  ReferenceLine,
  Cell,
} from "recharts";
import html2canvas from "html2canvas";

/* NEW: ESPN activity extractor                                       */
/**
 * Turn ESPN seasons (2018+) into:
 *   activityBySeason = {
 *     [year]: {
 *       [ownerDisplayName]: {
 *          acquisitions, drops, trades, moveToActive, ir, budget
 *       }
 *     }
 *   }
 *
 * Pass this into <TradesTab activityBySeason={…} />.
 */
export function extractEspnActivity(seasons = []) {
  const activity = {};
  for (const season of seasons || []) {
    const yr = Number(season?.seasonId);
    if (!Number.isFinite(yr)) continue;
    const memberName = new Map();
    (season?.members || []).forEach((m) => {
      const dn = m?.displayName || "";
      const fn = m?.firstName || "";
      const ln = m?.lastName || "";
      const best = dn || [fn, ln].filter(Boolean).join(" ").trim() || "";
      if (m?.id) memberName.set(m.id, best);
    });
    if (!activity[yr]) activity[yr] = {};
    (season?.teams || []).forEach((t) => {
      const ownerId = t?.primaryOwner || (t?.owners || [])[0] || "__unknown__";
      const owner =
        memberName.get(ownerId) ||
        (t?.location && t?.nickname
          ? `${t.location} ${t.nickname}`.trim()
          : t?.name || `Team ${t?.id}`) ||
        "Unknown";
      const tx = t?.transactionCounter || {};
      activity[yr][owner] = {
        acquisitions: Number(tx.acquisitions || 0),
        drops: Number(tx.drops || 0),
        trades: Number(tx.trades || 0),
        moveToActive: Number(tx.moveToActive || 0),
        ir: Number(tx.moveToIR || 0),
        budget: Number(tx.acquisitionBudgetSpent || 0),
      };
    });
  }
  return activity;
}
export function UploadBox({ onFileParsed, error, setError }) {
  const [showPaste, setShowPaste] = useState(false);
  const [pasteText, setPasteText] = useState("");
  const ingestRows = (rows) => {
    try {
      const built = buildFromRows(rows);
      onFileParsed(built, rows);
    } catch (e) {
      console.error(e);
      setError?.("Failed to process rows");
    }
  };
  const onFile = async (file) => {
    setError?.("");
    const ext = (file.name.split(".").pop() || "").toLowerCase();
    if (ext === "csv") {
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        transformHeader: (h) => norm(h),
        complete: (res) => ingestRows(res.data || []),
        error: () => setError?.("Failed to read CSV"),
      });
      return;
    }
    if (ext === "xlsx" || ext === "xls") {
      try {
        const buf = await file.arrayBuffer();
        const wb = XLSX.read(buf, { type: "array" });
        const sh = wb.Sheets[wb.SheetNames[0]];
        const json = XLSX.utils.sheet_to_json(sh, { header: 1 });
        const [hdr, ...rows] = json;
        if (!hdr) throw new Error("No header row");
        const headers = hdr.map((h) => norm(String(h || "")));
        const objs = rows
          .filter(
            (r) =>
              r &&
              r.some(
                (x) => x !== undefined && x !== null && String(x).trim() !== ""
              )
          )
          .map((r) => {
            const o = {};
            headers.forEach((h, i) => (o[h] = r[i]));
            return o;
          });
        ingestRows(objs);
      } catch (e) {
        console.error(e);
        setError?.("Failed to parse Excel");
      }
      return;
    }
    setError?.("Unsupported file type. Upload .csv or .xlsx");
  };
  return (
    <Card
      title="Upload league history (.csv or .xlsx)"
      subtitle="Columns (aliases OK): season, manager, opponent, team_name, points_for, points_against, result?, final_rank?, league_name/league_id?, platform?, scoring?"
    >
      <div className="flex flex-wrap items-center gap-3">
        <input
          type="file"
          accept=".csv,.xlsx,.xls"
          onChange={(e) =>
            e.target.files && e.target.files[0] && onFile(e.target.files[0])
          }
          className="text-sm"
        />
        <button
          className="px-3 py-1 rounded-lg bg-zinc-100 dark:bg-zinc-800"
          onClick={() => setShowPaste((v) => !v)}
        >
          {showPaste ? "Hide Paste CSV" : "Paste CSV"}
        </button>
        <button
          className="px-3 py-1 rounded-lg bg-indigo-600 text-white"
          onClick={() => ingestRows(demoRows)}
        >
          Load Demo Data
        </button>
      </div>
      {showPaste && (
        <div className="mt-3 space-y-2">
          <textarea
            className="w-full h-32 p-2 rounded-lg bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
            placeholder="Paste CSV with headers here"
            value={pasteText}
            onChange={(e) => setPasteText(e.target.value)}
          />
          <div>
            <button
              className="px-3 py-1 rounded-lg bg-zinc-900 text-white dark:bg-white dark:text-zinc-900"
              onClick={() =>
                Papa.parse(pasteText, {
                  header: true,
                  skipEmptyLines: true,
                  transformHeader: (h) => norm(h),
                  complete: (res) => ingestRows(res.data || []),
                })
              }
            >
              Parse Pasted CSV
            </button>
          </div>
        </div>
      )}

      {error && <div className="mt-2 text-red-600">{error}</div>}
    </Card>
  );
}
const TROPHIES = {
  1: "/trophies/gold.png",
  2: "/trophies/silver.png",
  3: "/trophies/bronze.png",
};
const ordinal = (n) => {
  if (n === 1) return "1st";
  if (n === 2) return "2nd";
  if (n === 3) return "3rd";
  const j = n % 10,
    k = n % 100;
  if (j === 1 && k !== 11) return `${n}st`;
  if (j === 2 && k !== 12) return `${n}nd`;
  if (j === 3 && k !== 13) return `${n}rd`;
  return `${n}th`;
};

/* HideManagerControl — choose which managers are hidden across tabs */
function HideManagerControl({
  owners = [],
  hidden = new Set(),
  onChangeHidden, // (nextSet: Set<string>) => void
}) {
  const toggle = (name) => {
    const next = new Set(hidden);
    next.has(name) ? next.delete(name) : next.add(name);
    onChangeHidden?.(next);
  };
  const clearAll = () => onChangeHidden?.(new Set());
  const selectAll = () => onChangeHidden?.(new Set(owners));

  return (
    <Card title="Hide managers (global)">
      <div className="text-xs text-zinc-500 mb-2">
        Hidden managers won’t appear in charts/tables. Other managers’ stats
        still include games played against them.
      </div>
      <div className="flex items-center gap-2 mb-2">
        <button
          className="px-2 py-1 rounded-full text-xs border border-zinc-300 dark:border-zinc-700"
          onClick={selectAll}
        >
          Hide all
        </button>
        <button
          className="px-2 py-1 rounded-full text-xs border border-zinc-300 dark:border-zinc-700"
          onClick={clearAll}
        >
          Show all
        </button>
        <span className="text-xs text-zinc-500">
          Hidden: {hidden.size}/{owners.length}
        </span>
      </div>
      <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-2 max-h-64 overflow-auto pr-1">
        {owners.map((name) => (
          <label
            key={name}
            className="flex items-center gap-2 px-2 py-1 rounded-md hover:bg-zinc-100 dark:hover:bg-zinc-800"
          >
            <input
              type="checkbox"
              className="checkbox checkbox-xs"
              checked={hidden.has(name)}
              onChange={() => toggle(name)}
            />
            <span className="truncate">{name}</span>
          </label>
        ))}
      </div>
    </Card>
  );
}

/* SetupTab                                                           */
/* SetupTab                                                           */
export function SetupTab({
  derivedAll,
  selectedLeague,
  setSelectedLeague,
  onLegacyCsvMerged,
  hiddenManagers = new Set(), // ← add
  onChangeHiddenManagers, // ← add
}) {
  if (!derivedAll) return null;
  const league = selectedLeague && derivedAll?.byLeague?.[selectedLeague];
  // 👇 ADD THIS EFFECT (keeps ownerMaps in sync with the selected league)
  React.useEffect(() => {
    if (!league) return;
    const aliases = window.__FL_ALIASES || {};
    primeOwnerMaps({
      league,
      selectedLeague: league,
      espnOwnerByTeamByYear: league.ownerByTeamByYear || {},
      manualAliases: aliases,
    });
    // Optional sanity log:
    console.log(
      "Owner map sources ready",
      window.__ownerMaps?.mapFor?.(Number(league?.seasonsAll?.slice?.(-1)?.[0]))
    );
  }, [league]);
  const keys = derivedAll.leagues;
  const [wantLegacy, setWantLegacy] = useState(false);
  const inferredId = (league?.meta?.id && String(league.meta.id)) || "";
  const [legacyLeagueId, setLegacyLeagueId] = useState(inferredId);
  const inferredStart = useMemo(() => {
    const s = Number(league?.meta?.startSeason);
    if (Number.isFinite(s) && s < 2019) return s;
    return 2018;
  }, [league?.meta?.startSeason]);
  const [legacyStartYear, setLegacyStartYear] = useState(inferredStart);
  const [isScraping, setIsScraping] = useState(false);
  const [scrapeMsg, setScrapeMsg] = useState("");
  useEffect(() => {
    setLegacyLeagueId(inferredId);
  }, [inferredId]);
  useEffect(() => {
    setLegacyStartYear(inferredStart);
  }, [inferredStart]);
  return (
    <div className="space-y-4">
      <Card title="League selection">
        <select
          className="px-3 py-2 rounded-lg bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
          value={selectedLeague}
          onChange={(e) => setSelectedLeague(e.target.value)}
        >
          {keys.map((k) => (
            <option key={k} value={k}>
              {derivedAll.byLeague[k].meta.name || k}
            </option>
          ))}
        </select>
      </Card>
      {/* Pre-2019 history helper unchanged... */}
      {league && (
        <ManagerMergeControl
          leagueMeta={league.meta}
          leagueRows={league.games || []}
        />
      )}
      {league && (
        <HideManagerControl
          owners={league.owners || []}
          hidden={hiddenManagers}
          onChangeHidden={onChangeHiddenManagers}
        />
      )}
      {league && (
        <Card title="League details">
          <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-3 text-sm">
            <Info label="League Name" value={league.meta.name} />
            <Info label="League Size" value={league.meta.size} />
            <Info label="Start Season" value={league.meta.startSeason} />
            <Info label="Years Running" value={league.meta.yearsRunning} />
            <Info label="Platform" value={league.meta.platform} />
            <Info label="Scoring" value={league.meta.scoring || "Standard"} />
          </div>
        </Card>
      )}
    </div>
  );
}
function Info({ label, value }) {
  return (
    <div>
      <div className="text-zinc-500">{label}</div>
      <div className="font-medium">{String(value ?? "—")}</div>
    </div>
  );
}
/* MembersTab  ----------------------------------------------                                                       */
export function MembersTab({ league }) {
  if (!league) return null;

  // Prime ownerMaps (safe no-op if already primed)
  try {
    window.__ownerMaps?.prime?.({ league });
  } catch {}

  // Canonical owner resolver: ownerMaps first, then league fallback
  const ownerNameOf = React.useCallback(
    (season, teamId) => {
      try {
        const nm = window.__ownerMaps?.name?.(Number(season), Number(teamId));
        if (nm) return nm;
      } catch {}
      const g = (o, ...ks) => ks.reduce((p, k) => (p == null ? p : p[k]), o);
      return (
        g(league, "ownerByTeamByYear", season, teamId) ||
        g(league, "ownerByTeamByYear", String(season), teamId) ||
        g(league, "ownerByTeamByYear", season, String(teamId)) ||
        g(league, "ownerByTeamByYear", String(season), String(teamId)) ||
        null
      );
    },
    [league]
  );

  const owners = league.owners || [];
  const seasons = league.seasonsAll || [];
  const teamNames = league.teamNamesByOwner || {}; // { owner -> { season -> team_name } }
  const latest = seasons.length ? Math.max(...seasons) : null;
  const seasonsDescRaw = [...seasons].sort((a, b) => b - a);
  const seasonsDesc = seasonsDescRaw.filter((yr) => yr !== latest); // ← hides newest column
  const labelFor = (yr) => `${yr} Team Name`;
  return (
    <TableBox>
      <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
        <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
          <th className="px-3 py-2 text-left">Member</th>
          <th className="px-3 py-2 text-center">Yr Joined</th>
          <th className="px-3 py-2 text-center">Yrs Played</th>
          <th className="px-3 py-2 text-center">Current Team</th>
          {seasonsDesc.map((yr) => (
            <th
              key={`hdr-${yr}`}
              className="px-3 py-2 text-center whitespace-nowrap w-48"
            >
              {labelFor(yr)}
            </th>
          ))}
        </tr>
      </thead>
      <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700 [&>tr:nth-child(odd)]:bg-zinc-50 dark:[&>tr:nth-child(odd)]:bg-zinc-900 [&>tr:hover]:bg-zinc-100 dark:[&>tr:hover]:bg-zinc-800">
        {league.members.map((m) => (
          <tr key={m.id}>
            {/* OWNER (manager) NAME */}
            <td className="px-3 py-2 font-medium text-left">{m.name}</td>
            <td className="px-3 py-2 text-center">{m.joined}</td>
            <td className="px-3 py-2 text-center">{m.yearsPlayed}</td>
            {/* Current team (fallback to most recent season’s saved team_name) */}
            <td className="px-3 py-2 text-center">
              {m.currentTeam || teamNames?.[m.name]?.[latest] || "—"}
            </td>
            {/* Per-season team names, newest -> oldest (with fixed width) */}
            {seasonsDesc.map((yr) => (
              <td
                key={`${m.id}-${yr}`}
                className="px-3 py-2 text-center whitespace-nowrap w-48"
              >
                {teamNames?.[m.name]?.[yr] || "—"}
              </td>
            ))}
          </tr>
        ))}
      </tbody>
    </TableBox>
  );
}
/* CareerTab — Playful Sport styling (wider + ticks + hover tooltip) */
export function CareerTab({ league }) {
  if (!league) return null;

  const hiddenSet = new Set(league.hiddenManagers || []); // will be set from App later
  const visibleOwners = (league.owners || []).filter((n) => !hiddenSet.has(n));

  /* --- tiny UI helpers (local-only) --- */
  const Chip = ({ children, className = "" }) => (
    <span
      className={`px-2.5 py-1 rounded-full text-xs border border-white/10 bg-white/[.05] dark:bg-white/[.04] ${className}`}
    >
      {children}
    </span>
  );
  const SoftButton = ({ children, onClick, className = "" }) => (
    <button
      onClick={onClick}
      className={
        "px-2.5 py-1 rounded-full text-xs border border-zinc-300/40 dark:border-zinc-700/60 " +
        "bg-zinc-50/70 dark:bg-zinc-800/70 hover:bg-white/80 dark:hover:bg-zinc-800 " +
        "transition transform hover:translate-y-[-1px] " +
        className
      }
    >
      {children}
    </button>
  );
  const Section = ({ title, right, children }) => (
    <div className="rounded-2xl border border-zinc-200/60 dark:border-zinc-700/60 bg-white/60 dark:bg-zinc-900/50 shadow-md shadow-black/5 backdrop-blur">
      <div className="sticky top-0 z-10 flex items-center justify-between px-4 py-3 border-b border-zinc-200/60 dark:border-zinc-700/60 bg-gradient-to-b from-white/70 to-white/30 dark:from-zinc-900/70 dark:to-zinc-900/20 backdrop-blur rounded-t-2xl">
        <h3 className="text-sm font-medium text-zinc-600 dark:text-zinc-300">
          {title}
        </h3>
        <div className="flex items-center gap-2">{right}</div>
      </div>
      <div className="p-3 md:p-4">{children}</div>
    </div>
  );

  /* --- logic (unchanged) --- */

  // <-- this must be defined before any state that uses it
  const allSeasons = (league.seasonsAll || []).slice().sort((a, b) => b - a); // newest first

  const [metricKey, setMetricKey] = React.useState("pointsFor");
  const [showMemberPicker, setShowMemberPicker] = React.useState(false);
  const [selectedNames, setSelectedNames] = React.useState(new Set());
  const [showYearPicker, setShowYearPicker] = React.useState(false);
  const [selectedYears, setSelectedYears] = React.useState(new Set(allSeasons));
  const [hoverI, setHoverI] = React.useState(null);

  // Year selector for the Win%-by-score table (defaults to newest season)
  // Use string so we can support "ALL"
  const [wpYear, setWpYear] = React.useState(
    String(allSeasons[0] || new Date().getFullYear())
  );
  React.useEffect(() => {
    setWpYear(String(allSeasons[0] || new Date().getFullYear()));
  }, [JSON.stringify(allSeasons)]);

  // Toggle: show graph instead of table for Win%-by-score
  const [showWpGraph, setShowWpGraph] = React.useState(false);

  React.useEffect(() => {
    setSelectedNames(new Set(visibleOwners.map(String)));
    setSelectedYears(new Set(allSeasons));
  }, [league, JSON.stringify(visibleOwners), JSON.stringify(allSeasons)]);

  const toggleName = (name) =>
    setSelectedNames((prev) => {
      const next = new Set(prev);
      next.has(name) ? next.delete(name) : next.add(name);
      return next;
    });
  const toggleYear = (yr) =>
    setSelectedYears((prev) => {
      const next = new Set(prev);
      next.has(yr) ? next.delete(yr) : next.add(yr);
      return next;
    });
  const selectAllNames = () =>
    setSelectedNames(new Set((league.owners || []).map(String)));
  const clearNames = () => setSelectedNames(new Set());
  const selectAllYears = () => setSelectedYears(new Set(allSeasons));
  const clearYears = () => setSelectedYears(new Set());

  const metrics = [
    {
      key: "pointsFor",
      label: "Total Points For (PF)",
      accessor: (r) => r.pointsFor,
      better: "high",
    },
    {
      key: "pointsAgainst",
      label: "Total Points Against (PA)",
      accessor: (r) => r.pointsAgainst,
      better: "low",
    },
    { key: "wins", label: "Wins", accessor: (r) => r.wins, better: "high" },
    {
      key: "losses",
      label: "Losses",
      accessor: (r) => r.losses,
      better: "low",
    },
    {
      key: "games",
      label: "Games Played",
      accessor: (r) => r.games,
      better: "high",
    },
    {
      key: "winPct",
      label: "Win %",
      accessor: (r) => r.winPct,
      better: "high",
    },
    {
      key: "avgPF",
      label: "Avg Points For",
      accessor: (r) => r.avgPF,
      better: "high",
    },
    {
      key: "avgPA",
      label: "Avg Points Against",
      accessor: (r) => r.avgPA,
      better: "low",
    },
  ];
  const metric = metrics.find((m) => m.key === metricKey) || metrics[0];

  const filteredGames = React.useMemo(() => {
    if (!selectedYears.size) return [];
    return (league?.games || []).filter(
      (g) => selectedYears.has(Number(g.season)) && g?.is_playoff !== true
    );
  }, [league?.games, selectedYears]);

  const careerStatsFiltered = React.useMemo(() => {
    const base = new Map();
    visibleOwners.forEach((name) =>
      base.set(name, {
        id: (name || "").toLowerCase().replace(/\s+/g, "_"),
        name,
        games: 0,
        wins: 0,
        losses: 0,
        pointsFor: 0,
        pointsAgainst: 0,
        avgPF: 0,
        avgPA: 0,
        winPct: 0,
      })
    );
    filteredGames.forEach((g) => {
      const decided = g?.res === "W" || g?.res === "L";
      if (!decided) return;
      const row = base.get(g.owner);
      if (!row) return;
      row.games += 1;
      if (g.res === "W") row.wins += 1;
      else row.losses += 1;
      const pf = Number(g.pf);
      const pa = Number(g.pa);
      row.pointsFor += isNaN(pf) ? 0 : pf;
      row.pointsAgainst += isNaN(pa) ? 0 : pa;
    });
    for (const r of base.values()) {
      r.avgPF = r.games ? r.pointsFor / r.games : 0;
      r.avgPA = r.games ? r.pointsAgainst / r.games : 0;
      r.winPct = r.games ? r.wins / r.games : 0;
    }
    return Array.from(base.values());
  }, [league?.owners, filteredGames]);

  const visibleStats = careerStatsFiltered.filter((r) =>
    selectedNames.has(r.name)
  );
  const chartData = visibleStats
    .map((r) => ({ name: r.name, value: metric.accessor(r) }))
    .sort((a, b) =>
      metric.better === "high" ? b.value - a.value : a.value - b.value
    );

  /* -------- Chart: slightly wider, ticks, hover tooltip, auto-scale -------- */
  const baseW = 880; // tad wider than before
  const H = 360; // a bit taller so labels never clip
  const M = { top: 20, right: 24, bottom: 96, left: 64 };
  const innerW = Math.max(1, baseW - M.left - M.right);
  const n = Math.max(1, chartData.length);
  const barW = innerW / n;

  const values = chartData.map((d) => Number(d.value) || 0);
  const max = Math.max(1, ...values);
  const min = Math.min(...values);
  const padFrac = 0.1;
  const domainMin = Math.max(0, min - (max - min) * padFrac);
  const domainMax = max + (max - min) * padFrac;
  const denom = Math.max(1e-6, domainMax - domainMin);

  const x = (i) => M.left + i * barW + barW * 0.1;
  const y = (v) =>
    M.top +
    (1 - Math.max(0, Number(v) - domainMin) / denom) * (H - M.top - M.bottom);

  // Y ticks (5 lines)
  const tickCount = 5;
  const ticks = Array.from({ length: tickCount + 1 }, (_, i) => {
    const t = i / tickCount;
    const val = domainMin + t * (domainMax - domainMin);
    return { val, y: y(val) };
  });

  // Tooltip formatting and rough width for the pill bg
  const fmtVal = (v) => {
    if (
      metricKey === "avgPF" ||
      metricKey === "avgPA" ||
      metricKey === "winPct"
    ) {
      return metricKey === "winPct"
        ? `${(v * 100).toFixed(1)}%`
        : Number(v).toFixed(1);
    }
    return Math.round(Number(v)).toLocaleString();
  };
  const approxTextW = (s) => s.length * 8 + 12; // simple estimate

  const owners = visibleOwners;
  const avgPlacement = (name) => {
    if (!selectedYears.size) return null;
    let sum = 0,
      c = 0;
    selectedYears.forEach((yr) => {
      const p = league?.placementMap?.[name]?.[yr];
      if (p) {
        sum += p;
        c++;
      }
    });
    return c ? sum / c : null;
  };

  const rank = (arr, better = "high") => {
    const vals = arr.map((a) => a.val);
    const uniqSorted = Array.from(new Set(vals.filter((v) => v != null))).sort(
      (a, b) => (better === "high" ? b - a : a - b)
    );
    const map = new Map();
    uniqSorted.forEach((v, i) => map.set(v, i + 1));
    return arr.map((a) => ({
      name: a.name,
      r: a.val == null ? null : map.get(a.val),
    }));
  };
  const rowsForRank = careerStatsFiltered.map((r) => ({
    name: r.name,
    avgPF: r.avgPF,
    pa: r.pointsAgainst,
    winPct: r.winPct,
    avgPlace: avgPlacement(r.name) == null ? null : -avgPlacement(r.name),
  }));
  const rAvgPF = rank(
    rowsForRank.map((r) => ({ name: r.name, val: r.avgPF })),
    "high"
  );
  const rPA = rank(
    rowsForRank.map((r) => ({ name: r.name, val: -r.pa })),
    "high"
  );
  const rWin = rank(
    rowsForRank.map((r) => ({ name: r.name, val: r.winPct })),
    "high"
  );
  const rPlace = rank(
    rowsForRank.map((r) => ({ name: r.name, val: r.avgPlace })),
    "high"
  );
  const rankRow = (name) => ({
    name,
    avgPF: rAvgPF.find((x) => x.name === name)?.r ?? "—",
    pa: rPA.find((x) => x.name === name)?.r ?? "—",
    winPct: rWin.find((x) => x.name === name)?.r ?? "—",
    place: rPlace.find((x) => x.name === name)?.r ?? "—",
  });
  const rankTable = owners.map((o) => rankRow(o));

  // ---------- Win% by own scoring buckets (per manager, per season) ----------
  // Buckets: 10, 20, ..., 200 (200 means 200+)
  const bucketStops = React.useMemo(
    () => Array.from({ length: 20 }, (_, i) => (i + 1) * 10), // 10..200
    []
  );
  const bucketLabels = React.useMemo(
    () => bucketStops.map((b) => (b === 200 ? "200+" : String(b))),
    [bucketStops]
  );
  // Build per-owner rows and an overall aggregator.
  // If Year = "ALL", collapse to ONE row per owner across all seasons.
  const wpRowsAndOverall = React.useMemo(() => {
    const rows = new Map(); // key depends on isAll: owner OR `${owner}__${season}`
    const overall = {}; // stop -> {wins,games}
    const isAll = String(wpYear) === "ALL";

    const yearGames = isAll
      ? filteredGames || []
      : (filteredGames || []).filter(
          (g) => Number(g?.season) === Number(wpYear)
        );

    for (const g of yearGames) {
      const owner = g?.owner;
      const season = Number(g?.season);
      if (!owner || !Number.isFinite(season)) continue;
      if (!selectedNames.has(owner)) continue;

      const pf = Number(g?.pf);
      const res = g?.res; // 'W' / 'L'
      if (!Number.isFinite(pf) || (res !== "W" && res !== "L")) continue;

      let stop = Math.floor(pf / 10) * 10;
      if (stop < 10) stop = 10;
      if (stop > 200) stop = 200;

      // Key by OWNER when isAll; otherwise by OWNER+SEASON
      const key = isAll ? owner : `${owner}__${season}`;
      if (!rows.has(key)) {
        rows.set(key, {
          owner,
          season: isAll ? "All" : season,
          buckets: {},
        });
      }
      const row = rows.get(key);
      if (!row.buckets[stop]) row.buckets[stop] = { wins: 0, games: 0 };
      row.buckets[stop].games += 1;
      if (res === "W") row.buckets[stop].wins += 1;

      // overall aggregator (always across whatever set we're viewing)
      if (!overall[stop]) overall[stop] = { wins: 0, games: 0 };
      overall[stop].games += 1;
      if (res === "W") overall[stop].wins += 1;
    }

    const rowsSorted = Array.from(rows.values()).sort((a, b) =>
      a.owner.localeCompare(b.owner)
    );

    return {
      rows: rowsSorted, // one row per OWNER if isAll, else per owner-season
      overallBuckets: overall,
      label: isAll ? "All" : String(wpYear),
      isAll,
    };
  }, [filteredGames, selectedNames, wpYear]);

  const fmtPct0 = (v) => (v == null ? "—" : `${Math.round(v * 100)}%`);

  /* --- UI --- */

  /* --- UI --- */
  return (
    <div className="space-y-6">
      <Section
        title="Career bar chart (Regular Season)"
        right={
          <div className="flex items-center gap-2">
            <select
              className="px-3 py-1.5 rounded-full bg-white/80 dark:bg-zinc-900/80 border border-zinc-300/60 dark:border-zinc-700/60 text-xs shadow-sm"
              value={metricKey}
              onChange={(e) => setMetricKey(e.target.value)}
            >
              {metrics.map((m) => (
                <option key={m.key} value={m.key}>
                  {m.label}
                </option>
              ))}
            </select>

            <div className="relative">
              <SoftButton onClick={() => setShowYearPicker((v) => !v)}>
                Years <Chip className="ml-1">{selectedYears.size || 0}</Chip>
              </SoftButton>
              {showYearPicker && (
                <div className="absolute right-0 z-10 mt-2 w-60 max-h-72 overflow-auto rounded-2xl border border-zinc-200/60 dark:border-zinc-700/60 bg-white/95 dark:bg-zinc-900/95 shadow-lg p-2">
                  <div className="flex items-center justify-between mb-2">
                    <SoftButton onClick={selectAllYears}>Select all</SoftButton>
                    <SoftButton onClick={clearYears}>Clear</SoftButton>
                  </div>
                  <div className="space-y-1">
                    {allSeasons.map((yr) => (
                      <label
                        key={yr}
                        className="flex items-center gap-2 text-sm px-2 py-1 rounded-md hover:bg-zinc-100/70 dark:hover:bg-zinc-800/60"
                      >
                        <input
                          type="checkbox"
                          className="checkbox checkbox-xs"
                          checked={selectedYears.has(yr)}
                          onChange={() => toggleYear(yr)}
                        />
                        <span className="truncate">{yr}</span>
                      </label>
                    ))}
                  </div>
                </div>
              )}
            </div>

            <div className="relative">
              <SoftButton onClick={() => setShowMemberPicker((v) => !v)}>
                Members <Chip className="ml-1">{selectedNames.size}</Chip>
              </SoftButton>
              {showMemberPicker && (
                <div className="absolute right-0 z-10 mt-2 w-72 max-h-72 overflow-auto rounded-2xl border border-zinc-200/60 dark:border-zinc-700/60 bg-white/95 dark:bg-zinc-900/95 shadow-lg p-2">
                  <div className="flex items-center justify-between mb-2">
                    <SoftButton onClick={selectAllNames}>Select all</SoftButton>
                    <SoftButton onClick={clearNames}>Clear</SoftButton>
                  </div>
                  <div className="space-y-1">
                    {visibleOwners.map((name) => (
                      <label
                        key={name}
                        className="flex items-center gap-2 text-sm px-2 py-1 rounded-md hover:bg-zinc-100/70 dark:hover:bg-zinc-800/60"
                      >
                        <input
                          type="checkbox"
                          className="checkbox checkbox-xs"
                          checked={selectedNames.has(name)}
                          onChange={() => toggleName(name)}
                        />
                        <span className="truncate">{name}</span>
                      </label>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        }
      >
        <div className="text-xs text-zinc-500 mb-3">
          Regular season only. Filtering by{" "}
          {selectedYears.size
            ? Array.from(selectedYears)
                .sort((a, b) => a - b)
                .join(", ")
            : "—"}
          .
          {selectedYears.size === 0 &&
            " (No years selected — showing empty state.)"}
        </div>

        {/* Optional: friendly “Outfit” font just for this tab */}
        <style>{`@import url('https://fonts.googleapis.com/css2?family=Outfit:wght@500;700&display=swap');`}</style>

        {/* Fixed width (wider), taller, with ticks + hover tooltips */}
        <svg
          width={baseW}
          height={H}
          className="block mx-auto"
          style={{ fontFamily: "'Outfit', ui-sans-serif" }}
        >
          <defs>
            <linearGradient id="bar" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stopOpacity="1" stopColor="#6AB1FF" />
              <stop offset="100%" stopOpacity="1" stopColor="#8BE28B" />
            </linearGradient>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
              <feGaussianBlur stdDeviation="3" result="coloredBlur" />
              <feMerge>
                <feMergeNode in="coloredBlur" />
                <feMergeNode in="SourceGraphic" />
              </feMerge>
            </filter>
          </defs>

          {/* gridlines + y-axis */}
          {ticks.map((t, i) => (
            <g key={i}>
              <line
                x1={M.left}
                y1={t.y}
                x2={baseW - M.right}
                y2={t.y}
                stroke="#64748b22"
                strokeWidth="1"
              />
              <text
                x={M.left - 10}
                y={t.y + 4}
                fontSize="11"
                textAnchor="end"
                className="fill-white"
                style={{
                  paintOrder: "stroke",
                  stroke: "rgba(0,0,0,.35)",
                  strokeWidth: 2,
                }}
              >
                {fmtVal(t.val)}
              </text>
            </g>
          ))}
          <line
            x1={M.left}
            y1={M.top}
            x2={M.left}
            y2={H - M.bottom}
            stroke="#94a3b8"
            strokeWidth="1"
          />

          {/* bars + diagonal names + hover highlight */}
          {chartData.map((d, i) => {
            const cx = x(i) + (barW * 0.8) / 2;
            const topY = y(d.value);
            const tip = fmtVal(d.value);
            const w = approxTextW(tip);
            const tipX = Math.min(
              Math.max(cx, M.left + w / 2 + 6),
              baseW - M.right - w / 2 - 6
            );
            const tipY = Math.max(M.top + 18, topY - 12);

            const dimOthers = hoverI !== null && hoverI !== i;
            return (
              <g
                key={d.name}
                onMouseEnter={() => setHoverI(i)}
                onMouseLeave={() => setHoverI(null)}
                style={{ cursor: "pointer" }}
              >
                <rect
                  x={x(i)}
                  y={topY}
                  width={barW * 0.8}
                  height={H - M.bottom - topY}
                  fill="url(#bar)"
                  rx="10"
                  filter={hoverI === i ? "url(#glow)" : undefined}
                  opacity={dimOthers ? 0.45 : 1}
                  stroke={hoverI === i ? "#ffffffaa" : "none"}
                  strokeWidth={hoverI === i ? 1.5 : 0}
                  className="transition-[transform,opacity] duration-150 will-change-transform"
                  transform={hoverI === i ? `translate(0,-2)` : undefined}
                />

                {/* diagonal name */}
                <g
                  transform={`translate(${cx}, ${
                    H - M.bottom + 30
                  }) rotate(-35)`}
                >
                  <text
                    fontSize="12"
                    textAnchor="end"
                    className="fill-white"
                    style={{
                      paintOrder: "stroke",
                      stroke: "rgba(0,0,0,.35)",
                      strokeWidth: 2,
                      opacity: dimOthers ? 0.6 : 1,
                    }}
                  >
                    {d.name}
                  </text>
                </g>

                {/* tooltip on hover */}
                {hoverI === i && (
                  <g>
                    <rect
                      x={tipX - w / 2}
                      y={tipY - 18}
                      width={w}
                      height={22}
                      rx="11"
                      fill="rgba(17,24,39,.9)"
                      stroke="rgba(255,255,255,.25)"
                    />
                    <text
                      x={tipX}
                      y={tipY - 3}
                      fontSize="12"
                      textAnchor="middle"
                      className="fill-white"
                    >
                      {tip}
                    </text>
                  </g>
                )}
              </g>
            );
          })}
        </svg>
      </Section>

      {/* Raw career table (filtered) */}
      <Section title="Career totals (filtered)">
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-white/70 dark:bg-zinc-800/70 sticky top-0 backdrop-blur border-b border-zinc-200/60 dark:border-zinc-700/60">
              <tr>
                <th className="px-3 py-2 text-left">Member</th>
                <th className="px-3 py-2">GP</th>
                <th className="px-3 py-2">W</th>
                <th className="px-3 py-2">L</th>
                <th className="px-3 py-2">Win %</th>
                <th className="px-3 py-2">PF</th>
                <th className="px-3 py-2">PA</th>
                <th className="px-3 py-2">Avg PF</th>
                <th className="px-3 py-2">Avg PA</th>
              </tr>
            </thead>
            <tbody className="[&>tr:nth-child(odd)]:bg-zinc-50/60 dark:[&>tr:nth-child(odd)]:bg-white/[.03] [&>tr:hover]:bg-white/80 dark:[&>tr:hover]:bg-zinc-800/70 transition">
              {careerStatsFiltered.map((r) => (
                <tr
                  key={r.id}
                  className="border-b border-zinc-200/40 dark:border-zinc-700/40"
                >
                  <td className="px-3 py-2 font-medium text-left">{r.name}</td>
                  <td className="px-3 py-2 text-center">{r.games}</td>
                  <td className="px-3 py-2 text-center">{r.wins}</td>
                  <td className="px-3 py-2 text-center">{r.losses}</td>
                  <td className="px-3 py-2 text-center">
                    {(r.winPct * 100).toFixed(1)}%
                  </td>
                  <td className="px-3 py-2 text-center">
                    {Math.round(r.pointsFor).toLocaleString()}
                  </td>
                  <td className="px-3 py-2 text-center">
                    {Math.round(r.pointsAgainst).toLocaleString()}
                  </td>
                  <td className="px-3 py-2 text-center">
                    {r.avgPF.toFixed(1)}
                  </td>
                  <td className="px-3 py-2 text-center">
                    {r.avgPA.toFixed(1)}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Section>

      {/* Rank table (filtered) */}
      <Section title="Career ranks (filtered)">
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-white/70 dark:bg-zinc-800/70 sticky top-0 backdrop-blur border-b border-zinc-200/60 dark:border-zinc-700/60">
              <tr>
                <th className="px-3 py-2 text-left">Member</th>
                <th className="px-3 py-2">Rank: Avg PF</th>
                <th className="px-3 py-2">Rank: PA (lower better)</th>
                <th className="px-3 py-2">Rank: Win %</th>
                <th className="px-3 py-2">Rank: Placement (avg)</th>
              </tr>
            </thead>
            <tbody className="[&>tr:nth-child(odd)]:bg-zinc-50/60 dark:[&>tr:nth-child(odd)]:bg-white/[.03] [&>tr:hover]:bg-white/80 dark:[&>tr:hover]:bg-zinc-800/70 transition">
              {rankTable.map((r) => (
                <tr
                  key={r.name}
                  className="border-b border-zinc-200/40 dark:border-zinc-700/40"
                >
                  <td className="px-3 py-2 font-medium text-left">{r.name}</td>
                  <td className="px-3 py-2 text-center">{r.avgPF}</td>
                  <td className="px-3 py-2 text-center">{r.pa}</td>
                  <td className="px-3 py-2 text-center">{r.winPct}</td>
                  <td className="px-3 py-2 text-center">{r.place}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Section>

      {/* NEW: Win % by scoring bucket (per season) */}
      <Section
        title="Win % by own points scored"
        right={
          <div className="flex items-center gap-3">
            <div className="text-xs text-zinc-500">
              Regular season only. Buckets = score floored to nearest 10 (10,
              20, …, 200+).
            </div>
            <div className="flex items-center gap-1 text-xs">
              <span className="text-zinc-500">Year:</span>
              <select
                className="px-2 py-1 rounded-md bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-700"
                value={wpYear}
                onChange={(e) => setWpYear(e.target.value)}
              >
                <option value="ALL">All</option>
                {allSeasons.map((yr) => (
                  <option key={yr} value={String(yr)}>
                    {yr}
                  </option>
                ))}
              </select>
            </div>
            <SoftButton onClick={() => setShowWpGraph((v) => !v)}>
              {showWpGraph ? "Show table" : "Show graph"}
            </SoftButton>
          </div>
        }
      >
        {/* Toggle: Graph vs Table */}
        {showWpGraph ? (
          // ---- GRAPH VIEW (overall line = all selected managers) ----
          (() => {
            const W = 920,
              H = 320;
            const M = { top: 16, right: 20, bottom: 40, left: 48 };
            const innerW = W - M.left - M.right;
            const innerH = H - M.top - M.bottom;

            const xPos = (i) =>
              M.left + (i / (bucketStops.length - 1)) * innerW;

            const yPos = (p) => {
              const v = Math.max(0, Math.min(1, Number(p) || 0));
              return M.top + (1 - v) * innerH;
            };

            const pts = bucketStops.map((stop, i) => {
              const cell = wpRowsAndOverall.overallBuckets[stop];
              const pct =
                cell && cell.games > 0 ? cell.wins / cell.games : null;
              return { i, stop, pct, games: cell?.games || 0 };
            });

            let d = "";
            let started = false;
            pts.forEach((p) => {
              if (p.pct == null) return;
              const X = xPos(p.i);
              const Y = yPos(p.pct);
              d += started ? ` L ${X} ${Y}` : `M ${X} ${Y}`;
              started = true;
            });

            return (
              <svg width={W} height={H} className="block">
                {/* axes */}
                <line
                  x1={M.left}
                  y1={M.top}
                  x2={M.left}
                  y2={H - M.bottom}
                  stroke="#94a3b8"
                />
                <line
                  x1={M.left}
                  y1={H - M.bottom}
                  x2={W - M.right}
                  y2={H - M.bottom}
                  stroke="#94a3b8"
                />
                {/* y grid (0..100%) */}
                {[0, 0.25, 0.5, 0.75, 1].map((v) => (
                  <g key={v}>
                    <line
                      x1={M.left}
                      x2={W - M.right}
                      y1={yPos(v)}
                      y2={yPos(v)}
                      stroke="#64748b22"
                    />
                    <text
                      x={M.left - 8}
                      y={yPos(v) + 4}
                      textAnchor="end"
                      fontSize="11"
                      className="fill-white"
                    >
                      {Math.round(v * 100)}%
                    </text>
                  </g>
                ))}
                {/* x labels every 20 points */}
                {bucketStops.map((stop, i) =>
                  stop % 20 === 0 ? (
                    <text
                      key={stop}
                      x={xPos(i)}
                      y={H - M.bottom + 16}
                      fontSize="11"
                      textAnchor="middle"
                      className="fill-white"
                    >
                      {stop === 200 ? "200+" : stop}
                    </text>
                  ) : null
                )}

                {/* line + dots */}
                <path d={d} fill="none" stroke="url(#bar)" strokeWidth="2.5" />
                {pts.map((p) =>
                  p.pct == null ? null : (
                    <circle
                      key={p.stop}
                      cx={xPos(p.i)}
                      cy={yPos(p.pct)}
                      r="3.5"
                      fill="#8BE28B"
                    />
                  )
                )}

                {/* caption */}
                <text
                  x={W - M.right}
                  y={M.top + 12}
                  textAnchor="end"
                  fontSize="12"
                  className="fill-white"
                >
                  {`Overall — ${wpRowsAndOverall.label}`}
                </text>
              </svg>
            );
          })()
        ) : (
          // ---- TABLE VIEW ----
          <div className="overflow-x-auto">
            <table className="w-full text-xs">
              <thead className="bg-white/70 dark:bg-zinc-800/70 sticky top-0 backdrop-blur border-b border-zinc-200/60 dark:border-zinc-700/60">
                <tr>
                  <th className="px-2 py-2 text-left">Member</th>
                  <th className="px-2 py-2 text-center">Season</th>
                  {bucketLabels.map((lbl) => (
                    <th key={lbl} className="px-2 py-2 text-center">
                      {lbl}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody className="[&>tr:nth-child(odd)]:bg-zinc-50/60 dark:[&>tr:nth-child(odd)]:bg-white/[.03] [&>tr:hover]:bg-white/80 dark:[&>tr:hover]:bg-zinc-800/70 transition">
                {/* Summary row first */}
                <tr className="border-b border-zinc-200/40 dark:border-zinc-700/40 bg-white/60 dark:bg-zinc-800/50">
                  <td className="px-2 py-1 font-semibold text-left whitespace-nowrap">
                    All managers
                  </td>
                  <td className="px-2 py-1 text-center">
                    {wpRowsAndOverall.label}
                  </td>
                  {bucketStops.map((stop) => {
                    const cell = wpRowsAndOverall.overallBuckets[stop];
                    const pct =
                      cell && cell.games > 0 ? cell.wins / cell.games : null;
                    return (
                      <td
                        key={stop}
                        className="px-2 py-1 text-center tabular-nums"
                        title={
                          cell
                            ? `${cell.wins}-${
                                cell.games - cell.wins
                              } (${Math.round((pct || 0) * 100)}%)`
                            : ""
                        }
                      >
                        {fmtPct0(pct)}
                      </td>
                    );
                  })}
                </tr>

                {/* Per-owner rows */}
                {wpRowsAndOverall.rows.map((row) => (
                  <tr
                    key={`${row.owner}-${row.season}`}
                    className="border-b border-zinc-200/40 dark:border-zinc-700/40"
                  >
                    <td className="px-2 py-1 font-medium text-left whitespace-nowrap">
                      {row.owner}
                    </td>
                    <td className="px-2 py-1 text-center">{row.season}</td>
                    {bucketStops.map((stop) => {
                      const cell = row.buckets[stop];
                      const pct =
                        cell && cell.games > 0 ? cell.wins / cell.games : null;
                      return (
                        <td
                          key={stop}
                          className="px-2 py-1 text-center tabular-nums"
                          title={
                            cell
                              ? `${cell.wins}-${
                                  cell.games - cell.wins
                                } (${Math.round((pct || 0) * 100)}%)`
                              : ""
                          }
                        >
                          {fmtPct0(pct)}
                        </td>
                      );
                    })}
                  </tr>
                ))}

                {wpRowsAndOverall.rows.length === 0 && (
                  <tr>
                    <td
                      colSpan={2 + bucketStops.length}
                      className="px-3 py-6 text-center text-zinc-500"
                    >
                      No games for {wpRowsAndOverall.label} in the current
                      filters.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        )}
      </Section>
    </div>
  );
}

// H2HTab.jsx — regular season only (ignores ties)
export function H2HTab({ league }) {
  if (!league) return null;

  const hidden = new Set(league.hiddenManagers || []); // ← NEW
  const owners = (league.owners || []).filter((n) => !hidden.has(n)); // ← NEW

  // Scope filter: REG = regular season, PO = playoffs, ALL = both
  const [seg, setSeg] = React.useState("REG");
  const segLabel = React.useMemo(
    () => ({ REG: "Regular season", PO: "Playoffs", ALL: "All games" }),
    []
  );

  // Filtered, completed games (ties ignored)
  const gamesFiltered = React.useMemo(
    () =>
      (league.games || []).filter((g) => {
        if (!(g.res === "W" || g.res === "L")) return false; // ignore ties/unfinished
        if (seg === "REG") return g.is_playoff !== true;
        if (seg === "PO") return g.is_playoff === true;
        return true; // ALL
      }),
    [league.games, seg]
  );

  // helper to pick the first finite numeric candidate
  const pickNum = (...vals) => {
    for (const v of vals) {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
    return null;
  };

  // Popup state for clicked pair
  const [detailPair, setDetailPair] = React.useState(null); // {a, b} or null
  // track hovered row/col
  const [hover, setHover] = React.useState({ row: null, col: null });
  const clearHover = () => setHover({ row: null, col: null });

  // Build list of games per (owner A, owner B) from the filtered games
  const pairGames = React.useMemo(() => {
    const m = new Map(); // key: "A__B" -> array of games from A's perspective
    const keyOf = (a, b) => `${a}__${b}`;

    for (const g of gamesFiltered || []) {
      const a = g?.owner;
      const b = g?.opp;
      if (!a || !b) continue;
      if (hidden.has(a) || hidden.has(b)) continue; // ← NEW: don’t record pairs that involve hidden owners

      const ownerPts = pickNum(
        g.pf,
        g.points_for,
        g.points,
        g.score,
        g.owner_points,
        g.pts,
        g.fpts
      );
      const oppPts = pickNum(
        g.pa,
        g.points_against,
        g.opp_points,
        g.oppPts,
        g.against,
        g.opp_score
      );

      const rec = {
        res: (g?.res || "").toUpperCase(), // 'W' | 'L'
        a,
        b,
        aPts: ownerPts,
        bPts: oppPts,
        week: Number(g?.week) || null,
        year: Number(g?.season) || null,
      };

      const k = keyOf(a, b);
      if (!m.has(k)) m.set(k, []);
      m.get(k).push(rec);
    }

    // Sort each list by (year asc, week asc)
    for (const arr of m.values()) {
      arr.sort(
        (x, y) => (x.year ?? 0) - (y.year ?? 0) || (x.week ?? 0) - (y.week ?? 0)
      );
    }
    return m;
  }, [gamesFiltered, league.hiddenManagers]); // ← NEW dep

  // Win/Loss tallies per pair
  const wl = React.useMemo(() => {
    const map = {};
    owners.forEach((a) => {
      map[a] = {};
      owners.forEach((b) => (map[a][b] = { w: 0, l: 0 }));
    });

    gamesFiltered.forEach((g) => {
      if (!map[g.owner] || !map[g.owner][g.opp]) return;
      if (g.res === "W") map[g.owner][g.opp].w += 1;
      else if (g.res === "L") map[g.owner][g.opp].l += 1;
    });

    return map;
  }, [owners, gamesFiltered]);

  // Matrix: "w-l"
  const matrix = React.useMemo(() => {
    const out = {};
    owners.forEach((a) => {
      out[a] = {};
      owners.forEach((b) => {
        const v = wl[a][b];
        out[a][b] = `${v.w}-${v.l}`;
      });
    });
    return out;
  }, [owners, wl]);

  // Best / Worst (based on win %; needs at least 1 game)
  const bestWorst = React.useMemo(() => {
    const out = {};
    owners.forEach((a) => {
      let best = { opp: null, w: 0, l: 0, pct: -1 };
      let worst = { opp: null, w: 0, l: 0, pct: 2 };
      owners.forEach((b) => {
        if (a === b) return;
        const v = wl[a][b];
        const total = v.w + v.l;
        if (!total) return;
        const pct = v.w / total;
        if (pct > best.pct) best = { opp: b, w: v.w, l: v.l, pct };
        if (pct < worst.pct) worst = { opp: b, w: v.w, l: v.l, pct };
      });
      out[a] = best.opp
        ? { best, worst }
        : {
            best: { opp: null, w: 0, l: 0, pct: 0 },
            worst: { opp: null, w: 0, l: 0, pct: 0 },
          };
    });
    return out;
  }, [owners, wl]);

  // --- UI (keep your existing table components/styles) ---
  return (
    <div className="space-y-6">
      <Card
        title="Head-to-Head"
        right={
          <div className="flex items-center gap-2">
            <div className="text-xs text-zinc-500">Scope:</div>
            <select
              className="px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
              value={seg}
              onChange={(e) => setSeg(e.target.value)}
            >
              <option value="REG">Regular season</option>
              <option value="PO">Playoffs</option>
              <option value="ALL">All games</option>
            </select>
          </div>
        }
      >
        <div className="text-xs text-zinc-500 mb-2">
          {segLabel[seg]} • ties ignored.
        </div>

        {/* Matrix */}
        <div className="overflow-auto" onMouseLeave={clearHover}>
          <table className="min-w-[700px] w-full text-sm">
            <thead>
              <tr>
                <th className="px-3 py-2 text-left">Owner</th>
                {owners.map((b) => (
                  <th
                    key={b}
                    className={`px-3 py-2 text-center ${
                      hover.col === b ? "bg-zinc-100 dark:bg-zinc-800" : ""
                    }`}
                    onMouseEnter={() => setHover((h) => ({ ...h, col: b }))}
                    onMouseLeave={clearHover}
                  >
                    {b}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700">
              {owners.map((a) => (
                <tr key={a}>
                  <td
                    className={`px-3 py-2 font-medium ${
                      hover.row === a ? "bg-zinc-100 dark:bg-zinc-800" : ""
                    }`}
                    onMouseEnter={() => setHover((h) => ({ ...h, row: a }))}
                    onMouseLeave={clearHover}
                  >
                    {a}
                  </td>
                  {owners.map((b) => {
                    const key = `${a}__${b}`;
                    const hasGames =
                      a !== b && (pairGames.get(key)?.length || 0) > 0;
                    const isHilited = hover.row === a || hover.col === b;
                    return (
                      <td
                        key={b}
                        className={`px-3 py-2 text-center transition-colors ${
                          isHilited
                            ? "bg-zinc-100 dark:bg-zinc-800"
                            : hasGames
                            ? "hover:bg-zinc-100 dark:hover:bg-zinc-800 cursor-pointer"
                            : ""
                        }`}
                        onMouseEnter={() => setHover({ row: a, col: b })}
                        onMouseLeave={clearHover}
                        onClick={() => {
                          if (hasGames) setDetailPair({ a, b });
                        }}
                        title={hasGames ? `View ${a} vs ${b}` : ""}
                      >
                        {a === b ? "—" : matrix[a][b]}
                      </td>
                    );
                  })}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Card>
      {/* Matchup detail modal */}
      {detailPair &&
        (() => {
          const key = `${detailPair.a}__${detailPair.b}`;
          const list = pairGames.get(key) || [];
          const totals = list.reduce(
            (acc, g) => {
              if (g.res === "W") acc.w += 1;
              else if (g.res === "L") acc.l += 1;
              return acc;
            },
            { w: 0, l: 0 }
          );
          const fmtPts = (v) =>
            Number.isFinite(Number(v)) ? Number(v).toFixed(1) : "—";

          return (
            <div className="fixed inset-0 z-50 flex items-center justify-center">
              <div
                className="absolute inset-0 bg-black/50"
                onClick={() => setDetailPair(null)}
              />
              <div className="relative w-[min(880px,92vw)] max-h-[85vh] overflow-hidden rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-xl">
                <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 sticky top-0 bg-white dark:bg-zinc-900">
                  <div className="text-base font-semibold">
                    {detailPair.a} vs {detailPair.b} — {segLabel[seg]} •{" "}
                    {totals.w}-{totals.l}
                  </div>
                  <button
                    className="btn btn-xs"
                    onClick={() => setDetailPair(null)}
                  >
                    Close
                  </button>
                </div>

                <div
                  className="p-3 overflow-y-auto"
                  style={{ maxHeight: "calc(85vh - 48px)" }}
                >
                  {list.length ? (
                    <table className="w-full text-sm">
                      <thead className="text-xs uppercase opacity-60">
                        <tr className="border-b border-zinc-200 dark:border-zinc-800">
                          <th className="text-left px-2 py-1 w-[52px]">W/L</th>
                          <th className="text-left px-2 py-1">Owner</th>
                          <th className="text-right px-2 py-1 w-[90px]">
                            {detailPair.a} Pts
                          </th>
                          <th className="text-center px-2 py-1 w-[40px]">vs</th>
                          <th className="text-left px-2 py-1">
                            Opponent (W/L)
                          </th>
                          <th className="text-right px-2 py-1 w-[90px]">
                            {detailPair.b} Pts
                          </th>
                          <th className="text-right px-2 py-1 w-[64px]">
                            Week
                          </th>
                          <th className="text-right px-2 py-1 w-[64px]">
                            Year
                          </th>
                        </tr>
                      </thead>
                      <tbody className="divide-y divide-zinc-200 dark:divide-zinc-800">
                        {list.map((g, i) => (
                          <tr
                            key={i}
                            className="[&:hover]:bg-zinc-50 dark:[&:hover]:bg-zinc-800/40"
                          >
                            <td className="px-2 py-1 font-semibold">
                              <span
                                className={
                                  g.res === "W"
                                    ? "text-green-600 dark:text-green-400"
                                    : "text-red-600 dark:text-red-400"
                                }
                              >
                                {g.res}
                              </span>
                            </td>
                            <td className="px-2 py-1">{g.a}</td>
                            <td className="px-2 py-1 text-right tabular-nums">
                              {fmtPts(g.aPts)}
                            </td>
                            <td className="px-2 py-1 text-center">v</td>
                            <td className="px-2 py-1">
                              <span
                                className={
                                  g.res === "W"
                                    ? "mr-1 font-semibold text-red-600 dark:text-red-400"
                                    : "mr-1 font-semibold text-green-600 dark:text-green-400"
                                }
                                title={
                                  g.res === "W"
                                    ? "Opponent loss"
                                    : "Opponent win"
                                }
                              >
                                {g.res === "W" ? "L" : "W"}
                              </span>
                              {g.b}
                            </td>
                            <td className="px-2 py-1 text-right tabular-nums">
                              {fmtPts(g.bPts)}
                            </td>

                            <td className="px-2 py-1 text-right">
                              {g.week ?? "—"}
                            </td>
                            <td className="px-2 py-1 text-right">
                              {g.year ?? "—"}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  ) : (
                    <div className="text-sm opacity-70 px-2 py-3">
                      No games found.
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        })()}

      {/* Best / Worst opponents */}
      <Card title="Best / Worst Opponents">
        <div className="text-xs text-zinc-500 mb-2">
          {segLabel[seg]} • ties ignored.
        </div>
        <div className="grid sm:grid-cols-2 gap-3 text-sm">
          {owners.map((o) => {
            const bw = bestWorst[o] || {};
            const fmt = (x) =>
              x?.opp
                ? `${x.opp} (${x.w}-${x.l}, ${(x.pct * 100).toFixed(1)}%)`
                : "—";
            return (
              <div
                key={o}
                className="p-3 rounded-lg bg-zinc-50 dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-700"
              >
                <div className="font-medium mb-1">{o}</div>
                <div>Best: {fmt(bw.best)}</div>
                <div>Worst: {fmt(bw.worst)}</div>
              </div>
            );
          })}
        </div>
      </Card>
    </div>
  );
}
/* PlacementsTab ------------------------------------------------------------------ */
export function PlacementsTab({
  league,
  playoffTeamsBase = {}, // ESPN-scraped counts (2018+)
  playoffTeamsOverrides = {}, // manual overrides
  onSavePlayoffOverrides, // saver from App
}) {
  if (!league) return null;

  const owners = league.owners || [];
  const seasons = league.seasonsAll || [];
  // Everyone who has any placement data (used for totals + “last place” math).
  const allOwnersForPlacements = React.useMemo(() => {
    const pm = league?.placementMap;
    return pm && typeof pm === "object" ? Object.keys(pm) : [];
  }, [league?.placementMap]);

  const maxPlaceBySeason = React.useMemo(() => {
    const out = {};
    (seasons || []).forEach((yr) => {
      let max = 0;
      (allOwnersForPlacements || []).forEach((m) => {
        const p = Number(league?.placementMap?.[m]?.[yr]);
        if (Number.isFinite(p) && p > max) max = p;
      });
      out[yr] = max || 0;
    });
    return out;
  }, [seasons, allOwnersForPlacements, league?.placementMap]);
  // compute the global worst finishing position seen across seasons
  const globalMaxPlace = React.useMemo(() => {
    const vals = Object.values(maxPlaceBySeason || {});
    const m = Math.max(0, ...vals);
    return m || 12; // fallback to 12 if empty
  }, [maxPlaceBySeason]);

  // build Y-axis ticks: globalMaxPlace .. 1 (descending so 12, 11, ... 1)
  const yTicks = React.useMemo(() => {
    const max = Number(globalMaxPlace || 12);
    return Array.from({ length: max }, (_, i) => max - i);
  }, [globalMaxPlace]);

  /* NEW: sorting for the placements grid */
  const [gridSort, setGridSort] = React.useState({ key: "member", dir: "asc" });
  const toggleGrid = (key) =>
    setGridSort((prev) => ({
      key,
      dir: prev.key === key && prev.dir === "asc" ? "desc" : "asc",
    }));
  const sortArrow = (state, key) =>
    state.key !== key ? "↕" : state.dir === "asc" ? "▲" : "▼";

  const ownersSorted = React.useMemo(() => {
    const arr = [...owners];
    const k = gridSort.key;
    const dir = gridSort.dir === "asc" ? 1 : -1;

    const getYearPlace = (name, year) => {
      const v = league?.placementMap?.[name]?.[year];
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    arr.sort((a, b) => {
      if (k === "member") return dir * a.localeCompare(b);

      // year column sort
      const ya = getYearPlace(a, k);
      const yb = getYearPlace(b, k);

      const aa = ya ?? (gridSort.dir === "asc" ? Infinity : -Infinity);
      const bb = yb ?? (gridSort.dir === "asc" ? Infinity : -Infinity);

      // Make sure we return a number
      if (aa === bb) return dir * a.localeCompare(b);
      return dir * (aa - bb);
    });

    return arr;
  }, [owners, gridSort, league?.placementMap]);

  // Merged playoff-team counts (override wins)
  const mergedPlayoffTeams = React.useMemo(() => {
    const out = {};
    (seasons || []).forEach((yr) => {
      const base = Number(playoffTeamsBase?.[yr] ?? 0) || 0;
      const ovrd = Number(playoffTeamsOverrides?.[yr] ?? 0) || 0;
      out[yr] = ovrd || base || 0;
    });
    return out;
  }, [seasons, playoffTeamsBase, playoffTeamsOverrides]);

  // Local editor state for the override inputs
  const [edit, setEdit] = React.useState(playoffTeamsOverrides || {});
  React.useEffect(
    () => setEdit(playoffTeamsOverrides || {}),
    [playoffTeamsOverrides]
  );
  const setYr = (yr, val) => {
    const n = Math.max(0, Math.round(Number(val) || 0));
    setEdit((p) => ({ ...p, [yr]: n }));
  };
  const commit = () => {
    if (onSavePlayoffOverrides) onSavePlayoffOverrides(edit);
  };

  const summary = owners.map((m) => {
    let total = 0;
    let count = 0;
    let firsts = 0;
    let top3 = 0;
    let lasts = 0;
    let playoffs = 0;

    seasons.forEach((yr) => {
      const p = league.placementMap?.[m]?.[yr];
      if (p) {
        total += p;
        count += 1;
        if (p === 1) firsts += 1;
        if (p <= 3) top3 += 1;

        /* NEW: "last" = equals the worst actual finish for that season */
        const worst = Number(maxPlaceBySeason?.[yr] || 0);
        if (Number(p) === worst && worst > 0) lasts += 1;

        // Playoff appearance = placement <= playoff-team-count for that season
        const poCnt = Number(mergedPlayoffTeams?.[yr] || 0);
        if (poCnt > 0 && p <= poCnt) playoffs += 1;
      }
    });

    const avg = count ? total / count : 0;
    return { member: m, avg, firsts, top3, playoffs, lasts };
  });
  // sorting for the summary table
  const [sumSort, setSumSort] = React.useState({ key: "avg", dir: "asc" });
  const toggleSummary = (key) =>
    setSumSort((prev) => ({
      key,
      dir: prev.key === key && prev.dir === "asc" ? "desc" : "asc",
    }));

  const summarySorted = React.useMemo(() => {
    const arr = [...summary];
    const dir = sumSort.dir === "asc" ? 1 : -1;
    const k = sumSort.key;

    arr.sort((a, b) => {
      if (k === "member") return dir * a.member.localeCompare(b.member);
      const av = Number(a[k]);
      const bv = Number(b[k]);
      const aa = Number.isFinite(av)
        ? av
        : sumSort.dir === "asc"
        ? Infinity
        : -Infinity;
      const bb = Number.isFinite(bv)
        ? bv
        : sumSort.dir === "asc"
        ? Infinity
        : -Infinity;
      return dir * (aa - bb);
    });

    return arr;
  }, [summary, sumSort]);
  const ordinalSafe = (n) => {
    const x = Number(n);
    if (!Number.isFinite(x)) return "";
    if (x % 100 >= 11 && x % 100 <= 13) return `${x}th`;
    switch (x % 10) {
      case 1:
        return `${x}st`;
      case 2:
        return `${x}nd`;
      case 3:
        return `${x}rd`;
      default:
        return `${x}th`;
    }
  };
  // ============================================================
  // Placements line chart prep
  // ============================================================

  // Small emoji fallback for medals (uses emojis if TROPHIES images aren’t handy)
  const medalFor = (place) =>
    place === 1 ? "🥇" : place === 2 ? "🥈" : place === 3 ? "🥉" : null;

  // Build a tidy series per owner: [{ year, owner, place }]
  const seriesByOwner = React.useMemo(() => {
    const out = new Map(); // owner -> [{year, place}]
    (owners || []).forEach((o) => out.set(o, []));
    (seasons || []).forEach((yr) => {
      (owners || []).forEach((o) => {
        const p = Number(league?.placementMap?.[o]?.[yr] ?? NaN);
        out.get(o).push({ year: yr, place: Number.isFinite(p) ? p : null });
      });
    });
    return out; // Map(owner -> array)
  }, [owners, seasons, league?.placementMap]);
  // Years that actually have final placements (exclude empty/in-progress years)
  // Years that actually have final placements (must be exactly 1..N with no gaps)
  const seasonsChart = React.useMemo(() => {
    const out = [];
    for (const yr of seasons || []) {
      // collect all numeric placements for this year
      const places = (allOwnersForPlacements || [])
        .map((o) => Number(league?.placementMap?.[o]?.[yr]))
        .filter((p) => Number.isFinite(p) && p > 0);

      if (places.length === 0) continue;

      const max = Math.max(...places);
      const min = Math.min(...places);

      // Completed if we have exactly one of each rank 1..max (no gaps/dupes)
      const set = new Set(places);
      const looksComplete =
        min === 1 && set.size === max && places.length === max;

      if (looksComplete) out.push(yr);
    }
    return out;
  }, [seasons, allOwnersForPlacements, league?.placementMap]);

  const chartRows = React.useMemo(() => {
    return (seasonsChart || []).map((yr) => {
      const row = { year: yr };
      (owners || []).forEach((o) => {
        const p = Number(league?.placementMap?.[o]?.[yr] ?? NaN);
        row[o] = Number.isFinite(p) ? p : null;
      });
      return row;
    });
  }, [owners, seasonsChart, league?.placementMap]);

  // Visible owners (toggle via checkboxes)
  const [visibleOwners, setVisibleOwners] = React.useState(
    () => new Set(owners || [])
  );
  React.useEffect(() => {
    setVisibleOwners((prev) => {
      const next = new Set();
      (owners || []).forEach((o) => prev.has(o) && next.add(o));
      if (next.size === 0 && (owners || []).length)
        (owners || []).forEach((o) => next.add(o));
      return next;
    });
  }, [owners]);

  const toggleOwnerVisible = (o) => {
    setVisibleOwners((prev) => {
      const n = new Set(prev);
      if (n.has(o)) n.delete(o);
      else n.add(o);
      return n;
    });
  };
  const selectAllOwners = () => setVisibleOwners(new Set(owners || []));
  const clearAllOwners = () => setVisibleOwners(new Set());

  // Axis domain: 1 is best; worst = max placement in any season
  const worstOverall = React.useMemo(() => {
    let max = 0;
    (seasons || []).forEach((yr) => {
      const w = Number(maxPlaceBySeason?.[yr] || 0);
      if (w > max) max = w;
    });
    return max || 12; // fallback
  }, [seasons, maxPlaceBySeason]);

  // “Playoff line” per season (uses override if present, else ESPN base, else 0)
  const playoffBySeason = React.useMemo(() => {
    const out = {};
    (seasons || []).forEach((yr) => {
      out[yr] = Number(mergedPlayoffTeams?.[yr] || 0);
    });
    return out;
  }, [seasons, mergedPlayoffTeams]);

  // Simple color palette for lines
  const COLORS = [
    "#8ab4f8",
    "#f28b82",
    "#fdd663",
    "#81c995",
    "#d7aefb",
    "#78d9ec",
    "#fbbc04",
    "#34a853",
    "#e8710a",
    "#a142f4",
    "#46bdc6",
    "#ea4335",
  ];
  const colorFor = (idx) => COLORS[idx % COLORS.length];
  // Always show full range 1..12 on the Y-axis
  const Y_TICKS = React.useMemo(
    () => Array.from({ length: 12 }, (_, i) => i + 1),
    []
  );

  // add these:
  const ownerIndex = React.useCallback(
    (o) => (owners || []).indexOf(o),
    [owners]
  );

  const ownerColor = React.useCallback(
    (o) => colorFor(Math.max(0, ownerIndex(o))),
    [ownerIndex]
  );

  const MedalDot = ({ cx, cy, value }) => {
    if (value == null) return null;
    const medal = medalFor(Number(value));
    if (medal) {
      return (
        <text x={cx} y={cy} dy={6} textAnchor="middle" fontSize={24}>
          {medal}
        </text>
      );
    }
    return <circle cx={cx} cy={cy} r={3} fill="currentColor" opacity="0.9" />;
  };

  return (
    <div className="space-y-6">
      {/* Overrides row */}
      <Card
        title="Playoff teams per season"
        right={
          <button
            className="btn btn-xs"
            onClick={commit}
            title="Save overrides"
          >
            Save
          </button>
        }
      >
        <div className="flex flex-wrap gap-3 items-center">
          {seasons.map((yr) => {
            const espnVal = Number(playoffTeamsBase?.[yr] || 0) || 0;
            const show = edit[yr] ?? mergedPlayoffTeams[yr] ?? 0;
            return (
              <label key={yr} className="flex items-center gap-2 text-sm">
                <span className="w-12 text-right opacity-70">{yr}</span>
                <input
                  type="number"
                  min={0}
                  className="w-16 px-2 py-1 rounded bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
                  value={show || ""}
                  placeholder={espnVal ? String(espnVal) : "0"}
                  onChange={(e) => setYr(yr, e.target.value)}
                  onBlur={commit}
                />
                {espnVal ? (
                  <span className="text-xs text-zinc-500">
                    (ESPN: {espnVal})
                  </span>
                ) : null}
              </label>
            );
          })}
        </div>
        <div className="mt-2 text-xs text-zinc-500">
          ESPN usually provides values from ~2018+. Enter or override earlier
          years here. Your changes are saved locally and used across tabs.
        </div>
      </Card>

      {/* Placements grid */}
      <TableBox>
        <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
          <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
            <th className="px-3 py-2 text-left">
              {/* NEW: clickable header */}
              <button
                className="inline-flex items-center gap-1"
                onClick={() => toggleGrid("member")}
                title="Sort by member"
              >
                Member{" "}
                <span className="opacity-60 text-xs">
                  {sortArrow(gridSort, "member")}
                </span>
              </button>
            </th>
            {seasons.map((yr) => (
              <th key={yr} className="px-3 py-2 text-center">
                {/* NEW: clickable year header */}
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleGrid(yr)}
                  title={`Sort by ${yr}`}
                >
                  {yr}{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(gridSort, yr)}
                  </span>
                </button>
              </th>
            ))}
          </tr>
        </thead>

        <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700 [&>tr:nth-child(odd)]:bg-zinc-50 dark:[&>tr:nth-child(odd)]:bg-zinc-900 [&>tr:hover]:bg-zinc-100 dark:[&>tr:hover]:bg-zinc-800">
          {/* NEW: ownersSorted */}
          {ownersSorted.map((member) => (
            <tr key={member}>
              <td className="px-3 py-2 font-medium whitespace-nowrap">
                {member}
              </td>
              {seasons.map((yr) => {
                const place = league.placementMap?.[member]?.[yr];
                const poCnt = Number(mergedPlayoffTeams?.[yr] || 0);
                const hasPOInfo = poCnt > 0;
                const madePO = !!(place && hasPOInfo && place <= poCnt);
                const missedPO = !!(place && hasPOInfo && place > poCnt);

                // Shading: green if made playoffs, gray if missed (when we know playoff count)
                const baseClass = madePO
                  ? "bg-emerald-100 text-emerald-900 dark:bg-emerald-900/40 dark:text-emerald-100"
                  : "bg-zinc-100 text-zinc-900 dark:bg-zinc-800 dark:text-zinc-200";

                // Use trophy images for 1st/2nd/3rd; otherwise show the ordinal/plain number
                const isTop3 = Number(place) >= 1 && Number(place) <= 3;
                const label = Number.isFinite(Number(place))
                  ? ordinal(Number(place))
                  : "";

                return (
                  <td key={`${member}-${yr}`} className="px-3 py-2 text-center">
                    {place ? (
                      <span
                        className={`inline-flex items-center gap-2 px-2 py-1 rounded-lg ${
                          madePO
                            ? "bg-emerald-100 text-emerald-900 dark:bg-emerald-900/40 dark:text-emerald-100"
                            : "bg-zinc-100 text-zinc-900 dark:bg-zinc-800 dark:text-zinc-200"
                        }`}
                        title={
                          hasPOInfo
                            ? madePO
                              ? "Playoffs: Yes"
                              : "Playoffs: No"
                            : "Playoffs: (unknown for this season)"
                        }
                      >
                        {(() => {
                          const m = medalFor(Number(place));
                          if (m) return <span className="text-lg">{m}</span>;
                          return (
                            <span className="tabular-nums">
                              {ordinalSafe(Number(place))}
                            </span>
                          );
                        })()}
                      </span>
                    ) : (
                      <span className="text-zinc-400">—</span>
                    )}
                  </td>
                );
              })}
            </tr>
          ))}
        </tbody>
      </TableBox>
      {/* ============================================================
          Placements over time (toggle owners, shaded playoff area)
          ============================================================ */}
      <Card title="Placements over time">
        {/* Quick toggles */}
        <div className="mb-2 flex gap-2">
          <button
            type="button"
            className="btn btn-xs"
            onClick={selectAllOwners}
          >
            Select all
          </button>
          <button type="button" className="btn btn-xs" onClick={clearAllOwners}>
            Deselect all
          </button>
        </div>

        {/* Owner toggles */}
        <div className="mb-3 flex flex-wrap gap-3 max-h-28 overflow-auto pr-1">
          {(owners || []).map((o, i) => (
            <label key={o} className="inline-flex items-center gap-2 text-sm">
              <input
                type="checkbox"
                className="checkbox checkbox-sm"
                checked={visibleOwners.has(o)}
                onChange={() => toggleOwnerVisible(o)}
              />
              <span className="inline-flex items-center gap-2">
                <span
                  className="inline-block h-2.5 w-2.5 rounded-full"
                  style={{ backgroundColor: colorFor(i) }}
                />
                {o}
              </span>
            </label>
          ))}
        </div>

        <div className="h-[560px] w-full">
          {" "}
          {/* taller chart so labels don't collide */}
          <ResponsiveContainer width="100%" height={520}>
            <LineChart
              data={chartRows}
              margin={{ top: 16, right: 28, bottom: 44, left: 16 }} // more bottom space
            >
              <CartesianGrid strokeDasharray="3 3" opacity={0.25} />

              <XAxis
                dataKey="year"
                type="number"
                allowDecimals={false}
                tickCount={seasonsChart.length}
                interval="preserveStartEnd"
                tick={{ fill: "#e5e7eb", fontSize: 14, fontWeight: 700 }}
                domain={[
                  (seasonsChart[0] ?? 2013) - 0.5,
                  (seasonsChart[seasonsChart.length - 1] ??
                    new Date().getFullYear()) + 0.5,
                ]}
                tickFormatter={(v) => String(v)}
                axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
              />

              {/* Y axis: 1 at the top; label every finishing position */}
              <YAxis
                type="number"
                domain={[1, globalMaxPlace]} // fixed: 1..max; no padding
                ticks={yTicks} // 12, 11, ..., 1
                allowDecimals={false}
                reversed // so 1 is at the top
                tick={{ fill: "#e5e7eb", fontSize: 14, fontWeight: 700 }}
                axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
              />

              <Tooltip
                contentStyle={{
                  background: "rgba(24,24,27,0.95)",
                  border: "1px solid rgba(255,255,255,0.12)",
                  color: "#e5e7eb",
                }}
                labelStyle={{ color: "#fff", fontWeight: 700 }}
                labelFormatter={(v) => `Season ${v}`}
                formatter={(value, name) => [`Place: ${value}`, name]}
              />

              {/* Per-season playoff shading (independent of selected owners) */}
              {seasonsChart.map((yr) => {
                const raw = Number(mergedPlayoffTeams?.[yr] || 0);
                if (!raw) return null;
                const cutoff = Math.max(1, Math.min(globalMaxPlace, raw));
                return (
                  <ReferenceArea
                    key={`po-${yr}`}
                    x1={yr - 0.5}
                    x2={yr + 0.5}
                    y1={1}
                    y2={cutoff}
                    stroke="none"
                    fill="rgba(34,197,94,0.25)" // brighter green
                  />
                );
              })}

              {/* Lines for each visible owner */}
              {Array.from(visibleOwners).map((owner, i) => (
                <Line
                  key={owner}
                  type="monotone"
                  dataKey={owner}
                  stroke={colorFor(i)}
                  strokeWidth={3.5} // thicker lines
                  dot={<MedalDot />} // medals visible at 1/2/3
                  activeDot={{ r: 6, strokeWidth: 2, stroke: "#fff" }}
                  connectNulls
                />
              ))}
            </LineChart>
          </ResponsiveContainer>
        </div>

        <div className="mt-2 text-xs text-zinc-500">
          Shaded band indicates playoff placements (uses your per-season playoff
          team counts; manual overrides take precedence). Medals mark
          1st/2nd/3rd finishes.
        </div>
      </Card>

      <Card title="Playoff stats">
        <TableBox>
          <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
            <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
              <th className="px-3 py-2 text-left">
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleSummary("member")}
                >
                  Member{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(sumSort, "member")}
                  </span>
                </button>
              </th>
              <th className="px-3 py-2">
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleSummary("avg")}
                >
                  Avg Place{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(sumSort, "avg")}
                  </span>
                </button>
              </th>
              <th className="px-3 py-2">
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleSummary("firsts")}
                >
                  # 1sts{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(sumSort, "firsts")}
                  </span>
                </button>
              </th>
              <th className="px-3 py-2">
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleSummary("top3")}
                >
                  # Top 3s{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(sumSort, "top3")}
                  </span>
                </button>
              </th>
              <th className="px-3 py-2">
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleSummary("playoffs")}
                >
                  # Playoff Apps{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(sumSort, "playoffs")}
                  </span>
                </button>
              </th>
              <th className="px-3 py-2">
                <button
                  className="inline-flex items-center gap-1"
                  onClick={() => toggleSummary("lasts")}
                >
                  # Lasts{" "}
                  <span className="opacity-60 text-xs">
                    {sortArrow(sumSort, "lasts")}
                  </span>
                </button>
              </th>
            </tr>
          </thead>
          <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700 [&>tr:nth-child(odd)]:bg-zinc-50 dark:[&>tr:nth-child(odd)]:bg-zinc-900 [&>tr:hover]:bg-zinc-100 dark:[&>tr:hover]:bg-zinc-800">
            {summarySorted.map((s) => (
              <tr key={s.member}>
                <td className="px-3 py-2 text-left font-medium">{s.member}</td>
                <td className="px-3 py-2 text-center">
                  {Number.isFinite(s.avg) && s.avg > 0 ? s.avg.toFixed(2) : "—"}
                </td>
                <td className="px-3 py-2 text-center">{s.firsts}</td>
                <td className="px-3 py-2 text-center">{s.top3}</td>
                <td className="px-3 py-2 text-center">{s.playoffs}</td>
                <td className="px-3 py-2 text-center">{s.lasts}</td>
              </tr>
            ))}
          </tbody>
        </TableBox>
      </Card>

      {/* (Chart section unchanged) ... */}
    </div>
  );
}

/* MoneyTab (updated with dynamic heat, collapse, copy/paste, and earnings chart) */
export function MoneyTab({ league, moneyInputs, setMoneyInputs }) {
  if (!league) return null;
  const seasons = league.seasonsAll || [];
  const rawOwners = Array.isArray(league?.owners) ? league.owners : [];
  const hidden = new Set(
    Array.isArray(league?.hiddenManagers) ? league.hiddenManagers : []
  );
  const ownersList = rawOwners.filter((o) => !hidden.has(o));

  // UI: payout tiers + weekly addon visibility
  const [payoutTiers, setPayoutTiers] = useState(3);
  const [showWeekly, setShowWeekly] = useState(() => {
    // auto-show if any season already has a weekly value saved
    return seasons.some((yr) => moneyInputs?.[yr]?.weeklyHigh != null);
  });

  // NEW: collapse/expand for inputs (collapsed by default)
  const [inputsOpen, setInputsOpen] = useState(false);

  // Sorting
  const [sortBy, setSortBy] = useState("owner");
  const [sortDir, setSortDir] = useState(1); // 1 = asc, -1 = desc
  const toggleSort = (key) => {
    if (sortBy === key) setSortDir((d) => d * -1);
    else {
      setSortBy(key);
      setSortDir(-1); // default to desc on first click for numeric fields
    }
  };

  // Input helper
  const setSeasonVal = (yr, field, val) =>
    setMoneyInputs((prev) => ({
      ...prev,
      [yr]: { ...(prev[yr] || {}), [field]: Number(val) || 0 },
    }));

  // Season participation map (to charge buy-ins only when they played)
  const playedByOwnerSeason = new Map();
  (league.games || []).forEach((g) => {
    playedByOwnerSeason.set(`${g.owner}__${g.season}`, true);
  });

  // Collect season payout amounts per place and weeklyHigh
  const seasonPayouts = {};
  seasons.forEach((yr) => {
    seasonPayouts[yr] = [];
    for (let i = 1; i <= payoutTiers; i++) {
      const key =
        i === 1 ? "first" : i === 2 ? "second" : i === 3 ? "third" : `p${i}`;
      seasonPayouts[yr][i] = moneyInputs[yr]?.[key] || 0;
    }
  });

  // Weekly highest-scorer counts per owner per season (regular season only)
  const weeklyCountsByOwnerSeason = useMemo(() => {
    const map = new Map(); // key: `${owner}__${season}` -> integer count
    const bySeasonWeek = new Map(); // `${season}__${week}` -> array of { owner, pf }

    (league.games || []).forEach((g) => {
      if (g.is_playoff === true) return; // regular season only
      // ignore future/undecided weeks
      if (!(g.res === "W" || g.res === "L")) return;

      const s = Number(g.season);
      const w = Number(g.week);
      if (!Number.isFinite(s) || !Number.isFinite(w)) return;
      const key = `${s}__${w}`;
      if (!bySeasonWeek.has(key)) bySeasonWeek.set(key, []);
      bySeasonWeek.get(key).push({ owner: g.owner, pf: Number(g.pf) || 0 });
    });

    for (const [key, arr] of bySeasonWeek.entries()) {
      if (!arr.length) continue;
      const [sStr] = key.split("__");
      const s = Number(sStr);
      let max = -Infinity;
      arr.forEach((r) => (max = Math.max(max, r.pf)));
      // count ALL tied highest scorers (each receives full weekly payout)
      arr
        .filter((r) => r.pf === max)
        .forEach((r) => {
          const k = `${r.owner}__${s}`;
          map.set(k, (map.get(k) || 0) + 1);
        });
    }
    return map;
  }, [league.games]);

  // Aggregate invested / earned (totals) + per-year (for chart)
  const invested = {};
  const earned = {};
  const earnedByPlace = {};
  const weeklyEarned = {};
  const earnedByOwnerYear = {};
  const investedByOwnerYear = {};
  const ownersSet = new Set(ownersList);
  (ownersList || []).forEach((o) => {
    invested[o] = 0;
    earned[o] = 0;
    weeklyEarned[o] = 0;
    earnedByPlace[o] = {};
    earnedByOwnerYear[o] = {};
    investedByOwnerYear[o] = {};
    for (let i = 1; i <= payoutTiers; i++) earnedByPlace[o][i] = 0;
  });

  seasons.forEach((yr) => {
    const buyin = moneyInputs[yr]?.buyin || 0;

    // Charge buy-ins
    (ownersList || []).forEach((o) => {
      if (playedByOwnerSeason.get(`${o}__${yr}`)) {
        invested[o] += buyin;
        investedByOwnerYear[o][yr] = (investedByOwnerYear[o][yr] || 0) + buyin;
      }
    });

    // Season placements -> payouts
    const placeToOwner = Object.entries(league.placementMap || {}).reduce(
      (acc, [owner, map]) => {
        const p = map?.[yr];
        if (p) acc[p] = owner;
        return acc;
      },
      {}
    );
    for (let i = 1; i <= payoutTiers; i++) {
      const o = placeToOwner[i];
      const amt = seasonPayouts[yr][i] || 0;
      if (o && amt && ownersSet.has(o)) {
        earned[o] += amt;
        earnedByPlace[o][i] += amt;
        earnedByOwnerYear[o][yr] = (earnedByOwnerYear[o][yr] || 0) + amt;
      }
    }

    // Weekly highest-scorer payouts (addon)
    const weeklyAmt = moneyInputs[yr]?.weeklyHigh || 0;
    if (weeklyAmt) {
      (ownersList || []).forEach((o) => {
        const count = weeklyCountsByOwnerSeason.get(`${o}__${yr}`) || 0;
        if (count > 0) {
          const payout = count * weeklyAmt; // no split on ties
          earned[o] += payout;
          weeklyEarned[o] += payout;
          earnedByOwnerYear[o][yr] = (earnedByOwnerYear[o][yr] || 0) + payout;
        }
      });
    }
  });

  // Build rows
  let rows = (ownersList || []).map((o) => ({
    owner: o,
    invested: invested[o],
    earned: earned[o],
    roi: invested[o] ? (earned[o] - invested[o]) / invested[o] : 0,
    byPlace: earnedByPlace[o],
    weekly: weeklyEarned[o],
  }));

  // Sorting across supported keys
  rows.sort((a, b) => {
    if (sortBy === "owner") return a.owner.localeCompare(b.owner) * sortDir;
    if (sortBy === "invested") return (a.invested - b.invested) * sortDir;
    if (sortBy === "earned") return (a.earned - b.earned) * sortDir;
    if (sortBy === "roi") return (a.roi - b.roi) * sortDir;
    const m = /^place(\d+)$/.exec(sortBy);
    if (m) {
      const idx = Number(m[1]);
      return ((a.byPlace[idx] || 0) - (b.byPlace[idx] || 0)) * sortDir;
    }
    if (sortBy === "weekly") return (a.weekly - b.weekly) * sortDir;
    return 0;
  });

  // Value-based tones for Earned/ROI (always reflects values, not order)
  const extent = (arr) => {
    let min = Infinity,
      max = -Infinity;
    arr.forEach((v) => {
      const n = Number(v);
      if (!Number.isFinite(n)) return;
      if (n < min) min = n;
      if (n > max) max = n;
    });
    if (!Number.isFinite(min)) min = 0;
    if (!Number.isFinite(max)) max = 0;
    return [min, max];
  };

  const [roiMin, roiMax] = extent(rows.map((r) => r.roi));
  const [earnedMin, earnedMax] = extent(rows.map((r) => r.earned));

  const toneByValue = (value, min, max, goodHigh = true) => {
    if (max === min) {
      return "bg-zinc-100 text-zinc-900 dark:bg-zinc-800 dark:text-zinc-100";
    }
    let t = (Number(value) - min) / (max - min);
    if (!goodHigh) t = 1 - t;
    if (t <= 0.2)
      return "bg-red-300 text-red-900 dark:bg-red-950/60 dark:text-red-200";
    if (t <= 0.4)
      return "bg-red-200 text-red-900 dark:bg-red-900/50 dark:text-red-200";
    if (t <= 0.6)
      return "bg-yellow-100 text-yellow-900 dark:bg-yellow-900/40 dark:text-yellow-200";
    if (t <= 0.8)
      return "bg-green-100 text-green-900 dark:bg-green-900/40 dark:text-green-200";
    return "bg-emerald-100 text-emerald-900 dark:bg-emerald-900/40 dark:text-emerald-200";
  };

  // Helper to show weekly column if enabled or any season has a value
  const weeklyEnabled =
    showWeekly ||
    seasons.some((yr) => (moneyInputs[yr]?.weeklyHigh ?? null) != null);

  // ====== COPY/PASTE row state & helpers ====================================
  const [copiedFrom, setCopiedFrom] = useState(null); // season number or null
  const buildRowPayload = (yr) => {
    const payload = { buyin: Number(moneyInputs[yr]?.buyin || 0) };
    for (let i = 1; i <= payoutTiers; i++) {
      const key =
        i === 1 ? "first" : i === 2 ? "second" : i === 3 ? "third" : `p${i}`;
      payload[key] = Number(moneyInputs[yr]?.[key] || 0);
    }
    const hasWeekly =
      moneyInputs[yr]?.weeklyHigh != null ? moneyInputs[yr]?.weeklyHigh : null;
    if (hasWeekly != null) payload.weeklyHigh = Number(hasWeekly) || 0;
    return payload;
  };
  const pastePayloadToYear = (yr, payload) =>
    setMoneyInputs((prev) => ({
      ...prev,
      [yr]: { ...(prev[yr] || {}), ...payload },
    }));

  // ====== CHART: cumulative earned + ROI line ================================
  const yearsAsc = useMemo(() => [...seasons].sort((a, b) => a - b), [seasons]);

  const [ownerSel, setOwnerSel] = useState(ownersList[0] || "");
  const [metricMode, setMetricMode] = useState("earned"); // 'earned' | 'profit'
  useEffect(() => {
    if (!ownersList.length) setOwnerSel("");
    else if (!ownersList.includes(ownerSel)) setOwnerSel(ownersList[0]);
  }, [ownersList, ownerSel]);
  // REPLACE the existing ownerSeries/posMax/negMin/barFill/roiDomain block with this:
  const ownerSeries = useMemo(() => {
    let cumE = 0,
      cumI = 0;
    const out = [];
    yearsAsc.forEach((y) => {
      const e = Number(earnedByOwnerYear?.[ownerSel]?.[y] || 0);
      const i = Number(investedByOwnerYear?.[ownerSel]?.[y] || 0);
      cumE += e;
      cumI += i;
      const cumProfit = cumE - cumI;
      const roi = cumI > 0 ? cumProfit / cumI : 0;

      // unified "value" key drives the bars
      out.push({
        year: y,
        value: metricMode === "earned" ? cumE : cumProfit,
        cumEarned: cumE,
        cumInvested: cumI,
        roi,
      });
    });
    return out;
  }, [yearsAsc, ownerSel, metricMode, earnedByOwnerYear, investedByOwnerYear]);

  // Color scaling for bars depends on the selected metric's values
  const seriesVals = ownerSeries.map((d) => Number(d.value) || 0);
  const posMax = Math.max(0, ...seriesVals.map((v) => (v > 0 ? v : 0)));
  const negMin = Math.min(0, ...seriesVals.map((v) => (v < 0 ? v : 0)));

  const barFill = (v) => {
    if (v >= 0) {
      const t = posMax > 0 ? v / posMax : 0.5;
      const L = 88 - t * 48; // 88% → 40%
      return `hsl(142 70% ${L}%)`; // green
    } else {
      const t = negMin < 0 ? Math.abs(v) / Math.abs(negMin) : 0.5;
      const L = 88 - t * 48;
      return `hsl(0 75% ${L}%)`; // red
    }
  };

  // ROI axis domain (with a little padding)
  const [roiMinSel, roiMaxSel] = (function () {
    let mn = Infinity,
      mx = -Infinity;
    ownerSeries.forEach((d) => {
      const r = Number(d.roi);
      if (!Number.isFinite(r)) return;
      if (r < mn) mn = r;
      if (r > mx) mx = r;
    });
    if (!Number.isFinite(mn)) mn = 0;
    if (!Number.isFinite(mx)) mx = 0;
    return [mn, mx];
  })();
  const roiDomain = [
    Math.min(roiMinSel - 0.05, -0.1),
    Math.max(roiMaxSel + 0.05, 0.1),
  ];

  return (
    <div className="space-y-6">
      <Card
        title="Season Buy-ins & Payouts"
        right={
          <div className="flex items-center gap-2">
            {/* collapse/expand */}
            <button
              className="px-2 py-1 rounded-lg bg-zinc-100 dark:bg-zinc-800 text-xs"
              onClick={() => setInputsOpen((o) => !o)}
              title={inputsOpen ? "Collapse inputs" : "Expand inputs"}
            >
              {inputsOpen ? "Collapse" : "Expand"}
            </button>

            {/* copy mode indicator/cancel */}
            {copiedFrom != null ? (
              <button
                className="px-2 py-1 rounded-lg bg-amber-100 dark:bg-amber-900/40 text-xs"
                onClick={() => setCopiedFrom(null)}
                title="Exit copy mode"
              >
                Cancel copy
              </button>
            ) : null}

            <button
              className="px-2 py-1 rounded-lg bg-zinc-100 dark:bg-zinc-800 text-xs"
              onClick={() => setPayoutTiers((p) => Math.min(10, p + 1))}
              disabled={!inputsOpen}
              title={!inputsOpen ? "Expand to edit tiers" : "Add payout tier"}
            >
              + Add payout tier
            </button>
            <button
              className="px-2 py-1 rounded-lg bg-zinc-100 dark:bg-zinc-800 text-xs"
              onClick={() => setShowWeekly(true)}
              disabled={!inputsOpen}
              title={
                !inputsOpen ? "Expand to edit weekly" : "Add weekly payout"
              }
            >
              + Add weekly payout
            </button>
          </div>
        }
      >
        {inputsOpen ? (
          <TableBox>
            <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
              <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
                <th className="px-2 py-1 text-left">Season</th>
                <th className="px-2 py-1">Buy-in (per team)</th>
                {[...Array(payoutTiers)].map((_, i) => (
                  <th key={i} className="px-2 py-1">
                    {i + 1}
                    {i === 0 ? "st" : i === 1 ? "nd" : i === 2 ? "rd" : "th"}
                  </th>
                ))}
                {weeklyEnabled && <th className="px-2 py-1">Weekly</th>}
                <th className="px-2 py-1 text-right">Tools</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700 [&>tr:nth-child(odd)]:bg-zinc-50 dark:[&>tr:nth-child(odd)]:bg-zinc-900 [&>tr:hover]:bg-zinc-100 dark:[&>tr:hover]:bg-zinc-800">
              {seasons.map((yr) => (
                <tr key={yr} className="text-center">
                  <td className="px-2 py-1 text-left font-medium">{yr}</td>
                  <td>
                    <input
                      className="w-24 px-2 py-1 rounded bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
                      type="number"
                      step="1"
                      value={moneyInputs[yr]?.buyin || ""}
                      onChange={(e) =>
                        setSeasonVal(yr, "buyin", e.target.value)
                      }
                    />
                  </td>
                  {[...Array(payoutTiers)].map((_, i) => {
                    const key =
                      i === 0
                        ? "first"
                        : i === 1
                        ? "second"
                        : i === 2
                        ? "third"
                        : `p${i + 1}`;
                    return (
                      <td key={i}>
                        <input
                          className="w-24 px-2 py-1 rounded bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
                          type="number"
                          step="1"
                          value={moneyInputs[yr]?.[key] || ""}
                          onChange={(e) =>
                            setSeasonVal(yr, key, e.target.value)
                          }
                        />
                      </td>
                    );
                  })}
                  {weeklyEnabled && (
                    <td>
                      <input
                        className="w-24 px-2 py-1 rounded bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
                        type="number"
                        step="1"
                        placeholder="0"
                        value={
                          moneyInputs[yr]?.weeklyHigh != null
                            ? moneyInputs[yr]?.weeklyHigh
                            : ""
                        }
                        onChange={(e) =>
                          setSeasonVal(yr, "weeklyHigh", e.target.value)
                        }
                      />
                    </td>
                  )}
                  <td className="px-2 py-1 text-right">
                    {copiedFrom == null ? (
                      <button
                        className="px-2 py-1 rounded bg-zinc-200 dark:bg-zinc-700 text-xs"
                        onClick={() => setCopiedFrom(yr)}
                        title="Copy this year's payouts"
                      >
                        Copy
                      </button>
                    ) : copiedFrom === yr ? (
                      <span className="px-2 py-1 rounded bg-emerald-200 dark:bg-emerald-900/40 text-xs">
                        Copied ✓
                      </span>
                    ) : (
                      <button
                        className="px-2 py-1 rounded bg-blue-200 dark:bg-blue-900/40 text-xs"
                        onClick={() =>
                          pastePayloadToYear(yr, buildRowPayload(copiedFrom))
                        }
                        title={`Paste values from ${copiedFrom}`}
                      >
                        Paste
                      </button>
                    )}
                  </td>
                </tr>
              ))}
            </tbody>
          </TableBox>
        ) : (
          <div className="text-xs opacity-70">
            Inputs are collapsed. Click <b>Expand</b> to edit buy-ins, payout
            tiers, and weekly payouts. You can also copy a year and paste to
            others once expanded.
          </div>
        )}
      </Card>
      {/* ====== Earnings & ROI Over Time (chart) ====== */}
      <Card
        title="Earnings & ROI Over Time"
        subtitle={
          metricMode === "earned"
            ? "Cumulative earnings by year with ROI line"
            : "Cumulative profit (earned − invested) by year with ROI line"
        }
        right={
          <div className="flex items-center gap-2">
            <select
              className="px-2 py-1 rounded border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-950"
              value={ownerSel}
              onChange={(e) => setOwnerSel(e.target.value)}
              title="Select manager"
            >
              {(ownersList || []).map((o) => (
                <option key={o} value={o}>
                  {o}
                </option>
              ))}
            </select>

            <select
              className="px-2 py-1 rounded border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-950"
              value={metricMode}
              onChange={(e) => setMetricMode(e.target.value)}
              title="Bar metric"
            >
              <option value="earned">Earned</option>
              <option value="profit">Profit</option>
            </select>
          </div>
        }
      >
        <div className="h-[440px] w-full">
          <ResponsiveContainer width="100%" height={400}>
            <ComposedChart
              data={ownerSeries}
              margin={{ top: 8, right: 28, bottom: 24, left: 12 }}
            >
              <CartesianGrid
                strokeDasharray="3 3"
                opacity={0.25}
                vertical={false}
              />
              <XAxis
                dataKey="year"
                allowDecimals={false}
                tick={{ fill: "#e5e7eb", fontSize: 12 }}
                axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
              />
              <YAxis
                yAxisId="left"
                tick={{ fill: "#e5e7eb", fontSize: 12 }}
                axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickFormatter={(v) => `$${Math.round(v).toLocaleString()}`}
              />
              <YAxis
                yAxisId="right"
                orientation="right"
                domain={roiDomain}
                tick={{ fill: "#e5e7eb", fontSize: 12 }}
                axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
                tickFormatter={(v) => `${(v * 100).toFixed(0)}%`}
              />
              <ReferenceLine
                y={0}
                yAxisId="left"
                stroke="rgba(255,255,255,0.2)"
              />

              <Tooltip
                contentStyle={{
                  background: "rgba(24,24,27,0.95)",
                  border: "1px solid rgba(255,255,255,0.12)",
                  color: "#e5e7eb",
                }}
                labelFormatter={(y) => `Season ${y}`}
                formatter={(val, key) => {
                  if (key === "roi")
                    return [`${(val * 100).toFixed(1)}%`, "ROI"];
                  if (key === "cumInvested")
                    return [
                      `$${Math.round(val).toLocaleString()}`,
                      "Cum Invested",
                    ];
                  if (key === "value") {
                    return [
                      `$${Math.round(val).toLocaleString()}`,
                      metricMode === "earned" ? "Cum Earned" : "Cum Profit",
                    ];
                  }
                  return [`$${Math.round(val).toLocaleString()}`, key];
                }}
              />

              <Bar yAxisId="left" dataKey="value" barSize={24} stroke="none">
                {ownerSeries.map((d, i) => (
                  <Cell key={`c${i}`} fill={barFill(d.value)} />
                ))}
              </Bar>

              <Line
                yAxisId="right"
                type="monotone"
                dataKey="roi"
                stroke="#8ab4f8"
                strokeWidth={3}
                dot={{ r: 3 }}
                activeDot={{ r: 6, strokeWidth: 2, stroke: "#fff" }}
              />
            </ComposedChart>
          </ResponsiveContainer>
        </div>
      </Card>
      {/* Bottom table */}
      <TableBox>
        <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
          <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
            <th
              className="px-3 py-2 text-left cursor-pointer"
              onClick={() => toggleSort("owner")}
              title="Sort by Member"
            >
              Member {sortBy === "owner" ? (sortDir === -1 ? "↓" : "↑") : ""}
            </th>

            {/* Invested (first) */}
            <th
              className="px-3 py-2 cursor-pointer"
              onClick={() => toggleSort("invested")}
              title="Sort by Invested"
            >
              Invested{" "}
              {sortBy === "invested" ? (sortDir === -1 ? "↓" : "↑") : ""}
            </th>

            {/* Earned (second) */}
            <th
              className="px-3 py-2 cursor-pointer"
              onClick={() => toggleSort("earned")}
              title="Sort by Earned"
            >
              Earned {sortBy === "earned" ? (sortDir === -1 ? "↓" : "↑") : ""}
            </th>

            {/* ROI (third) */}
            <th
              className="px-3 py-2 cursor-pointer"
              onClick={() => toggleSort("roi")}
              title="Sort by ROI"
            >
              ROI {sortBy === "roi" ? (sortDir === -1 ? "↓" : "↑") : ""}
            </th>

            {[1, 2, 3].map((place) => (
              <th
                key={`place-h-${place}`}
                className="px-3 py-2 cursor-pointer"
                onClick={() => toggleSort(`place${place}`)}
                title={`Sort by ${
                  place === 1 ? "1st" : place === 2 ? "2nd" : "3rd"
                }`}
              >
                {place === 1 ? "1st" : place === 2 ? "2nd" : "3rd"}{" "}
                {sortBy === `place${place}` ? (sortDir === -1 ? "↓" : "↑") : ""}
              </th>
            ))}

            {weeklyEnabled && (
              <th
                className="px-3 py-2 cursor-pointer"
                onClick={() => toggleSort("weekly")}
                title="Sort by Weekly payouts"
              >
                Weekly {sortBy === "weekly" ? (sortDir === -1 ? "↓" : "↑") : ""}
              </th>
            )}

            {payoutTiers > 3 &&
              [...Array(payoutTiers - 3)].map((_, idx) => {
                const place = idx + 4;
                return (
                  <th
                    key={`place-h-${place}`}
                    className="px-3 py-2 cursor-pointer"
                    onClick={() => toggleSort(`place${place}`)}
                    title={`Sort by ${place}th`}
                  >
                    {place}
                    {place === 1
                      ? "st"
                      : place === 2
                      ? "nd"
                      : place === 3
                      ? "rd"
                      : "th"}{" "}
                    {sortBy === `place${place}`
                      ? sortDir === -1
                        ? "↓"
                        : "↑"
                      : ""}
                  </th>
                );
              })}
          </tr>
        </thead>
        <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700 [&>tr:nth-child(odd)]:bg-zinc-50 dark:[&>tr:nth-child(odd)]:bg-zinc-900 [&>tr:hover]:bg-zinc-100 dark:[&>tr:hover]:bg-zinc-800">
          {rows.map((r) => (
            <tr key={r.owner} className="text-center">
              <td className="text-left px-3 py-2 font-medium">{r.owner}</td>

              {/* Invested */}
              <td className="px-3 py-2">
                ${Math.round(r.invested).toLocaleString()}
              </td>

              {/* Earned with value-based tone */}
              <td
                className={`px-3 py-2 ${toneByValue(
                  r.earned,
                  earnedMin,
                  earnedMax,
                  true
                )}`}
              >
                ${Math.round(r.earned).toLocaleString()}
              </td>

              {/* ROI with value-based tone */}
              <td
                className={`px-3 py-2 ${toneByValue(
                  r.roi,
                  roiMin,
                  roiMax,
                  true
                )}`}
              >
                {(r.roi * 100).toFixed(1)}%
              </td>

              {[1, 2, 3].map((place) => (
                <td key={`p-${place}`} className="px-3 py-2">
                  ${Math.round(r.byPlace[place] || 0).toLocaleString()}
                </td>
              ))}

              {weeklyEnabled && (
                <td className="px-3 py-2">
                  ${Math.round(r.weekly || 0).toLocaleString()}
                </td>
              )}

              {payoutTiers > 3 &&
                [...Array(payoutTiers - 3)].map((_, idx2) => {
                  const place = 4 + idx2;
                  return (
                    <td key={`p-${place}`} className="px-3 py-2">
                      ${Math.round(r.byPlace[place] || 0).toLocaleString()}
                    </td>
                  );
                })}
            </tr>
          ))}
        </tbody>
      </TableBox>
    </div>
  );
}
/* RecordsTab with scope filter (Regular / Playoffs / All)
   Updated: “Most Highest-Scoring Weeks” uses the same schedule logic as your weekScores()
*/
export function RecordsTab({ league }) {
  if (!league) return null;
  const rawOwners = Array.isArray(league?.owners) ? league.owners : [];
  const hidden = new Set(
    Array.isArray(league?.hiddenManagers) ? league.hiddenManagers : []
  );
  const ownersList = rawOwners.filter((o) => !hidden.has(o));
  const ownersSet = new Set(ownersList);

  // -------- Scope control --------
  const [scope, setScope] = React.useState("regular"); // "regular" | "playoffs" | "all"
  const scopeLabel = {
    regular: "Regular season",
    playoffs: "Playoffs",
    all: "All games",
  }[scope];

  // finished (decided) games only
  const decided = (g) =>
    g &&
    (String(g.res).toUpperCase() === "W" ||
      String(g.res).toUpperCase() === "L");
  const inScope = (g) =>
    scope === "regular"
      ? g.is_playoff !== true
      : scope === "playoffs"
      ? g.is_playoff === true
      : true;

  const finishedGames = (league.games || []).filter(
    (g) => decided(g) && ownersSet.has(g.owner) && ownersSet.has(g.opp)
  );

  const scopeGames = finishedGames.filter(inScope);

  // completed seasons only (has a placement)
  const completedSeasons = new Set(
    (league.seasonsAll || []).filter((yr) =>
      Object.values(league.placementMap || {}).some((m) => Number(m?.[yr]))
    )
  );

  // --- helpers ---
  const fmtWeek = (w) => (w == null || isNaN(Number(w)) ? "?" : String(w));
  const byDesc = (sel) => (a, b) =>
    (sel(b) ?? -Infinity) - (sel(a) ?? -Infinity);
  const byAsc = (sel) => (a, b) => (sel(a) ?? Infinity) - (sel(b) ?? Infinity);

  const pickNum = (...vals) => {
    for (const v of vals) {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
    return null;
  };

  // Build quick map: teamId -> display name / owner
  const teamNameById = React.useMemo(() => {
    const m = {};
    (league.teams || []).forEach((t) => {
      const name =
        t?.owner?.name ||
        t?.ownerName ||
        [t?.location, t?.nickname].filter(Boolean).join(" ") ||
        t?.name ||
        `Team ${t?.id ?? "?"}`;
      if (t?.id != null) m[t.id] = name;
    });
    return m;
  }, [league.teams]);

  // -------- Season aggregates (completed seasons only, in-scope games) --------
  const bySeasonOwner = new Map(); // `${owner}__${season}` -> { pf, pa, wins, games }
  scopeGames.forEach((g) => {
    if (!completedSeasons.has(Number(g.season))) return;
    const k = `${g.owner}__${g.season}`;
    if (!bySeasonOwner.has(k))
      bySeasonOwner.set(k, { pf: 0, pa: 0, wins: 0, games: 0 });
    const s = bySeasonOwner.get(k);
    const pf =
      pickNum(
        g.pf,
        g.points_for,
        g.points,
        g.score,
        g.owner_points,
        g.pts,
        g.fpts
      ) || 0;
    const pa =
      pickNum(
        g.pa,
        g.points_against,
        g.opp_points,
        g.oppPts,
        g.against,
        g.opp_score
      ) || 0;
    s.pf += pf;
    s.pa += pa;
    s.games += 1;
    if (String(g.res).toUpperCase() === "W") s.wins += 1;
  });

  // -------- Weekly records (finished games in scope; require finite week) -----
  const scopeGamesWithWeek = scopeGames.filter((g) =>
    Number.isFinite(Number(g.week))
  );

  const weeklyHigh = { owner: null, val: -Infinity, season: null, week: null };
  const weeklyLow = { owner: null, val: Infinity, season: null, week: null };

  scopeGamesWithWeek.forEach((g) => {
    const pf = pickNum(
      g.pf,
      g.points_for,
      g.points,
      g.score,
      g.owner_points,
      g.pts,
      g.fpts
    );
    if (!Number.isFinite(pf)) return;
    if (pf > weeklyHigh.val)
      Object.assign(weeklyHigh, {
        owner: g.owner,
        val: pf,
        season: g.season,
        week: g.week,
      });
    if (pf < weeklyLow.val)
      Object.assign(weeklyLow, {
        owner: g.owner,
        val: pf,
        season: g.season,
        week: g.week,
      });
  });

  // ====== Most Highest-Scoring Weeks (manager counts) ======
  const topWeeklyWinnersAll = React.useMemo(() => {
    // prefer ESPN schedules (same logic as your weekScores), fallback to league.games
    const seasonsObj =
      league?.seasonsByYear ||
      (typeof window !== "undefined"
        ? window.__FL_SOURCES?.seasonsByYear
        : {}) ||
      {};
    const ownerByTeamByYear =
      league?.ownerByTeamByYear ||
      (typeof window !== "undefined"
        ? window.__sources?.ownerByTeamByYear
        : {}) ||
      {};

    const weeklyMaxByKey = new Map(); // "season__week" -> { max:number, owners:Set<string> }

    const isPlayoff = (m) => {
      const tier = String(
        m?.playoffTierType || m?.playoffTier || ""
      ).toUpperCase();
      const mtype = String(m?.matchupType || "").toUpperCase();
      return (
        (tier && tier !== "NONE") ||
        /PLAYOFF|CHAMP/.test(mtype) ||
        m?.playoffMatchup === true
      );
    };
    const inScopeMatch = (m) =>
      scope === "regular"
        ? !isPlayoff(m)
        : scope === "playoffs"
        ? isPlayoff(m)
        : true;

    const add = (season, week, owner, pts) => {
      if (!Number.isFinite(pts) || !owner || !ownersSet.has(owner)) return;
      const key = `${Number(season)}__${Number(week)}`;
      const rec = weeklyMaxByKey.get(key);
      if (!rec) {
        weeklyMaxByKey.set(key, { max: pts, owners: new Set([owner]) });
      } else if (pts > rec.max) {
        rec.max = pts;
        rec.owners = new Set([owner]);
      } else if (pts === rec.max) {
        rec.owners.add(owner);
      }
    };

    // 1) schedules
    for (const [yearStr, seasonObj] of Object.entries(seasonsObj || {})) {
      const season = Number(seasonObj?.seasonId ?? yearStr);
      const sched = Array.isArray(seasonObj?.schedule)
        ? seasonObj.schedule
        : [];
      const ownerByTeam = ownerByTeamByYear?.[season] || {};
      for (const m of sched) {
        if (!inScopeMatch(m)) continue;
        const week = Number(m?.matchupPeriodId ?? m?.scoringPeriodId ?? 0);
        if (!week) continue;

        const hId =
          m?.home?.teamId ??
          m?.homeTeam?.teamId ??
          m?.teams?.find?.((t) => t.homeAway === "home")?.teamId ??
          null;
        const aId =
          m?.away?.teamId ??
          m?.awayTeam?.teamId ??
          m?.teams?.find?.((t) => t.homeAway === "away")?.teamId ??
          null;
        const hs =
          Number(
            m?.home?.totalPoints ?? m?.homeTeam?.totalPoints ?? m?.home?.score
          ) || 0;
        const as =
          Number(
            m?.away?.totalPoints ?? m?.awayTeam?.totalPoints ?? m?.away?.score
          ) || 0;

        const hOwner = ownerByTeam[hId] || null;
        const aOwner = ownerByTeam[aId] || null;
        const top = Math.max(hs, as);
        if (hOwner && hs === top) add(season, week, hOwner, hs);
        if (aOwner && as === top) add(season, week, aOwner, as);
      }
    }

    // 2) fallback to league.games if no schedule data yielded anything
    if (weeklyMaxByKey.size === 0) {
      const inScopeGame = (g) =>
        scope === "regular"
          ? g.is_playoff !== true
          : scope === "playoffs"
          ? g.is_playoff === true
          : true;

      (league.games || [])
        .filter((g) => inScopeGame(g) && Number.isFinite(Number(g.week)))
        .forEach((g) => {
          const season = Number(g.season);
          const week = Number(g.week);
          const pf = Number(
            g.pf ??
              g.points_for ??
              g.points ??
              g.score ??
              g.owner_points ??
              g.pts ??
              g.fpts
          );
          const pa = Number(
            g.pa ??
              g.points_against ??
              g.opp_points ??
              g.oppPts ??
              g.against ??
              g.opp_score
          );
          if (Number.isFinite(pf)) add(season, week, g.owner, pf);
          if (Number.isFinite(pa)) add(season, week, g.opp, pa);
        });
    }

    // collapse to counts per owner
    const counts = {};
    weeklyMaxByKey.forEach(({ owners }) =>
      owners.forEach((o) => (counts[o] = (counts[o] || 0) + 1))
    );

    return Object.entries(counts)
      .map(([owner, cnt]) => ({ owner, cnt }))
      .sort((a, b) => b.cnt - a.cnt);
  }, [
    league?.seasonsByYear,
    league?.ownerByTeamByYear,
    league?.games,
    scope,
    ownersSet,
  ]);

  // Win streaks (per-owner PER-SEASON; in-scope finished games)
  const longestStreaks = React.useMemo(() => {
    // owner -> season -> sorted games
    const map = new Map();
    scopeGames
      .map((g) => ({
        owner: g.owner,
        season: Number(g.season),
        week: Number(g.week) || 0,
        res: String(g.res).toUpperCase(),
      }))
      .sort((a, b) => a.season - b.season || a.week - b.week)
      .forEach((g) => {
        if (!map.has(g.owner)) map.set(g.owner, new Map());
        const bySeason = map.get(g.owner);
        if (!bySeason.has(g.season)) bySeason.set(g.season, []);
        bySeason.get(g.season).push(g);
      });

    const rows = [];
    for (const [owner, bySeason] of map.entries()) {
      for (const [season, arr] of bySeason.entries()) {
        let cur = 0,
          best = 0,
          bestEndWeek = null,
          streakStart = null,
          bestStartWeek = null;
        arr.forEach((g) => {
          if (g.res === "W") {
            cur = cur + 1;
            if (cur === 1) streakStart = g.week; // new streak
            if (cur > best) {
              best = cur;
              bestEndWeek = g.week;
              bestStartWeek = streakStart;
            }
          } else {
            cur = 0;
            streakStart = null;
          }
        });
        if (best > 0)
          rows.push({
            owner,
            best,
            season,
            startW: bestStartWeek,
            endW: bestEndWeek,
          });
      }
    }
    return rows.sort(byDesc((r) => r.best));
  }, [scopeGames]);

  // Per-season highs/lows (completed seasons only, in-scope)
  let seasonHigh = { owner: null, season: null, val: -Infinity };
  let seasonLow = { owner: null, season: null, val: Infinity };
  let mostWins = { owner: null, season: null, val: -Infinity };
  let leastWins = { owner: null, season: null, val: Infinity };

  for (const [k, v] of bySeasonOwner.entries()) {
    const [owner, season] = k.split("__");
    if (v.pf > seasonHigh.val)
      seasonHigh = { owner, season: Number(season), val: v.pf };
    if (v.pf < seasonLow.val)
      seasonLow = { owner, season: Number(season), val: v.pf };
    if (v.wins > mostWins.val)
      mostWins = { owner, season: Number(season), val: v.wins };
    if (v.wins < leastWins.val)
      leastWins = { owner, season: Number(season), val: v.wins };
  }

  // ---------- Top lists from games ----------
  const topWeeklyHighAll = scopeGamesWithWeek
    .slice()
    .sort(
      byDesc((g) =>
        pickNum(
          g.pf,
          g.points_for,
          g.points,
          g.score,
          g.owner_points,
          g.pts,
          g.fpts
        )
      )
    );
  const topWeeklyLowAll = scopeGamesWithWeek
    .slice()
    .sort(
      byAsc((g) =>
        pickNum(
          g.pf,
          g.points_for,
          g.points,
          g.score,
          g.owner_points,
          g.pts,
          g.fpts
        )
      )
    );

  const seasonRows = Array.from(bySeasonOwner.entries()).map(([k, v]) => {
    const [owner, season] = k.split("__");
    return { owner, season: Number(season), pf: v.pf, wins: v.wins, pa: v.pa };
  });
  const topSeasonPFHighAll = seasonRows.slice().sort(byDesc((r) => r.pf));
  const topSeasonPFLowAll = seasonRows.slice().sort(byAsc((r) => r.pf));
  const topSeasonWinsHighAll = seasonRows.slice().sort(byDesc((r) => r.wins));
  const topSeasonWinsLowAll = seasonRows.slice().sort(byAsc((r) => r.wins));
  const topPunchingBagAll = seasonRows.slice().sort(byDesc((r) => r.pa)); // Highest PA in season

  // Largest Win Differential (in-scope)
  const largestDiffAll = scopeGamesWithWeek
    .map((g) => {
      const pf = pickNum(
        g.pf,
        g.points_for,
        g.points,
        g.score,
        g.owner_points,
        g.pts,
        g.fpts
      );
      const pa = pickNum(
        g.pa,
        g.points_against,
        g.opp_points,
        g.oppPts,
        g.against,
        g.opp_score
      );
      if (!Number.isFinite(pf) || !Number.isFinite(pa)) return null;
      const diff = Math.abs(pf - pa);
      const winner = pf >= pa ? g.owner : g.opp;
      const loser = pf >= pa ? g.opp : g.owner;
      return { winner, loser, diff, season: g.season, week: g.week };
    })
    .filter(Boolean)
    .sort(byDesc((r) => r.diff));

  const highestScoringPlayersAll = React.useMemo(() => {
    const out = [];
    const seasonsObj =
      league?.seasonsByYear ||
      (typeof window !== "undefined"
        ? window.__FL_SOURCES?.seasonsByYear
        : {}) ||
      {};
    for (const [yearStr, seasonObj] of Object.entries(seasonsObj || {})) {
      const year = Number(seasonObj?.seasonId ?? yearStr);
      const rbtbw =
        seasonObj?.rostersByTeamByWeek || seasonObj?.rostersByTeamWeek || {};
      for (const [teamIdStr, byWeek] of Object.entries(rbtbw || {})) {
        const teamId = Number(teamIdStr);
        const manager =
          ownerName(year, teamId) || teamNameById[teamId] || `Team ${teamId}`;
        for (const [weekStr, roster] of Object.entries(byWeek || {})) {
          const week = Number(weekStr);
          (roster || []).forEach((p) => {
            const pts = Number(p?.pts);
            if (!Number.isFinite(pts)) return;
            const name = p?.name || p?.playerName || "Unknown";
            out.push({ owner: manager, player: name, pts, season: year, week });
          });
        }
      }
    }
    return out.sort(byDesc((r) => r.pts));
  }, [teamNameById, league?.seasonsByYear]);

  // Longest win streak top list (already computed)
  const topWinStreaksAll = longestStreaks;

  // ---------- Championships / Sackos / Playoff Appearances ----------
  const champs = {},
    sackos = {},
    poApps = {};
  ownersList.forEach((o) => {
    champs[o] = 0;
    sackos[o] = 0;
    poApps[o] = 0;
  });

  const placementsBySeason = new Map(); // yr -> [{owner, place}]
  for (const [owner, byYear] of Object.entries(league.placementMap || {})) {
    if (!ownersSet.has(owner)) continue; // guard
    Object.entries(byYear || {}).forEach(([yrStr, place]) => {
      const yr = Number(yrStr);
      const p = Number(place);
      if (!Number.isFinite(p) || p <= 0) return;
      poApps[owner] = (poApps[owner] || 0) + 1; // playoff appearance: any positive place
      if (!placementsBySeason.has(yr)) placementsBySeason.set(yr, []);
      placementsBySeason.get(yr).push({ owner, place: p });
    });
  }
  placementsBySeason.forEach((arr) => {
    if (!arr.length) return;
    const maxPlace = Math.max(...arr.map((r) => r.place));
    arr.forEach((r) => {
      if (r.place === 1) champs[r.owner] = (champs[r.owner] || 0) + 1;
      if (r.place === maxPlace) sackos[r.owner] = (sackos[r.owner] || 0) + 1;
    });
  });

  const champArr = Object.entries(champs).sort((a, b) => b[1] - a[1]);
  const sackoArr = Object.entries(sackos).sort((a, b) => b[1] - a[1]);
  const poArr = Object.entries(poApps).sort((a, b) => b[1] - a[1]);

  const maxChamp = champArr.length ? champArr[0][1] : 0;
  const mostChamps = champArr.filter(([, c]) => c === maxChamp && c > 0);

  // ---------- Shared “Top block” renderer ----------
  const Medal = ({ place }) =>
    place === 1 ? "🥇" : place === 2 ? "🥈" : place === 3 ? "🥉" : null;

  // sizes small so 5 lines fit
  const sizeForIdx = (i) =>
    i === 0
      ? "text-sm md:text-base"
      : i === 1
      ? "text-[13px] md:text-sm"
      : "text-xs md:text-[13px]";

  // “see more” modal state
  const [moreKey, setMoreKey] = React.useState(null);
  const closeMore = () => setMoreKey(null);

  // generic card section (1 big line + rows 2–5 + modal)
  const TopSection = ({ title, bigLine, listAll, renderRow, moreKeyName }) => {
    const top5 = listAll.slice(0, 5);
    const tail2to5 = top5.slice(1);

    return (
      <Card title={title}>
        {bigLine ? (
          <div className="text-lg md:text-xl font-semibold text-white/95 leading-snug">
            {bigLine}
          </div>
        ) : (
          <div>—</div>
        )}

        {tail2to5.length > 0 && (
          <ul className="mt-2 space-y-1.5">
            {tail2to5.map((item, i) => {
              const overallPlace = i + 2;
              return (
                <li
                  key={i}
                  className={`flex items-baseline gap-2 ${sizeForIdx(i)}`}
                >
                  <span className="w-5 shrink-0 text-sm md:text-base">
                    {overallPlace <= 3 ? (
                      <Medal place={overallPlace} />
                    ) : (
                      <span className="opacity-70">{overallPlace}.</span>
                    )}
                  </span>
                  <div className="text-zinc-300">
                    {renderRow(item, overallPlace)}
                  </div>
                </li>
              );
            })}
          </ul>
        )}

        {listAll.length > 5 && (
          <button
            className="btn btn-sm mt-3"
            onClick={() => setMoreKey(moreKeyName)}
          >
            + See more
          </button>
        )}
      </Card>
    );
  };

  // ---------- Modal payloads ----------
  const modalMap = {
    weeklyHigh: {
      title: "Highest Points (week) — more",
      items: topWeeklyHighAll.slice(5, 25),
      render: (g, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {g.owner} —{" "}
            {Math.round(
              pickNum(
                g.pf,
                g.points_for,
                g.points,
                g.score,
                g.owner_points,
                g.pts,
                g.fpts
              )
            )}{" "}
            (S{g.season} W{fmtWeek(g.week)})
          </span>
        </div>
      ),
    },

    weeklyWinners: {
      title: "Most Highest-Scoring Weeks — more",
      items: topWeeklyWinnersAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {r.cnt} {r.cnt === 1 ? "week" : "weeks"}
          </span>
        </div>
      ),
    },

    weeklyLow: {
      title: "Lowest Points (week) — more",
      items: topWeeklyLowAll.slice(5, 25),
      render: (g, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {g.owner} —{" "}
            {Math.round(
              pickNum(
                g.pf,
                g.points_for,
                g.points,
                g.score,
                g.owner_points,
                g.pts,
                g.fpts
              )
            )}{" "}
            (S{g.season} W{fmtWeek(g.week)})
          </span>
        </div>
      ),
    },
    seasonPFHigh: {
      title: "Highest Points (season) — more",
      items: topSeasonPFHighAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {Math.round(r.pf)} (S{r.season})
          </span>
        </div>
      ),
    },
    seasonPFLow: {
      title: "Lowest Points (season) — more",
      items: topSeasonPFLowAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {Math.round(r.pf)} (S{r.season})
          </span>
        </div>
      ),
    },
    winsHigh: {
      title: "Most Wins (season) — more",
      items: topSeasonWinsHighAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {r.wins} (S{r.season})
          </span>
        </div>
      ),
    },
    winsLow: {
      title: "Least Wins (season) — more",
      items: topSeasonWinsLowAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {r.wins} (S{r.season})
          </span>
        </div>
      ),
    },
    streaks: {
      title: "Longest Win Streak — more",
      items: longestStreaks.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {r.best} (S{r.season} W{fmtWeek(r.startW)} → W
            {fmtWeek(r.endW)})
          </span>
        </div>
      ),
    },
    players: {
      title: "Highest Scoring Player — more",
      items: highestScoringPlayersAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.team} — {r.player} — {Math.round(r.pts)} (S{r.season} W
            {fmtWeek(r.week)})
          </span>
        </div>
      ),
    },
    diff: {
      title: "Largest Win Differential — more",
      items: largestDiffAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.winner} over {r.loser} — {Math.round(r.diff)} (S{r.season} W
            {fmtWeek(r.week)})
          </span>
        </div>
      ),
    },
    pa: {
      title: "League Punching Bag — more (Highest Points Against, season)",
      items: topPunchingBagAll.slice(5, 25),
      render: (r, idx) => (
        <div className="flex gap-2">
          <span className="opacity-60">{idx}.</span>
          <span>
            {r.owner} — {Math.round(r.pa)} against (S{r.season})
          </span>
        </div>
      ),
    },
    poapps: {
      title: "Most Playoff Appearances — more",
      items: poArr.slice(5, 25),
      render: (r, idx) => {
        const [owner, cnt] = r;
        return (
          <div className="flex gap-2">
            <span className="opacity-60">{idx}.</span>
            <span>
              {owner} — {cnt}
            </span>
          </div>
        );
      },
    },
  };

  const activeModal = moreKey ? modalMap[moreKey] : null;

  // ---------- UI ----------
  return (
    <div className="grid md:grid-cols-2 gap-4 text-sm">
      {/* Scope picker */}
      <div className="md:col-span-2">
        <Card
          title="Records scope"
          right={
            <div className="flex items-center gap-2">
              <span className="text-xs text-zinc-500">Show:</span>
              <select
                className="px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
                value={scope}
                onChange={(e) => setScope(e.target.value)}
              >
                <option value="regular">Regular season</option>
                <option value="playoffs">Playoffs</option>
                <option value="all">All games</option>
              </select>
            </div>
          }
        >
          <div className="text-xs text-zinc-500">
            Calculations use finished games only. Season totals use completed
            seasons only. Current scope:{" "}
            <span className="font-medium">{scopeLabel}</span>.
          </div>
        </Card>
      </div>

      {/* Highest Points (week) */}
      <TopSection
        title="Highest Points (week)"
        bigLine={
          weeklyHigh.owner ? (
            <span>
              <span className="mr-1">🥇</span>
              {weeklyHigh.owner} — {Math.round(weeklyHigh.val)} (S
              {weeklyHigh.season} W{fmtWeek(weeklyHigh.week)})
            </span>
          ) : null
        }
        listAll={topWeeklyHighAll}
        renderRow={(g) => (
          <span>
            {g.owner} —{" "}
            {Math.round(
              pickNum(
                g.pf,
                g.points_for,
                g.points,
                g.score,
                g.owner_points,
                g.pts,
                g.fpts
              )
            )}{" "}
            (S{g.season} W{fmtWeek(g.week)})
          </span>
        )}
        moreKeyName="weeklyHigh"
      />

      {/* Most Highest-Scoring Weeks (manager who topped the week most often) */}
      <TopSection
        title="Most Highest-Scoring Weeks"
        bigLine={
          topWeeklyWinnersAll.length ? (
            <span>
              <span className="mr-1">🥇</span>
              {topWeeklyWinnersAll[0].owner} — {topWeeklyWinnersAll[0].cnt}{" "}
              {topWeeklyWinnersAll[0].cnt === 1 ? "week" : "weeks"}
            </span>
          ) : null
        }
        listAll={topWeeklyWinnersAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {r.cnt} {r.cnt === 1 ? "week" : "weeks"}
          </span>
        )}
        moreKeyName="weeklyWinners"
      />

      {/* Lowest Points (week) */}
      <TopSection
        title="Lowest Points (week)"
        bigLine={
          weeklyLow.owner ? (
            <span>
              <span className="mr-1">🥇</span>
              {weeklyLow.owner} — {Math.round(weeklyLow.val)} (S
              {weeklyLow.season} W{fmtWeek(weeklyLow.week)})
            </span>
          ) : null
        }
        listAll={topWeeklyLowAll}
        renderRow={(g) => (
          <span>
            {g.owner} —{" "}
            {Math.round(
              pickNum(
                g.pf,
                g.points_for,
                g.points,
                g.score,
                g.owner_points,
                g.pts,
                g.fpts
              )
            )}{" "}
            (S{g.season} W{fmtWeek(g.week)})
          </span>
        )}
        moreKeyName="weeklyLow"
      />

      {/* Highest Points (season) */}
      <TopSection
        title="Highest Points (season)"
        bigLine={
          seasonHigh.owner ? (
            <span>
              <span className="mr-1">🥇</span>
              {seasonHigh.owner} — {Math.round(seasonHigh.val)} (S
              {seasonHigh.season})
            </span>
          ) : null
        }
        listAll={topSeasonPFHighAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {Math.round(r.pf)} (S{r.season})
          </span>
        )}
        moreKeyName="seasonPFHigh"
      />

      {/* Lowest Points (season) */}
      <TopSection
        title="Lowest Points (season)"
        bigLine={
          seasonLow.owner ? (
            <span>
              <span className="mr-1">🥇</span>
              {seasonLow.owner} — {Math.round(seasonLow.val)} (S
              {seasonLow.season})
            </span>
          ) : null
        }
        listAll={topSeasonPFLowAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {Math.round(r.pf)} (S{r.season})
          </span>
        )}
        moreKeyName="seasonPFLow"
      />

      {/* Most Wins (season) */}
      <TopSection
        title="Most Wins (season)"
        bigLine={
          mostWins.owner ? (
            <span>
              <span className="mr-1">🥇</span>
              {mostWins.owner} — {mostWins.val} (S{mostWins.season})
            </span>
          ) : null
        }
        listAll={topSeasonWinsHighAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {r.wins} (S{r.season})
          </span>
        )}
        moreKeyName="winsHigh"
      />

      {/* Least Wins (season) */}
      <TopSection
        title="Least Wins (season)"
        bigLine={
          leastWins.owner ? (
            <span>
              <span className="mr-1">🥇</span>
              {leastWins.owner} — {leastWins.val} (S{leastWins.season})
            </span>
          ) : null
        }
        listAll={topSeasonWinsLowAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {r.wins} (S{r.season})
          </span>
        )}
        moreKeyName="winsLow"
      />

      {/* Longest Win Streak (per season) */}
      <TopSection
        title="Longest Win Streak"
        bigLine={
          longestStreaks.length ? (
            <span>
              <span className="mr-1">🥇</span>
              {longestStreaks[0].owner} — {longestStreaks[0].best} (S
              {longestStreaks[0].season} W{fmtWeek(longestStreaks[0].startW)} →
              W{fmtWeek(longestStreaks[0].endW)})
            </span>
          ) : null
        }
        listAll={longestStreaks}
        renderRow={(r) => (
          <span>
            {r.owner} — {r.best} (S{r.season} W{fmtWeek(r.startW)} → W
            {fmtWeek(r.endW)})
          </span>
        )}
        moreKeyName="streaks"
      />

      {/* Highest Scoring Player */}
      <TopSection
        title="Highest Scoring Player"
        bigLine={
          highestScoringPlayersAll.length ? (
            <span>
              <span className="mr-1">🥇</span>
              {highestScoringPlayersAll[0].owner} —{" "}
              {highestScoringPlayersAll[0].player} —{" "}
              {Math.round(highestScoringPlayersAll[0].pts)} (S
              {highestScoringPlayersAll[0].season} W
              {fmtWeek(highestScoringPlayersAll[0].week)})
            </span>
          ) : null
        }
        listAll={highestScoringPlayersAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {r.player} — {Math.round(r.pts)} (S{r.season} W
            {fmtWeek(r.week)})
          </span>
        )}
        moreKeyName="players"
      />

      {/* Largest Win Differential */}
      <TopSection
        title="Largest Win Differential"
        bigLine={
          largestDiffAll.length ? (
            <span>
              <span className="mr-1">🥇</span>
              {largestDiffAll[0].winner} over {largestDiffAll[0].loser} —{" "}
              {Math.round(largestDiffAll[0].diff)} (S{largestDiffAll[0].season}{" "}
              W{fmtWeek(largestDiffAll[0].week)})
            </span>
          ) : null
        }
        listAll={largestDiffAll}
        renderRow={(r) => (
          <span>
            {r.winner} over {r.loser} — {Math.round(r.diff)} (S{r.season} W
            {fmtWeek(r.week)})
          </span>
        )}
        moreKeyName="diff"
      />

      {/* Highest Points Against (season) */}
      <TopSection
        title="League Punching Bag — Highest Points Against (season)"
        bigLine={
          topPunchingBagAll.length ? (
            <span>
              <span className="mr-1">🥇</span>
              {topPunchingBagAll[0].owner} —{" "}
              {Math.round(topPunchingBagAll[0].pa)} against (S
              {topPunchingBagAll[0].season})
            </span>
          ) : null
        }
        listAll={topPunchingBagAll}
        renderRow={(r) => (
          <span>
            {r.owner} — {Math.round(r.pa)} against (S{r.season})
          </span>
        )}
        moreKeyName="pa"
      />

      {/* Most Championships (all tied shown as 🥇) */}
      <Card title="Most Championships">
        {mostChamps.length ? (
          <div className="space-y-1">
            {mostChamps.slice(0, 5).map(([o, c]) => (
              <div key={`mc-${o}`} className="text-sm md:text-base font-medium">
                🥇 {o} — {c}
              </div>
            ))}
          </div>
        ) : (
          <div>—</div>
        )}
      </Card>

      {/* Most Playoff Appearances */}
      <TopSection
        title="Most Playoff Appearances"
        bigLine={
          poArr.length ? (
            <span>
              <span className="mr-1">🥇</span>
              {poArr[0][0]} — {poArr[0][1]}
            </span>
          ) : null
        }
        listAll={poArr}
        renderRow={(r) => {
          const [o, c] = r;
          return (
            <span>
              {o} — {c}
            </span>
          );
        }}
        moreKeyName="poapps"
      />

      {/* Most Sackos */}
      <Card title="Most Sackos">
        {sackoArr.length ? (
          <div className="space-y-1">
            {sackoArr.slice(0, 5).map(([o, c], i) => (
              <div
                key={`ms-${o}`}
                className={`${
                  i === 0 ? "text-sm md:text-base font-medium" : ""
                }`}
              >
                {i === 0 ? "🥇 " : i === 1 ? "🥈 " : i === 2 ? "🥉 " : ""}
                {o} — {c}
              </div>
            ))}
          </div>
        ) : (
          <div>—</div>
        )}
      </Card>

      {/* footnote */}
      <Card>
        <div className="text-xs text-zinc-500">
          Transactions/trades require extra data from ESPN or your CSV. If your
          CSV includes per-season columns named <code>transactions</code> or{" "}
          <code>trades</code>, the Trades / Transactions tab will show them.
          Include <code>trade_partner</code> (or traded_with / partner /
          trade_with) to get most common pairings.
        </div>
      </Card>

      {/* See-more modal */}
      {activeModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center">
          <div className="absolute inset-0 bg-black/50" onClick={closeMore} />
          <div className="relative w-[min(880px,92vw)] max-h-[85vh] overflow-hidden rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-xl">
            <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 sticky top-0 bg-white dark:bg-zinc-900">
              <div className="text-base font-semibold">{activeModal.title}</div>
              <button className="btn btn-xs" onClick={closeMore}>
                Close
              </button>
            </div>
            <div
              className="p-3 overflow-y-auto"
              style={{ maxHeight: "calc(85vh - 48px)" }}
            >
              {activeModal.items.length ? (
                <ol className="space-y-1">
                  {activeModal.items.map((item, i) => (
                    <li key={i} className="text-sm text-zinc-200">
                      {activeModal.render(item, i + 6 /* numbers start at 6 */)}
                    </li>
                  ))}
                </ol>
              ) : (
                <div className="text-sm opacity-70 px-2 py-3">
                  No more results.
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

//------------------------trade tab, TradeTab, Tradetab ----------------
// Helper: load league-specific merge map (Combine Managers)
function getMergeMap(league) {
  try {
    const lid = league?.meta?.leagueId || league?.leagueId || null;
    if (!lid) return {};
    const key = `fl_merge_map::${lid}`;
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

export function TradesTab({
  league,
  rawRows = [],
  espnRostersByYear = {},
  espnOwnerByTeamByYear = {},
  espnTeamNamesByOwner = {}, // (kept but unused)
  espnOwnerFullByTeamByYear = {}, // (kept but unused)
  espnRosterAcqByYear: rosterAcqByYearProp = {},
  selectedLeague,
  activityBySeason: activityFromProp = {},
  hiddenManagers, // ✅ optional: explicit list; falls back to league.hiddenManagers
}) {
  const fmt1 = (n) => Number(n || 0).toFixed(1);
  const fmt2 = (n) => Number(n || 0).toFixed(2);
  // Build an expanded merge map so aliases like "Jacob966788" also match the pretty member name ("Jacob Teitelbaum")
  const expandedMergeMap = React.useMemo(() => {
    const out = new Map();
    const norm = (s) =>
      String(s || "")
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .trim();

    try {
      // 1) Base entries from your league-specific localStorage map
      const mm = getMergeMap(league) || {};
      for (const [alias, canonical] of Object.entries(mm)) {
        out.set(norm(alias), canonical);
      }

      // 2) If any alias is actually an ESPN "handle"/displayName, add that member's pretty name as an alias too
      const payload = JSON.parse(window.name || "{}");
      const seasons = [
        ...(Array.isArray(payload?.seasons) ? payload.seasons : []),
        ...(Array.isArray(payload?.legacySeasonsLite)
          ? payload.legacySeasonsLite
          : []),
      ];

      // Build a set of (handle -> prettyName) for all seasons we have
      const handleToPretty = new Map();
      for (const s of seasons) {
        (s?.members || []).forEach((m) => {
          const handle = String(m?.displayName || "").trim(); // may be "Jacob966788" or already a name
          const pretty =
            [m?.firstName || "", m?.lastName || ""]
              .filter(Boolean)
              .join(" ")
              .trim() || handle;
          if (handle) handleToPretty.set(handle.toLowerCase(), pretty);
        });
      }

      // For each saved alias, if it equals some member handle, also map that member's pretty name to the same canonical
      for (const [alias, canonical] of Object.entries(mm)) {
        const pretty = handleToPretty.get(String(alias).toLowerCase());
        if (pretty) {
          out.set(norm(pretty), canonical); // e.g., norm("Jacob Teitelbaum") → "Jake Teitelbaum"
        }
      }
    } catch (e) {
      console.warn("expandedMergeMap build failed", e);
    }

    return out;
  }, [league]);

  // Canonicalize owner names; honor the merge map if present
  // Canonicalize owner names; honor the merge map if present
  // Canonicalize owner names; honor expanded merge map (aliases + pretty names)
  const canonOwner = React.useCallback(
    (raw) => {
      const name = String(raw || "").trim();
      if (!name) return name;

      const norm = name
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .trim();

      // 1) Try expanded map (covers both saved alias AND that alias's pretty name)
      const hit = expandedMergeMap.get(norm);
      if (hit) return hit;

      // 2) Fallback: return original
      return name;
    },
    [expandedMergeMap]
  );

  // ✅ canonicalized hidden set (league prop wins, else explicit prop)
  const hiddenSet = React.useMemo(() => {
    const list = Array.isArray(league?.hiddenManagers)
      ? league.hiddenManagers
      : Array.isArray(hiddenManagers)
      ? hiddenManagers
      : [];
    return new Set(list.map((n) => canonOwner(n)));
  }, [league?.hiddenManagers, hiddenManagers, canonOwner]);

  const rosterAcqByYear = React.useMemo(
    () => rosterAcqByYearProp || {},
    [rosterAcqByYearProp]
  );

  // ---------------- Owner name normalization (prevents duplicated rows) ----------------
  const normName = (s) =>
    String(s || "")
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, "")
      .replace(/\s+/g, " ")
      .trim();

  const leagueOwners = React.useMemo(() => {
    const out = new Set();
    try {
      const payload = JSON.parse(window.name || "{}");
      const map = payload?.ownerByTeamByYear || {};
      Object.values(map).forEach((byTeam) => {
        Object.values(byTeam || {}).forEach((owner) => {
          const o = canonOwner(owner);
          if (o && !hiddenSet.has(o)) out.add(o);
        });
      });
    } catch {}
    return Array.from(out).sort((a, b) => a.localeCompare(b));
  }, [hiddenSet, canonOwner]);

  // Map normalized → canonical (from leagueOwners)
  const canonByNorm = React.useMemo(() => {
    const m = new Map();
    leagueOwners.forEach((o) => m.set(normName(o), o));
    return m;
  }, [leagueOwners]);

  const activityFromWindow = React.useMemo(() => {
    // shape: { [year]: { [Owner Name]: { acquisitions,drops,trades,moveToActive,ir } } }
    const bySeason = {};
    try {
      const payload = JSON.parse(window.name || "{}");
      const seasons = [
        ...(Array.isArray(payload?.seasons) ? payload.seasons : []),
        ...(Array.isArray(payload?.legacySeasonsLite)
          ? payload.legacySeasonsLite
          : []),
      ];

      for (const s of seasons) {
        const yr = Number(s?.seasonId);
        if (!Number.isFinite(yr)) continue;

        // memberId → best display name (prefer First Last over handle)
        const memberName = {};
        (s?.members || []).forEach((m) => {
          const dn = m?.displayName || "";
          const fn = m?.firstName || "";
          const ln = m?.lastName || "";
          const real = [fn, ln].filter(Boolean).join(" ").trim();
          const best = real || dn || "Unknown";
          if (m?.id != null) memberName[m.id] = best;
        });

        const seasonMap = bySeason[yr] || (bySeason[yr] = {});
        (s?.teams || []).forEach((t) => {
          // team can be t.id or t.teamId; owner can be t.primaryOwner or t.owners[0]
          const ownerId =
            t?.primaryOwner ?? (Array.isArray(t?.owners) ? t.owners[0] : null);
          let owner =
            ownerId != null
              ? String(memberName[ownerId] || "Unknown")
              : "Unknown";
          owner = canonOwner(owner); // ✅ collapse aliases immediately

          const tx = t?.transactionCounter || {};
          const prev = seasonMap[owner] || {
            acquisitions: 0,
            drops: 0,
            trades: 0,
            moveToActive: 0,
            ir: 0,
          };
          seasonMap[owner] = {
            acquisitions: prev.acquisitions + Number(tx.acquisitions || 0),
            drops: prev.drops + Number(tx.drops || 0),
            trades: prev.trades + Number(tx.trades || 0),
            moveToActive: prev.moveToActive + Number(tx.moveToActive || 0),
            ir: prev.ir + Number(tx.moveToIR || 0),
          };
        });
      }
    } catch {}
    return bySeason;
  }, []);

  // Prefer explicit prop if present; else use window.name harvest
  // Prefer explicit prop if present; else use window.name harvest
  const activityBySeasonRaw = activityFromWindow;

  // ✅ Re-key to canonical and accumulate (protects against any stray raw names)
  // Names coming from ownerByTeamByYear are already correct.
  const activityBySeason = activityBySeasonRaw;

  const activityBySeasonCanon = React.useMemo(() => {
    // Ensure we don’t accidentally show hidden owners
    const out = {};
    Object.entries(activityBySeason || {}).forEach(([yrStr, byOwner]) => {
      const y = Number(yrStr);
      out[y] = {};
      Object.entries(byOwner || {}).forEach(([owner, stats]) => {
        const o = canonOwner(owner);
        if (!hiddenSet.has(o)) out[y][o] = { ...stats };
      });
    });
    return out;
  }, [activityBySeason, hiddenSet, canonOwner]);

  const seasonsForTable = React.useMemo(() => {
    const s = new Set();
    Object.keys(activityBySeasonCanon || {}).forEach((yr) => s.add(Number(yr)));
    return Array.from(s).sort((a, b) => a - b);
  }, [activityBySeasonCanon]);

  const ownersUnionTx = React.useMemo(() => {
    const set = new Set();
    Object.values(activityBySeasonCanon || {}).forEach((byOwner) => {
      Object.keys(byOwner || {}).forEach((o) => {
        const c = canonOwner(o);
        if (!hiddenSet.has(c)) set.add(c);
      });
    });
    return Array.from(set).sort((a, b) => a.localeCompare(b));
  }, [activityBySeasonCanon, hiddenSet, canonOwner]);

  // ESPN defaultPositionId → position code
  const POS_LITE = { 1: "QB", 2: "RB", 3: "WR", 4: "TE", 5: "K", 16: "DST" };
  const posFromDefaultId = (n) =>
    Number.isFinite(Number(n)) ? POS_LITE[Number(n)] || "" : "";

  /** Pull position from espnRosterAcqByYear (season/teamId/playerId).
   *  If team-specific record isn’t present, scan any team in that season. */
  const getPosFromAcq = React.useCallback(
    (season, teamId, playerId) => {
      const yr = Number(season);
      const tid = Number(teamId);
      const pid = Number(playerId);
      if (!Number.isFinite(yr) || !Number.isFinite(pid)) return "";

      const rec =
        rosterAcqByYear?.[yr]?.[tid]?.[pid] ??
        (() => {
          const byTeam = rosterAcqByYear?.[yr] || {};
          for (const t of Object.values(byTeam)) {
            if (t && t[pid]) return t[pid];
          }
          return null;
        })();

      const posId =
        (rec && typeof rec === "object" ? rec.defaultPositionId : null) ?? null;
      return posFromDefaultId(posId);
    },
    [rosterAcqByYear]
  );

  // filters
  const [posFilter, setPosFilter] = React.useState("all");
  function includeByPos(posCode, filter) {
    if (!filter || filter === "all") return true;
    if (filter === "WR/RB/TE") return ["WR", "RB", "TE"].includes(posCode);
    if (filter === "WR/RB") return ["WR", "RB"].includes(posCode);
    return posCode === filter;
  }
  const [yearFilter, setYearFilter] = React.useState("all");
  const [rankMetric, setRankMetric] = React.useState("total");
  const [scopeFilter, setScopeFilter] = React.useState("regular");
  const [minWeeks, setMinWeeks] = React.useState(3);

  // Index which weeks were playoffs vs regular for each season
  const weekScopesBySeason = React.useMemo(() => {
    const map = {};
    (rawRows || []).forEach((r) => {
      const y = Number(r?.season);
      const w = Number(r?.week);
      if (!y || !w) return;
      const isPO = r?.is_playoff === true;
      if (!map[y]) map[y] = { regular: new Set(), playoffs: new Set() };
      (isPO ? map[y].playoffs : map[y].regular).add(w);
    });
    return map;
  }, [rawRows]);

  function includeWeekForScope(year, week, scopeWanted) {
    const s = weekScopesBySeason[Number(year)];
    if (!s || scopeWanted === "all") return true;
    if (scopeWanted === "playoffs") return s.playoffs.has(Number(week));
    if (scopeWanted === "regular") return s.regular.has(Number(week));
    return true;
  }

  // --- NEW: season-only exclusion sets (by id AND by name) ----------------------------------
  const excludedBySeasonId = React.useMemo(() => {
    const out = {};
    const mark = (season, pid) => {
      const s = Number(season);
      const id = Number(pid);
      if (!Number.isFinite(s) || !Number.isFinite(id)) return;
      if (!out[s]) out[s] = new Set();
      out[s].add(id);
    };
    const normAcq = (v) =>
      String(v || "")
        .trim()
        .toUpperCase();

    if (Array.isArray(rosterAcqByYear)) {
      for (const row of rosterAcqByYear) {
        const acq = normAcq(row?.acquisitionType || row?.type);
        if (acq === "TRADE" || acq === "DRAFT") {
          mark(row?.season, row?.playerId ?? row?.pid ?? row?.player_id);
        }
      }
    } else {
      for (const [seasonStr, teams] of Object.entries(rosterAcqByYear || {})) {
        for (const players of Object.values(teams || {})) {
          for (const [pidStr, rec] of Object.entries(players || {})) {
            const raw =
              typeof rec === "string"
                ? rec
                : rec && typeof rec === "object"
                ? rec.acquisitionType || rec.type || null
                : null;
            const tag = normAcq(raw);
            if (tag === "TRADE" || tag === "DRAFT") mark(seasonStr, pidStr);
          }
        }
      }
    }
    return out;
  }, [rosterAcqByYear]);

  const excludedBySeasonName = React.useMemo(() => {
    const out = {};
    const mark = (season, name) => {
      const s = Number(season);
      const nm = normName(name);
      if (!Number.isFinite(s) || !nm) return;
      if (!out[s]) out[s] = new Set();
      out[s].add(nm);
    };
    const normAcq = (v) =>
      String(v || "")
        .trim()
        .toUpperCase();

    if (Array.isArray(rosterAcqByYear)) {
      for (const row of rosterAcqByYear) {
        const acq = normAcq(row?.acquisitionType || row?.type);
        if (acq === "TRADE" || acq === "DRAFT") {
          mark(row?.season, row?.name ?? row?.playerName ?? row?.player);
        }
      }
    } else {
      for (const [seasonStr, teams] of Object.entries(rosterAcqByYear || {})) {
        for (const players of Object.values(teams || {})) {
          for (const [, rec] of Object.entries(players || {})) {
            const raw =
              typeof rec === "string"
                ? rec
                : rec && typeof rec === "object"
                ? rec.acquisitionType || rec.type || null
                : null;
            const tag = normAcq(raw);
            const nm =
              (rec &&
                typeof rec === "object" &&
                (rec.name || rec.playerName || rec.player)) ||
              null;
            if ((tag === "TRADE" || tag === "DRAFT") && nm) mark(seasonStr, nm);
          }
        }
      }
    }
    return out;
  }, [rosterAcqByYear]);

  const isExcluded = React.useCallback(
    (season, playerId, playerName) => {
      const s = Number(season);
      if (excludedBySeasonId?.[s]?.has(Number(playerId))) return true;
      const nm = normName(playerName);
      if (nm && excludedBySeasonName?.[s]?.has(nm)) return true;
      return false;
    },
    [excludedBySeasonId, excludedBySeasonName]
  );

  // ---- playoff scope helper ----
  const playoffWeeksBySeason = React.useMemo(() => {
    const out = {};
    try {
      const payload = JSON.parse(window.name || "{}");
      const allSeasons = [
        ...(Array.isArray(payload?.seasons) ? payload.seasons : []),
        ...(Array.isArray(payload?.legacySeasonsLite)
          ? payload.legacySeasonsLite
          : []),
      ];
      for (const s of allSeasons) {
        const season = Number(s?.seasonId);
        const set = new Set();
        (s?.schedule || []).forEach((g) => {
          const wk = Number(g?.matchupPeriodId);
          const tier = String(g?.playoffTierType || "").toUpperCase();
          const mtype = String(g?.matchupType || "").toUpperCase();
          const isPO =
            g?.playoffMatchup === true ||
            (tier && tier !== "NONE") ||
            /PLAYOFF|CHAMP/.test(mtype);
          if (isPO && Number.isFinite(wk)) set.add(wk);
        });
        if (set.size) out[season] = set;
      }
    } catch {}
    return out;
  }, []);

  const weekScope = React.useCallback(
    (season, week) => {
      const set = playoffWeeksBySeason[Number(season)];
      if (!set) return "regular";
      return set.has(Number(week)) ? "playoffs" : "regular";
    },
    [playoffWeeksBySeason]
  );

  // ---- build windows; exclude players tagged Trade/Draft for that season ----
  const acquisitionsAll = React.useMemo(() => {
    const out = [];
    const seasons = Object.keys(espnRostersByYear)
      .map(Number)
      .filter((y) => y >= 2019)
      .sort((a, b) => a - b);

    for (const season of seasons) {
      const byTeam = espnRostersByYear[season] || {};

      for (const [teamIdStr, wkMapRaw] of Object.entries(byTeam)) {
        const teamId = Number(teamIdStr);
        const wkMap = wkMapRaw || {};
        const weeks = Object.keys(wkMap)
          .map(Number)
          .sort((a, b) => a - b);

        const open = new Map(); // pid -> { startWeek, totalPts, weeks, name }
        const sumPtsForPid = (arr, pid) =>
          (arr || [])
            .filter((e) => Number(e?.pid) === Number(pid))
            .reduce((s, e) => s + (Number(e?.pts) || 0), 0);

        let prevSet = new Set();

        for (const w of weeks) {
          const entries = wkMap[w] || [];
          const curSet = new Set(
            entries.map((e) => Number(e?.pid)).filter(Boolean)
          );

          // open new windows
          for (const pid of curSet) {
            if (!prevSet.has(pid)) {
              const ent = entries.find((e) => Number(e?.pid) === pid);
              const name = ent?.name || `Player ${pid}`;

              let pos = getPosFromAcq(season, teamId, pid);
              if (!pos) {
                const rawPosId =
                  ent?.defaultPositionId ??
                  ent?.posId ??
                  ent?.player?.defaultPositionId ??
                  ent?.playerPoolEntry?.player?.defaultPositionId ??
                  ent?.player?.defaultPosition ??
                  null;
                pos = posFromDefaultId(rawPosId);
                if (!pos) {
                  const s =
                    ent?.pos ||
                    ent?.position ||
                    ent?.slot ||
                    ent?.player?.position ||
                    "";
                  const t = String(s || "")
                    .toUpperCase()
                    .replace(/[^A-Z]/g, "");
                  if (["QB", "RB", "WR", "TE", "K", "DST"].includes(t)) pos = t;
                }
              }

              open.set(pid, { startWeek: w, totalPts: 0, weeks: 0, name, pos });
            }
          }

          // accumulate points for open windows this week (respect scope)
          for (const [pid, win] of open.entries()) {
            if (curSet.has(pid)) {
              if (includeWeekForScope(season, w, scopeFilter)) {
                win.totalPts += sumPtsForPid(entries, pid);
                win.weeks += 1;
              }
            }
          }

          // close dropped
          for (const pid of prevSet) {
            if (!curSet.has(pid) && open.has(pid)) {
              const win = open.get(pid);
              if (win.weeks > 0 && !isExcluded(season, pid, win.name)) {
                const total = Number(win.totalPts);
                out.push({
                  season,
                  teamId,
                  owner: ownerName(season, teamId) || `Team ${teamId}`, // ✅ central mapping
                  playerId: pid,
                  player: win.name,
                  pos: win.pos,
                  weekAcquired: win.startWeek,
                  weeks: win.weeks,
                  totalPts: total,
                  ppg: win.weeks ? total / win.weeks : 0,
                  scope: weekScope(season, win.startWeek),
                });
              }
              open.delete(pid);
            }
          }

          prevSet = curSet;
        }

        // close anything still open at end of season
        for (const [pid, win] of open.entries()) {
          if (win.weeks > 0 && !isExcluded(season, pid, win.name)) {
            const total = Number(win.totalPts);
            out.push({
              season,
              teamId,
              owner: ownerName(season, teamId) || `Team ${teamId}`, // ✅ central mapping
              playerId: pid,
              player: win.name,
              pos: win.pos,
              weekAcquired: win.startWeek,
              weeks: win.weeks,
              totalPts: total,
              ppg: win.weeks ? total / win.weeks : 0,
              scope: weekScope(season, win.startWeek),
            });
          }
        }
      }
    }

    // only count acquisitions that start at week >= 2
    return out.filter((r) => Number(r.weekAcquired || 0) >= 2);
  }, [espnRostersByYear, isExcluded, weekScope, scopeFilter]);

  // ---- filters & UI (unchanged) ----
  const seasonOptions = React.useMemo(
    () =>
      Array.from(
        new Set(
          acquisitionsAll.map((a) => Number(a.season)).filter((y) => y >= 2019)
        )
      ).sort((a, b) => b - a),
    [acquisitionsAll]
  );

  const filtered = React.useMemo(() => {
    const yr = yearFilter === "all" ? null : Number(yearFilter);
    return acquisitionsAll.filter((a) => {
      if (hiddenSet.has(canonOwner(a.owner))) return false;
      if (yr && a.season !== yr) return false;
      if (scopeFilter !== "all" && a.scope !== scopeFilter) return false;
      if (Number(a.weeks || 0) < Number(minWeeks || 0)) return false;
      if (!includeByPos(a.pos, posFilter)) return false;
      return true;
    });
  }, [
    acquisitionsAll,
    yearFilter,
    scopeFilter,
    minWeeks,
    posFilter,
    hiddenSet,
    canonOwner,
  ]);

  const metricValue = React.useCallback(
    (a) => (rankMetric === "ppg" ? a.ppg : a.totalPts),
    [rankMetric]
  );

  const top20Global = React.useMemo(() => {
    const arr = [...filtered];
    arr.sort(
      (a, b) =>
        metricValue(b) - metricValue(a) ||
        a.season - b.season ||
        a.weekAcquired - b.weekAcquired
    );
    return arr.slice(0, 20);
  }, [filtered, metricValue]);

  const top5Global = React.useMemo(
    () => top20Global.slice(0, 5),
    [top20Global]
  );

  const ownersUnion = React.useMemo(
    () =>
      Array.from(
        new Set(
          filtered
            .map((a) => a.owner)
            .filter((o) => !hiddenSet.has(canonOwner(o)))
        )
      ).sort((a, b) => a.localeCompare(b)),
    [filtered, hiddenSet, canonOwner]
  );

  const top5ByOwner = React.useMemo(() => {
    const out = {};
    ownersUnion.forEach((o) => {
      const mine = filtered.filter((a) => a.owner === o);
      mine.sort(
        (a, b) =>
          metricValue(b) - metricValue(a) ||
          a.season - b.season ||
          a.weekAcquired - b.weekAcquired
      );
      out[o] = mine.slice(0, 5);
    });
    return out;
  }, [ownersUnion, filtered, metricValue]);

  const PickupRow = ({ a, showOwner = true }) => (
    <div className="flex items-center justify-between py-1 px-2 rounded hover:bg-zinc-100 dark:hover:bg-zinc-800">
      <div className="truncate">
        {showOwner ? (
          <>
            <span className="font-medium">{a.owner || "—"}</span>
            <span className="mx-1 text-zinc-400">•</span>
          </>
        ) : null}
        <span className="font-medium">{a.player}</span>
        {a.pos ? (
          <span className="ml-1 text-xs text-zinc-500">({a.pos})</span>
        ) : null}
        <span className="mx-1 text-zinc-400">•</span>
        <span>
          Wk {a.weekAcquired}, {a.season}
        </span>
        <span className="mx-1 text-zinc-400">•</span>
        <span className="text-xs text-zinc-500">
          {a.weeks} wk{a.weeks === 1 ? "" : "s"}
        </span>
      </div>
      <div className="text-right tabular-nums">
        <div>{fmt1(a.totalPts)} pts</div>
        <div className="text-xs text-zinc-500">{fmt2(a.ppg)} ppg</div>
      </div>
    </div>
  );

  const Top5Panel = () => (
    <div className="relative">
      <Card
        title={`Best Pickups${
          yearFilter === "all" ? " (All-time)" : ` (${yearFilter})`
        }`}
        right={
          <div className="flex flex-wrap gap-2 items-center">
            {/* Season */}
            <select
              className="bg-transparent border rounded px-2 py-1 text-sm"
              value={yearFilter}
              onChange={(e) => setYearFilter(e.target.value)}
              title="Season"
            >
              <option value="all">All seasons</option>
              {seasonOptions.map((y) => (
                <option key={y} value={y}>
                  {y}
                </option>
              ))}
            </select>

            {/* Scope */}
            <select
              className="bg-transparent border rounded px-2 py-1 text-sm"
              value={scopeFilter}
              onChange={(e) => setScopeFilter(e.target.value)}
              title="Scope"
            >
              <option value="regular">Regular season</option>
              <option value="playoffs">Playoffs</option>
              <option value="all">All games</option>
            </select>

            {/* Position */}
            <select
              className="bg-transparent border rounded px-2 py-1 text-sm"
              value={posFilter}
              onChange={(e) => setPosFilter(e.target.value)}
              title="Position"
            >
              <option value="all">All positions</option>
              <option value="QB">QB</option>
              <option value="RB">RB</option>
              <option value="WR">WR</option>
              <option value="TE">TE</option>
              <option value="DST">DEF</option>
              <option value="K">K</option>
              <option value="WR/RB/TE">WR/RB/TE</option>
              <option value="WR/RB">WR/RB</option>
            </select>

            {/* Metric */}
            <select
              className="bg-transparent border rounded px-2 py-1 text-sm"
              value={rankMetric}
              onChange={(e) => setRankMetric(e.target.value)}
              title="Ranking metric"
            >
              <option value="total">Rank by Total points</option>
              <option value="ppg">Rank by PPG</option>
            </select>

            {/* Min weeks */}
            <div className="flex items-center gap-1 text-sm">
              <span className="text-xs text-zinc-500">Min weeks:</span>
              <button
                className="px-2 py-1 border rounded"
                onClick={() =>
                  setMinWeeks((x) => Math.max(1, Number(x || 0) - 1))
                }
              >
                –
              </button>
              <span className="px-2">{minWeeks}</span>
              <button
                className="px-2 py-1 border rounded"
                onClick={() =>
                  setMinWeeks((x) => Math.min(99, Number(x || 0) + 1))
                }
              >
                +
              </button>
            </div>
          </div>
        }
      >
        {filtered.length === 0 ? (
          <div className="text-sm text-zinc-500">
            No qualifying free-agency acquisitions found.
          </div>
        ) : (
          <div className="space-y-1">
            {top5Global.map((a, i) => (
              <div
                key={`${a.season}-${a.weekAcquired}-${a.playerId}-${i}`}
                className="flex"
              >
                <div className="w-6 text-zinc-400">{i + 1}.</div>
                <div className="flex-1">
                  <PickupRow a={a} />
                </div>
              </div>
            ))}
          </div>
        )}

        <div className="mt-3 text-xs text-zinc-500">
          {rankMetric === "ppg"
            ? "PPG since acquisition"
            : "Total points since acquisition"}{" "}
          • Scope:{" "}
          {scopeFilter === "all"
            ? "All games"
            : scopeFilter === "playoffs"
            ? "Playoffs"
            : "Regular season"}{" "}
          • Min weeks: {minWeeks} • Source: Free Agency / Waivers (excludes
          players tagged Draft/Trade for that season)
        </div>
      </Card>

      {/* Floating + anchored to the true card corner (outside padded content) */}
      {top20Global.length > 5 && (
        <button
          onClick={() => setMoreGlobal(true)}
          title="Show more"
          className="absolute bottom-6 right-6 w-8 h-8 rounded-full border flex items-center justify-center
                     translate-x-1/2 translate-y-1/2
                     bg-white/80 dark:bg-zinc-900/80 backdrop-blur shadow-md
                     hover:bg-white dark:hover:bg-zinc-800 transition-all"
        >
          +
        </button>
      )}
    </div>
  );

  const PerOwnerPanels = () => (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
      {ownersUnion.map((o) => {
        const list = top5ByOwner[o] || [];

        // build a sorted list for this owner (same sort as top5), up to 20
        const fullList = React.useMemo(() => {
          const mine = filtered.filter((a) => a.owner === o);
          mine.sort(
            (a, b) =>
              metricValue(b) - metricValue(a) ||
              a.season - b.season ||
              a.weekAcquired - b.weekAcquired
          );
          return mine.slice(0, 20);
        }, [filtered, o, metricValue]);

        return (
          <Card
            key={o}
            title={`${o} — Top 5 FA Pickups`}
            right={
              fullList.length > 5 ? (
                <button
                  onClick={() => setMoreOwner(o)}
                  title="Show more"
                  className="w-6 h-6 rounded-full border flex items-center justify-center hover:bg-zinc-100 dark:hover:bg-zinc-800"
                >
                  +
                </button>
              ) : null
            }
          >
            {list.length === 0 ? (
              <div className="text-sm text-zinc-500">
                No qualifying pickups.
              </div>
            ) : (
              <div className="space-y-1">
                {list.map((a, i) => (
                  <div
                    key={`${o}-${a.season}-${a.weekAcquired}-${a.playerId}-${i}`}
                    className="flex"
                  >
                    <div className="w-6 text-zinc-400">{i + 1}.</div>
                    <div className="flex-1">
                      <PickupRow a={a} showOwner={false} />
                    </div>
                  </div>
                ))}
              </div>
            )}
          </Card>
        );
      })}
    </div>
  );

  // ---------------- Single transactions table (metric switcher) ----------------
  const METRIC_OPTIONS = [
    { value: "acquisitions", label: "Acquisitions" },
    { value: "drops", label: "Drops" },
    { value: "trades", label: "Trades" },
    { value: "moveToActive", label: "Moves to Active" },
    { value: "ir", label: "IR Moves" },
    { value: "all", label: "All (sum)" },
  ];
  const [metric, setMetric] = React.useState("acquisitions");

  const sumAll = (s) =>
    (s?.acquisitions || 0) +
    (s?.drops || 0) +
    (s?.trades || 0) +
    (s?.moveToActive || 0) +
    (s?.ir || 0);

  const pickMetric = (s, m) => (m === "all" ? sumAll(s) : s?.[m] || 0);

  const rowsTx = React.useMemo(() => {
    return ownersUnionTx.map((o) => {
      const canon = canonOwner(o);
      const row = { owner: canon, total: 0 };
      seasonsForTable.forEach((yr) => {
        const v = pickMetric(activityBySeasonCanon?.[yr]?.[canon], metric);
        row[yr] = v;
        row.total += v;
      });
      return row;
    });
  }, [
    ownersUnionTx,
    seasonsForTable,
    activityBySeasonCanon,
    metric,
    canonOwner,
  ]);

  const metricLabel =
    METRIC_OPTIONS.find((m) => m.value === metric)?.label || "Metric";

  // modal state for "see more" on per-owner cards
  // modal state for "see more" on per-owner cards
  const [moreOwner, setMoreOwner] = React.useState(null);
  // modal state for "see more" on the global Best Pickups card
  const [moreGlobal, setMoreGlobal] = React.useState(false);

  const TransactionsTable = () => (
    <Card
      title={
        <div className="flex items-center justify-between gap-3">
          <span>{metricLabel} by Member (per season)</span>
          <div className="flex items-center gap-2">
            <label className="text-sm opacity-80">Metric:</label>
            <select
              value={metric}
              onChange={(e) => setMetric(e.target.value)}
              className="bg-transparent border rounded px-2 py-1 text-sm"
            >
              {METRIC_OPTIONS.map((opt) => (
                <option key={opt.value} value={opt.value}>
                  {opt.label}
                </option>
              ))}
            </select>
          </div>
        </div>
      }
    >
      <div className="overflow-x-auto">
        <table className="min-w-full text-sm border-collapse">
          <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
            <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
              <th className="px-3 py-2 text-left">Member</th>
              {seasonsForTable.map((yr) => (
                <th key={`h-${yr}`} className="px-3 py-2 text-center">
                  {yr}
                </th>
              ))}
              <th className="px-3 py-2 text-center">Total</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700">
            {rowsTx.map((r) => (
              <tr key={r.owner} className="text-center">
                <td className="text-left px-3 py-2 font-medium">{r.owner}</td>
                {seasonsForTable.map((yr) => (
                  <td
                    key={`${r.owner}-${yr}`}
                    className="px-3 py-2 tabular-nums"
                  >
                    {r[yr] || 0}
                  </td>
                ))}
                <td className="px-3 py-2 font-semibold tabular-nums">
                  {r.total || 0}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </Card>
  );

  // simple local modal for showing 20 rows
  const MoreModal = ({ owner, onClose }) => {
    // rebuild 20 for the selected owner (same sort)
    const mine = React.useMemo(() => {
      const arr = filtered.filter((a) => a.owner === owner);
      arr.sort(
        (a, b) =>
          metricValue(b) - metricValue(a) ||
          a.season - b.season ||
          a.weekAcquired - b.weekAcquired
      );
      return arr.slice(0, 20);
    }, [filtered, owner, metricValue]);

    return (
      <div className="fixed inset-0 z-50">
        <div
          className="absolute inset-0 bg-black/50"
          onClick={onClose}
          aria-hidden="true"
        />
        <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[min(680px,92vw)] max-h-[80vh] overflow-auto rounded-xl bg-white dark:bg-zinc-900 shadow-xl">
          <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800">
            <div className="font-semibold">{owner} — Top 20 FA Pickups</div>
            <button
              className="px-2 py-1 rounded border hover:bg-zinc-100 dark:hover:bg-zinc-800"
              onClick={onClose}
            >
              Close
            </button>
          </div>
          <div className="p-3">
            {mine.length === 0 ? (
              <div className="text-sm text-zinc-500">
                No qualifying pickups.
              </div>
            ) : (
              <div className="space-y-1">
                {mine.map((a, i) => (
                  <div
                    key={`${owner}-${a.season}-${a.weekAcquired}-${a.playerId}-${i}`}
                    className="flex"
                  >
                    <div className="w-6 text-zinc-400">{i + 1}.</div>
                    <div className="flex-1">
                      <PickupRow a={a} showOwner={false} />
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-6">
      <Top5Panel />
      <PerOwnerPanels />

      {moreOwner ? (
        <MoreModal owner={moreOwner} onClose={() => setMoreOwner(null)} />
      ) : null}

      {moreGlobal ? (
        <div className="fixed inset-0 z-50">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setMoreGlobal(false)}
            aria-hidden="true"
          />
          <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[min(720px,92vw)] max-h-[80vh] overflow-auto rounded-xl bg-white dark:bg-zinc-900 shadow-xl">
            <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800">
              <div className="font-semibold">Best Pickups — Top 20</div>
              <button
                className="px-2 py-1 rounded border hover:bg-zinc-100 dark:hover:bg-zinc-800"
                onClick={() => setMoreGlobal(false)}
              >
                Close
              </button>
            </div>
            <div className="p-3">
              {top20Global.length === 0 ? (
                <div className="text-sm text-zinc-500">
                  No qualifying pickups.
                </div>
              ) : (
                <div className="space-y-1">
                  {top20Global.map((a, i) => (
                    <div
                      key={`global-${a.season}-${a.weekAcquired}-${a.playerId}-${i}`}
                      className="flex"
                    >
                      <div className="w-6 text-zinc-400">{i + 1}.</div>
                      <div className="flex-1">
                        <PickupRow a={a} showOwner={true} />
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>
        </div>
      ) : null}

      {/* Transactions table (ESPN transactionCounter with owner normalization) */}
      <TransactionsTable />
    </div>
  );
}

/* ---------------- RosterTab — per-week lineups by team --------------- */
/** ESPN lineup slot ids -> row label */
const __SLOT_LABEL = {
  0: "QB",
  2: "RB",
  3: "WR",
  4: "WR", // WR/TE counts can live on WR row
  6: "TE",
  7: "OP",
  16: "D/ST",
  17: "K",
  20: "BENCH",
  21: "IR",
  23: "FLEX",
};

/** sensible display order */
const __ROW_ORDER = [0, 2, 3, 4, 6, 7, 23, 16, 17, 21, 20];

function __buildRowSpecs(lineupCounts = {}) {
  const specs = [];
  __ROW_ORDER.forEach((slotId) => {
    const cnt = Number(lineupCounts?.[slotId] ?? 0);
    if (!cnt || cnt < 0) return;
    const base = __SLOT_LABEL[slotId] || `SLOT ${slotId}`;
    for (let i = 1; i <= cnt; i++) {
      const label =
        slotId === 20 ? `BENCH${i}` : cnt > 1 ? `${base}${i}` : base;
      specs.push({ slotId, label, index: i }); // index 1..cnt
    }
  });
  return specs;
}

// --- slot + position helpers (ESPN ids) ---
const SLOT = {
  QB: 0,
  RB: 2,
  WR: 3,
  TE: 6,
  OP: 7,
  DST: 16,
  K: 17,
  BENCH: 20,
  IR: 21,
  FLEX: 23,
};
// ESPN defaultPositionId for players: QB=1, RB=2, WR=3, TE=4, K=5, DST=16
const POS = { QB: 1, RB: 2, WR: 3, TE: 4, K: 5, DST: 16 };
const __POS_LABEL = { 1: "QB", 2: "RB", 3: "WR", 4: "TE", 5: "K", 16: "DST" };

// is player (by posId) eligible for a given slotId?
function __eligible(posId, slotId) {
  if (slotId === SLOT.QB) return posId === POS.QB;
  if (slotId === SLOT.RB) return posId === POS.RB;
  if (slotId === SLOT.WR || slotId === 4) return posId === POS.WR;
  if (slotId === SLOT.TE) return posId === POS.TE;
  if (slotId === SLOT.DST) return posId === POS.DST;
  if (slotId === SLOT.K) return posId === POS.K;
  if (slotId === SLOT.FLEX)
    return posId === POS.RB || posId === POS.WR || posId === POS.TE;
  if (slotId === SLOT.OP)
    return (
      posId === POS.QB ||
      posId === POS.RB ||
      posId === POS.WR ||
      posId === POS.TE
    );
  return false;
}

const __num = (v) => {
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
};

const __entrySlotId = (e) => e?.lineupSlotId ?? e?.slotId ?? e?.slot ?? null;
const __toFiniteNum = (v) => {
  const n = Number(v);
  return Number.isFinite(n) ? n : null;
};

const __entryPosId = (e) => {
  const cand =
    e?.defaultPositionId ??
    e?.playerPoolEntry?.player?.defaultPositionId ??
    e?.player?.defaultPositionId ??
    e?.posId;
  return __toFiniteNum(cand); // => null unless truly 0/2/4/6/16/17
};
const __entryPts = (e) =>
  __num(
    e?.appliedTotal ??
      e?.playerPoints?.appliedTotal ??
      e?.appliedStatTotal ??
      e?.pts ??
      0
  );

// projected points for that roster entry (week)
const __entryProj = (e) =>
  __num(
    e?.proj ??
      e?.projStart ??
      e?.projectedStart ??
      e?.playerPoints?.projectedTotal ??
      0
  );

// Prefer ESPN's eligibleSlots; fall back to any nested path we find.
const __entryEligibleSlots = (e) =>
  e?.eligibleSlots ??
  e?.player?.eligibleSlots ??
  e?.playerPoolEntry?.player?.eligibleSlots ??
  null;
const __entryIsMarkedInjured = (entry) => {
  if (!entry) return false;
  if (entry?.injured === true) return true;
  const sid = Number(__entrySlotId(entry));
  if (sid === SLOT.IR) return true;
  return false;
};
const __collectWeekNums = (value, outSet) => {
  if (!value) return;
  if (Array.isArray(value)) {
    value.forEach((v) => __collectWeekNums(v, outSet));
    return;
  }
  if (typeof value === "object") {
    Object.values(value || {}).forEach((v) => __collectWeekNums(v, outSet));
    return;
  }
  const n = Number(value);
  if (Number.isFinite(n)) outSet.add(n);
};
const __entryByeWeekNumbers = (entry) => {
  const set = new Set();
  __collectWeekNums(entry?.byeWeeks, set);
  __collectWeekNums(entry?.byeWeekSchedule, set);
  __collectWeekNums(entry?.proTeamByeWeekSchedule, set);
  __collectWeekNums(entry?.player?.byeWeeks, set);
  __collectWeekNums(entry?.player?.byeWeekSchedule, set);
  __collectWeekNums(entry?.playerPoolEntry?.byeWeeks, set);
  __collectWeekNums(entry?.playerPoolEntry?.byeWeekSchedule, set);
  __collectWeekNums(entry?.playerPoolEntry?.player?.byeWeeks, set);
  __collectWeekNums(entry?.playerPoolEntry?.player?.byeWeekSchedule, set);
  return Array.from(set);
};
const __entryIsOnByeForWeek = (entry, week) => {
  if (!entry) return false;
  if (entry?.onBye != null) return Boolean(entry.onBye);
  const w = Number(week);
  if (!Number.isFinite(w) || w <= 0) return false;
  const singles = [
    entry?.byeWeek,
    entry?.proTeamByeWeek,
    entry?.player?.byeWeek,
    entry?.player?.proTeamByeWeek,
    entry?.playerPoolEntry?.byeWeek,
    entry?.playerPoolEntry?.proTeamByeWeek,
    entry?.playerPoolEntry?.player?.byeWeek,
    entry?.playerPoolEntry?.player?.proTeamByeWeek,
  ];
  for (const cand of singles) {
    const n = Number(cand);
    if (Number.isFinite(n) && n === w) return true;
  }
  const weeks = __entryByeWeekNumbers(entry);
  return weeks.some((n) => n === w);
};
const __normalizeTeamToken = (value) => {
  if (value == null) return null;
  const str = String(value).trim();
  if (!str) return null;
  return str.toUpperCase();
};

const __hasAnyEntries = (value) => {
  if (!value) return false;
  if (Array.isArray(value)) return value.length > 0;
  if (value instanceof Map) return value.size > 0;
  if (typeof value === "object") return Object.keys(value).length > 0;
  return false;
};

const __seasonKeyVariants = (seasonKey) => {
  const keys = [];
  if (seasonKey != null) keys.push(seasonKey);
  const seasonNum = Number(seasonKey);
  if (Number.isFinite(seasonNum)) {
    keys.push(seasonNum);
    const str = String(seasonNum);
    if (str !== seasonKey) keys.push(str);
  }
  return keys
    .map((k) => (typeof k === "number" ? k : String(k)))
    .filter((k, idx, arr) => {
      if (k == null || k === "" || k === "NaN") return false;
      return arr.indexOf(k) === idx;
    });
};

const __getFromContainer = (container, key) => {
  if (!container) return undefined;
  if (container instanceof Map) return container.get(key);
  if (typeof container.get === "function") {
    try {
      const val = container.get(key);
      if (val !== undefined) return val;
    } catch {}
  }
  return container[key];
};

function __resolveProTeamsForSeason(seasonKey, league) {
  const variants = __seasonKeyVariants(seasonKey);
  const pick = (source) => {
    if (!source) return null;
    for (const key of variants) {
      const direct = __getFromContainer(source, key);
      if (__hasAnyEntries(direct)) return direct;
      if (typeof key === "string") {
        const alt = __getFromContainer(source, Number(key));
        if (__hasAnyEntries(alt)) return alt;
      } else if (Number.isFinite(key)) {
        const alt = __getFromContainer(source, String(key));
        if (__hasAnyEntries(alt)) return alt;
      }
    }
    return null;
  };

  const fromByYear = pick(league?.proTeamsByYear);
  if (__hasAnyEntries(fromByYear)) return fromByYear;

  const seasonObj = pick(league?.seasonsByYear);
  if (__hasAnyEntries(seasonObj)) {
    const nested =
      seasonObj?.proTeams ??
      seasonObj?.proTeamsById ??
      seasonObj?.proTeamsMap ??
      seasonObj?.proTeamInfo;
    if (__hasAnyEntries(nested)) return nested;
  }

  if (__hasAnyEntries(league?.proTeams)) return league.proTeams;

  try {
    const payload = JSON.parse(window.name || "{}");
    const payloadByYear = pick(payload?.proTeamsByYear);
    if (__hasAnyEntries(payloadByYear)) return payloadByYear;

    if (Array.isArray(payload?.seasons)) {
      const seasonNum = Number(seasonKey);
      const seasonFromPayload = payload.seasons.find((s) => {
        const sid = Number(s?.seasonId);
        if (Number.isFinite(seasonNum)) return sid === seasonNum;
        return variants.some((key) => String(sid) === String(key));
      });
      if (__hasAnyEntries(seasonFromPayload)) {
        const nested =
          seasonFromPayload?.proTeams ??
          seasonFromPayload?.proTeamsById ??
          seasonFromPayload?.proTeamsMap ??
          seasonFromPayload?.proTeamInfo;
        if (__hasAnyEntries(nested)) return nested;
      }
    }

    if (__hasAnyEntries(payload?.proTeams)) return payload.proTeams;
  } catch {}

  return null;
}

const __teamByeWeekNumbers = (team) => {
  const set = new Set();
  __collectWeekNums(team?.byeWeek, set);
  __collectWeekNums(team?.byeWeeks, set);
  __collectWeekNums(team?.byeWeekSchedule, set);
  __collectWeekNums(team?.byeWeekNumber, set);
  __collectWeekNums(team?.byeWeekNumbers, set);
  __collectWeekNums(team?.byeWeek?.week, set);
  __collectWeekNums(team?.byeWeek?.byeWeek, set);
  return Array.from(set).sort((a, b) => a - b);
};

function __buildProTeamLookup(source) {
  const byeById = new Map();
  const abbrevToId = new Map();
  if (!__hasAnyEntries(source)) return { byeById, abbrevToId };

  const pushTeam = (team, key) => {
    if (!team || typeof team !== "object") return;
    const idCand =
      team?.id ??
      team?.teamId ??
      team?.proTeamId ??
      (Number.isFinite(Number(key)) ? Number(key) : null);
    const id = Number(idCand);
    if (!Number.isFinite(id)) return;

    const byeWeeks = __teamByeWeekNumbers(team);
    if (byeWeeks.length) byeById.set(id, byeWeeks[0]);

    const tokens = [
      team?.abbrev,
      team?.abbreviation,
      team?.teamAbbrev,
      team?.teamAbbreviation,
      team?.shortName,
      team?.nickname,
      team?.nickName,
      team?.nameShort,
    ];
    const location = String(team?.location || "").trim();
    const name = String(team?.name || "").trim();
    if (location) tokens.push(location);
    if (name) tokens.push(name);
    if (location && name) tokens.push(`${location} ${name}`);

    tokens
      .map(__normalizeTeamToken)
      .filter(Boolean)
      .forEach((token) => {
        if (!abbrevToId.has(token)) abbrevToId.set(token, id);
      });
  };

  if (source instanceof Map) {
    source.forEach((team, key) => pushTeam(team, key));
  } else if (Array.isArray(source)) {
    source.forEach((team, idx) => pushTeam(team, team?.id ?? idx));
  } else if (typeof source === "object") {
    Object.entries(source).forEach(([key, team]) => pushTeam(team, key));
  }

  return { byeById, abbrevToId };
}

function __entryProTeamIds(entry, abbrevToId) {
  const ids = new Set();
  if (!entry) return [];

  const lookup = (token) => {
    if (!token) return;
    const numeric = Number(token);
    if (Number.isFinite(numeric)) {
      ids.add(numeric);
      return;
    }
    const norm = __normalizeTeamToken(token);
    if (!norm) return;
    if (abbrevToId instanceof Map && abbrevToId.has(norm)) {
      ids.add(abbrevToId.get(norm));
      return;
    }
    if (abbrevToId && typeof abbrevToId === "object") {
      const cand = abbrevToId[norm];
      const candId = Number(
        cand?.id ?? cand?.teamId ?? cand?.proTeamId ?? cand
      );
      if (Number.isFinite(candId)) ids.add(candId);
    }
  };

  const candidates = [
    entry?.proTeamId,
    entry?.proTeam,
    entry?.teamId,
    entry?.nflTeamId,
    entry?.player?.proTeamId,
    entry?.player?.proTeam,
    entry?.player?.teamId,
    entry?.player?.nflTeamId,
    entry?.player?.proTeamIdCurrent,
    entry?.player?.proTeamAbbreviation,
    entry?.player?.teamAbbreviation,
    entry?.playerPoolEntry?.proTeamId,
    entry?.playerPoolEntry?.proTeam,
    entry?.playerPoolEntry?.teamId,
    entry?.playerPoolEntry?.player?.proTeamId,
    entry?.playerPoolEntry?.player?.proTeam,
    entry?.playerPoolEntry?.player?.teamId,
    entry?.playerPoolEntry?.player?.nflTeamId,
    entry?.playerPoolEntry?.player?.proTeamIdCurrent,
    entry?.playerPoolEntry?.player?.proTeamAbbreviation,
    entry?.playerPoolEntry?.player?.teamAbbreviation,
  ];
  candidates.forEach(lookup);

  return Array.from(ids);
}

function __entryHasTeamBye(entry, week, lookup) {
  if (!lookup) return false;
  const w = Number(week);
  if (!Number.isFinite(w) || w <= 0) return false;
  const ids = __entryProTeamIds(entry, lookup.abbrevToId);
  return ids.some((id) => Number.isFinite(id) && lookup.byeById.get(id) === w);
}

// Build the list of starting slotIds for this league (exclude BENCH/IR)
function __buildStartSlots(lineupCounts = {}) {
  const out = [];
  Object.entries(lineupCounts || {}).forEach(([k, v]) => {
    const slotId = Number(k);
    const cnt = __num(v);
    if (!cnt) return;
    if (slotId === SLOT.BENCH || slotId === SLOT.IR) return; // exclude bench/IR
    for (let i = 0; i < cnt; i++) out.push(slotId);
  });
  // keep a stable order using our display order
  out.sort((a, b) => __ROW_ORDER.indexOf(a) - __ROW_ORDER.indexOf(b));
  return out;
}

// Actual starters points (sum of entries in true starting slots)
function __actualStarterPoints(entries = [], startSlotsSet) {
  let sum = 0;
  for (const e of entries) {
    const sid = __entrySlotId(e);
    if (startSlotsSet.has(sid)) sum += __entryPts(e);
  }
  return sum;
}

// tiny readers for pick helper
const __readLineupSlotId = (e) =>
  e?.lineupSlotId ?? e?.slotId ?? e?.slot ?? null;
const __readTeamId = (e) =>
  e?.onTeamId ??
  e?.teamId ??
  e?.team?.id ??
  e?.playerPoolEntry?.onTeamId ??
  null;

// REPLACE the old __pickEntryForRow with this one (note: +teamId param)
function __pickEntryForRow(entries = [], rowSpec, teamId) {
  const candidates = (entries || []).filter((e) => {
    const onThisTeam = Number(__readTeamId(e)) === Number(teamId);
    const hasSlot = Number.isFinite(Number(__readLineupSlotId(e)));
    const locked = e?.lineupLocked === true;
    return onThisTeam || hasSlot || locked;
  });
  const sameSlot = candidates.filter(
    (e) => Number(__readLineupSlotId(e)) === rowSpec.slotId
  );
  const pool = sameSlot.length ? sameSlot : candidates;
  if (!pool.length) return null;
  pool.sort(
    (a, b) =>
      (a?.lineupOrder ?? a?.slotOrder ?? 0) -
      (b?.lineupOrder ?? b?.slotOrder ?? 0)
  );
  return pool[Math.max(0, rowSpec.index - 1)] || null;
}

function __fmtPts(n) {
  const v = Number(n);
  if (!Number.isFinite(v)) return "";
  return v.toFixed(v % 1 ? 1 : 0);
}

// add:
function __redScale(n) {
  // HSL red with lightness from 92% (bottom) to 40% (top)
  const L1 = 92,
    L2 = 40;
  if (n <= 1) return ["hsl(0 85% 60%)"];
  return Array.from({ length: n }, (_, i) => {
    const t = i / (n - 1);
    const L = L1 + (L2 - L1) * t;
    return `hsl(0 85% ${L}%)`;
  });
}

// Build manager display names per teamId for the chosen season.
function __managerMapForSeason(season, providedByYear = {}) {
  const direct = providedByYear?.[season];
  if (direct && Object.keys(direct).length) return direct;

  try {
    const payload = JSON.parse(window.name || "{}");
    const seasonObj = (payload?.seasons || []).find(
      (s) => Number(s?.seasonId) === Number(season)
    );
    if (!seasonObj) return {};
    const nameByMemberId = {};
    (seasonObj.members || []).forEach((m) => {
      const dn = m?.displayName || "";
      const fn = m?.firstName || "";
      const ln = m?.lastName || "";
      const best = dn || [fn, ln].filter(Boolean).join(" ").trim() || "Unknown";
      if (m?.id != null) nameByMemberId[m.id] = best;
    });
    const out = {};
    (seasonObj.teams || []).forEach((t) => {
      const ownerId = t?.primaryOwner || (t?.owners && t.owners[0]) || null;
      if (t?.id != null) out[t.id] = nameByMemberId[ownerId] || `Team ${t.id}`;
    });
    return out;
  } catch {
    return {};
  }
}

/**
 * Compute max potential points for the week by optimally filling the start slots.
 * Now also falls back to rosterAcqByYear for a player's defaultPositionId when needed.
 */
function __potentialPoints(
  entries = [],
  startSlots = [],
  season = null,
  teamId = null,
  rosterAcqByYear = {}
) {
  // Build best-per-player record for this week
  const bestByPid = new Map(); // pid -> { pid, pts, posId }
  for (const e of entries || []) {
    const pid =
      e?.pid ??
      e?.playerId ??
      e?.player?.id ??
      e?.playerPoolEntry?.player?.id ??
      null;
    if (pid == null) continue;

    const pts = __entryPts(e);
    const prev = bestByPid.get(pid);

    // use defaultPositionId directly from this weekly roster entry
    const posId = __entryPosId(e);

    if (!prev || pts > prev.pts) {
      bestByPid.set(Number(pid), { pid: Number(pid), pts, posId });
    }
  }

  if (!bestByPid.size || !startSlots?.length) return 0;

  // Count how many of each slot we must fill
  const need = startSlots.reduce((m, s) => {
    m[s] = (m[s] || 0) + 1;
    return m;
  }, {});

  // Treat slotId=4 (your WR/TE display row) as an extra WR requirement
  need[SLOT.WR] = (need[SLOT.WR] || 0) + (need[4] || 0);

  const needQB = need[SLOT.QB] || 0;
  const needRB = need[SLOT.RB] || 0;
  const needWR = need[SLOT.WR] || 0;
  const needTE = need[SLOT.TE] || 0;
  const needDST = need[SLOT.DST] || 0;
  const needK = need[SLOT.K] || 0;
  const needFLEX = need[SLOT.FLEX] || 0;
  const needOP = need[SLOT.OP] || 0;

  // Split candidates by position and sort by points desc
  const poolQB = [];
  const poolRB = [];
  const poolWR = [];
  const poolTE = [];
  const poolDST = [];
  const poolK = [];

  for (const rec of bestByPid.values()) {
    switch (rec.posId) {
      case POS.QB:
        poolQB.push(rec);
        break;
      case POS.RB:
        poolRB.push(rec);
        break;
      case POS.WR:
        poolWR.push(rec);
        break;
      case POS.TE:
        poolTE.push(rec);
        break;
      case POS.DST:
        poolDST.push(rec);
        break;
      case POS.K:
        poolK.push(rec);
        break;
      default:
        break; // unknown/missing pos → cannot be used
    }
  }
  const byPts = (a, b) => b.pts - a.pts;
  poolQB.sort(byPts);
  poolRB.sort(byPts);
  poolWR.sort(byPts);
  poolTE.sort(byPts);
  poolDST.sort(byPts);
  poolK.sort(byPts);

  // Helper to take top N while marking used
  const used = new Set();
  const takeTop = (arr, n) => {
    let sum = 0;
    for (const rec of arr) {
      if (sum === sum && used.size >= 0) {
      } // keep linter calm in some bundlers
      if (n <= 0) break;
      if (used.has(rec.pid)) continue;
      used.add(rec.pid);
      sum += rec.pts;
      n--;
    }
    return sum;
  };

  // 1) Fill strict slots
  let total = 0;
  total += takeTop(poolQB, needQB);
  total += takeTop(poolRB, needRB);
  total += takeTop(poolWR, needWR);
  total += takeTop(poolTE, needTE);
  total += takeTop(poolDST, needDST);
  total += takeTop(poolK, needK);

  // 2) FLEX (RB/WR/TE only) from remaining
  if (needFLEX > 0) {
    const flexPool = []
      .concat(poolRB, poolWR, poolTE)
      .filter((r) => !used.has(r.pid))
      .sort(byPts);
    total += takeTop(flexPool, needFLEX);
  }

  // 3) OP (if present): QB/RB/WR/TE from remaining
  if (needOP > 0) {
    const opPool = []
      .concat(poolQB, poolRB, poolWR, poolTE)
      .filter((r) => !used.has(r.pid))
      .sort(byPts);
    total += takeTop(opPool, needOP);
  }

  return total;
}
export function RosterTab({
  rostersByYear = {},
  lineupSlotsByYear = {},
  currentWeekByYear = {},
  rosterAcqByYear = {}, // ✅ new (optional; safe if not provided)
  league, // ✅ optional: source of hiddenManagers
  hiddenManagers, // ✅ optional: fallback array of names
}) {
  const hidden = React.useMemo(() => {
    const fromLeague = Array.isArray(league?.hiddenManagers)
      ? league.hiddenManagers
      : null;
    const fromProp = Array.isArray(hiddenManagers) ? hiddenManagers : null;
    return new Set(fromLeague || fromProp || []);
  }, [league?.hiddenManagers, hiddenManagers]);

  const seasons = React.useMemo(
    () =>
      Object.keys(rostersByYear)

        .map((y) => Number(y))
        .filter((y) => y >= 2019)
        .sort((a, b) => b - a),
    [rostersByYear]
  );
  const [season, setSeason] = React.useState(
    seasons[0] || new Date().getFullYear()
  );
  React.useEffect(() => {
    if (!seasons.length) return;
    if (!seasons.includes(season)) setSeason(seasons[0]);
  }, [seasons]);
  const byTeam = rostersByYear?.[season] || {};

  // Central owner resolver (tries ownerName, falls back to window.__ownerMaps.name, else Team X)
  const resolveOwner = React.useCallback(
    (teamId) => {
      try {
        if (typeof ownerName === "function") {
          return ownerName(season, teamId) || `Team ${teamId}`;
        }
      } catch {}
      try {
        const nm = window?.__ownerMaps?.name;
        if (typeof nm === "function") {
          return nm(season, teamId) || `Team ${teamId}`;
        }
      } catch {}
      return `Team ${teamId}`;
    },
    [season]
  );

  const weekCap = React.useMemo(
    () => Number(currentWeekByYear?.[season]) || 0,
    [currentWeekByYear, season]
  );
  const weeks = React.useMemo(() => {
    const s = new Set();
    Object.values(byTeam).forEach((wkMap) =>
      Object.keys(wkMap || {}).forEach((w) => s.add(Number(w)))
    );
    let all = Array.from(s).sort((a, b) => a - b);
    if (weekCap > 0) all = all.filter((w) => w <= weekCap);
    return all;
  }, [byTeam, weekCap]);
  const rowSpecs = React.useMemo(() => {
    const fromSettings = __buildRowSpecs(lineupSlotsByYear?.[season] || {});
    if (fromSettings.length) return fromSettings;
    return __buildRowSpecs({
      0: 1,
      2: 2,
      3: 2,
      6: 1,
      23: 1,
      16: 1,
      17: 1,
      20: 6,
    });
  }, [lineupSlotsByYear, season]);

  // starter slots for this season (derived from ESPN lineup settings)
  const startSlots = React.useMemo(
    () => __buildStartSlots(lineupSlotsByYear?.[season] || {}),
    [lineupSlotsByYear, season]
  );
  const startSlotsSet = React.useMemo(() => new Set(startSlots), [startSlots]);

  const teamIds = React.useMemo(
    () =>
      Object.keys(byTeam)
        .map((t) => Number(t))
        .filter((tid) => !hidden.has(resolveOwner(tid)))
        .sort((a, b) =>
          resolveOwner(a)
            .toLowerCase()
            .localeCompare(resolveOwner(b).toLowerCase())
        ),
    [byTeam, resolveOwner, hidden]
  );

  const [summaryMode, setSummaryMode] = React.useState("weekly"); // "weekly" | "yearly"
  const [summaryView, setSummaryView] = React.useState("chart"); // "table" | "chart"
  const [showProj, setShowProj] = React.useState(false); // show projections in roster tables

  // --- helper: bench left (potential - actual) for one team/week ---
  const __benchLeftFor = React.useCallback(
    (seasonId, teamId, week) => {
      const entries = rostersByYear?.[seasonId]?.[teamId]?.[week] || [];
      const starts = __buildStartSlots(lineupSlotsByYear?.[seasonId] || {});
      const startSet = new Set(starts);
      const actual = __actualStarterPoints(entries, startSet);
      const potential = __potentialPoints(
        entries,
        starts,
        seasonId,
        teamId,
        {}
      );
      return Math.max(0, potential - actual);
    },
    [rostersByYear, lineupSlotsByYear]
  );

  // ---------- WEEKLY SUMMARY (current `season`) ----------
  const weeklySummary = React.useMemo(() => {
    const wksSet = new Set();
    Object.values(byTeam).forEach((wmap) =>
      Object.keys(wmap || {}).forEach((w) => wksSet.add(Number(w)))
    );
    const weekCols = Array.from(wksSet).sort((a, b) => a - b);
    // limit to currentWeek if provided
    const cap = Number(currentWeekByYear?.[season]) || 0;
    const weeksToUse = cap ? weekCols.filter((w) => w <= cap) : weekCols;

    // rows keyed by manager name for the selected season
    const rows = teamIds.map((tid) => {
      const manager = resolveOwner(tid);
      const values = weeksToUse.map((w) => __benchLeftFor(season, tid, w));
      const sum = values.reduce((s, n) => s + (Number(n) || 0), 0);
      return { manager, teamId: tid, values, sum };
    });

    return { weeks: weeksToUse, rows };
  }, [
    byTeam,
    teamIds,
    resolveOwner,
    season,
    currentWeekByYear,
    __benchLeftFor,
  ]);

  // ---------- YEARLY SUMMARY (all seasons) ----------
  const yearlySummary = React.useMemo(() => {
    const yearsAsc = [...seasons].sort((a, b) => a - b); // columns from oldest → newest

    // Build Manager name list across all seasons (ensure stable order by latest season name)
    const allManagers = new Set();
    for (const yr of seasons) {
      const teams = Object.keys(rostersByYear?.[yr] || {}).map(Number);
      teams.forEach((tid) => {
        const name = resolveOwner(tid);
        if (!hidden.has(name)) allManagers.add(name);
      });
    }
    const managers = Array.from(allManagers).sort((a, b) => a.localeCompare(b));

    // For each manager, for each year, sum bench left over all weeks for the teamIds that map to that manager in that year
    const rows = managers.map((mgr) => {
      const perYear = yearsAsc.map((yr) => {
        // Collect teamIds whose resolveOwner(yr, tid) === mgr (use rostersByYear keys for that yr)
        const tids = Object.keys(rostersByYear?.[yr] || {})
          .map(Number)
          .filter((tid) => resolveOwner(tid) === mgr);

        if (!tids.length) return 0;

        // Weeks in this year (cap by currentWeek if present)
        const wksSet = new Set();
        tids.forEach((tid) =>
          Object.keys(rostersByYear?.[yr]?.[tid] || {}).forEach((w) =>
            wksSet.add(Number(w))
          )
        );
        const allWks = Array.from(wksSet).sort((a, b) => a - b);
        const cap = Number(currentWeekByYear?.[yr]) || 0;
        const weeksToUse = cap ? allWks.filter((w) => w <= cap) : allWks;

        // Sum across those teams & weeks
        let sum = 0;
        for (const tid of tids) {
          for (const w of weeksToUse) {
            sum += __benchLeftFor(yr, tid, w);
          }
        }
        return sum;
      });

      const total = perYear.reduce((s, n) => s + (Number(n) || 0), 0);
      const avg = yearsAsc.length ? total / yearsAsc.length : 0;

      return { manager: mgr, perYear, total, avg };
    });

    return { years: yearsAsc, rows };
  }, [seasons, rostersByYear, resolveOwner, currentWeekByYear, __benchLeftFor]);
  // ---- sorting helpers/state ----
  const SortHeader = ({ label, active, dir, onClick, className = "" }) => (
    <th className={className}>
      <button
        type="button"
        onClick={onClick}
        className="inline-flex items-center gap-1 hover:underline"
        title="Click to sort"
      >
        <span>{label}</span>
        <span className="opacity-60 text-[10px]">
          {active ? (dir === "asc" ? "▲" : "▼") : "↕"}
        </span>
      </button>
    </th>
  );

  const cmpDir = (a, b, dir) => {
    const as = typeof a === "string",
      bs = typeof b === "string";
    if (as || bs) {
      const r = String(a ?? "").localeCompare(String(b ?? ""));
      return dir === "asc" ? r : -r;
    }
    const r = Number(a ?? -Infinity) - Number(b ?? -Infinity);
    return dir === "asc" ? r : -r;
  };

  const [weeklySort, setWeeklySort] = React.useState({
    key: "manager",
    dir: "asc",
  });
  const [yearlySort, setYearlySort] = React.useState({
    key: "manager",
    dir: "asc",
  });

  const toggleSort = (cur, set, key) =>
    set(
      cur.key === key
        ? { key, dir: cur.dir === "asc" ? "desc" : "asc" }
        : { key, dir: "desc" }
    );

  const weekIndexByWeek = React.useMemo(
    () =>
      Object.fromEntries((weeklySummary?.weeks || []).map((w, i) => [w, i])),
    [weeklySummary]
  );
  const yearIndexByYear = React.useMemo(
    () =>
      Object.fromEntries((yearlySummary?.years || []).map((y, i) => [y, i])),
    [yearlySummary]
  );

  const weeklyRowsSorted = React.useMemo(() => {
    const rows = [...(weeklySummary?.rows || [])];
    const { key, dir } = weeklySort;
    return rows.sort((a, b) => {
      let va, vb;
      if (key === "manager") {
        va = a.manager;
        vb = b.manager;
      } else if (key === "sum") {
        va = a.sum;
        vb = b.sum;
      } else if (key.startsWith("w:")) {
        const w = Number(key.slice(2));
        const idx = weekIndexByWeek[w] ?? -1;
        va = a.values[idx] ?? 0;
        vb = b.values[idx] ?? 0;
      }
      return cmpDir(va, vb, dir);
    });
  }, [weeklySummary, weeklySort, weekIndexByWeek]);

  const yearlyRowsSorted = React.useMemo(() => {
    const rows = [...(yearlySummary?.rows || [])];
    const { key, dir } = yearlySort;
    return rows.sort((a, b) => {
      let va, vb;
      if (key === "manager") {
        va = a.manager;
        vb = b.manager;
      } else if (key === "total") {
        va = a.total;
        vb = b.total;
      } else if (key === "avg") {
        va = a.avg;
        vb = b.avg;
      } else if (key.startsWith("y:")) {
        const y = Number(key.slice(2));
        const idx = yearIndexByYear[y] ?? -1;
        va = a.perYear[idx] ?? 0;
        vb = b.perYear[idx] ?? 0;
      }
      return cmpDir(va, vb, dir);
    });
  }, [yearlySummary, yearlySort, yearIndexByYear]);
  // add: keys, colors, and data for the chart views
  const weekKeys = React.useMemo(
    () => (weeklySummary?.weeks || []).map((w) => `W${w}`),
    [weeklySummary]
  );
  const weekColors = React.useMemo(
    () => __redScale(weekKeys.length),
    [weekKeys]
  );
  const weeklyChartData = React.useMemo(() => {
    return (weeklyRowsSorted || []).map((r) => {
      const row = { manager: r.manager, total: Number(r.sum || 0) };
      (weeklySummary?.weeks || []).forEach((w, i) => {
        row[`W${w}`] = Number(r.values?.[i] || 0);
      });
      return row;
    });
  }, [weeklyRowsSorted, weeklySummary]);

  const yearKeys = React.useMemo(
    () => (yearlySummary?.years || []).map((y) => `Y${y}`),
    [yearlySummary]
  );
  const yearColors = React.useMemo(
    () => __redScale(yearKeys.length),
    [yearKeys]
  );
  const yearlyChartData = React.useMemo(() => {
    return (yearlyRowsSorted || []).map((r) => {
      const row = { manager: r.manager, total: Number(r.total || 0) };
      (yearlySummary?.years || []).forEach((y, i) => {
        row[`Y${y}`] = Number(r.perYear?.[i] || 0);
      });
      return row;
    });
  }, [yearlyRowsSorted, yearlySummary]);

  const TeamTable = ({ teamId, showProj }) => {
    const wkMap = byTeam?.[teamId] || {};
    const manager = resolveOwner(teamId);

    // per-week totals for this team
    const perWeekTotals = React.useMemo(() => {
      const out = {};
      weeks.forEach((w) => {
        const entries = wkMap?.[w] || [];

        // team actual in true starting slots
        const actual = __actualStarterPoints(entries, startSlotsSet);

        // team projected = sum of projected points for entries in true starting slots
        let projected = 0;
        for (const e of entries) {
          const sid = __entrySlotId(e);
          if (startSlotsSet.has(sid)) projected += __entryProj(e);
        }

        // team potential = optimal lineup ceiling (existing logic)
        const potential = __potentialPoints(
          entries,
          startSlots,
          season,
          teamId,
          rosterAcqByYear
        );

        const left = Math.max(0, potential - actual);
        out[w] = { actual, projected, potential, left };
      });
      return out;
    }, [
      wkMap,
      weeks,
      startSlots,
      startSlotsSet,
      season,
      teamId,
      rosterAcqByYear,
    ]);

    const NameCell = ({ entry }) => {
      const pid =
        entry?.pid ??
        entry?.playerId ??
        entry?.player?.id ??
        entry?.playerPoolEntry?.player?.id ??
        null;

      // use the entry's defaultPositionId (already present on weekly rosters)
      const posId = __entryPosId(entry);
      const label = posId != null ? __POS_LABEL[posId] || "" : "";

      const name = entry?.name || "";

      return (
        <div>
          <div className="truncate" title={name}>
            {name}
            {label ? (
              <span className="ml-1 inline-block align-middle text-[10px] px-1 py-[1px] rounded bg-zinc-200/70 dark:bg-zinc-800/70">
                {label}
              </span>
            ) : null}
          </div>

          {/* actual points */}
          <div className="opacity-60">
            {Number.isFinite(entry?.pts) ? `${__fmtPts(entry.pts)} pts` : ""}
          </div>

          {/* projected points (toggle) */}
          {showProj ? (
            <div className="opacity-70 text-[11px]">
              {(() => {
                const p = __entryProj(entry);
                if (!Number.isFinite(p)) return "";
                const d = __entryPts(entry) - p;
                const sign = d > 0 ? "+" : d < 0 ? "−" : "±";
                const mag = __fmtPts(Math.abs(d));
                return `proj ${__fmtPts(p)} (${sign}${mag})`;
              })()}
            </div>
          ) : null}
        </div>
      );
    };
    return (
      <Card className="mb-6" title={manager} subtitle="Weekly lineups by slot">
        <TableBox>
          <thead>
            <tr>
              <th className="w-16 text-center">#</th>
              <th className="w-28">Slot</th>
              {weeks.map((w) => (
                <th key={w} className="text-center">{`W${w}`}</th>
              ))}
            </tr>
            <tr className="text-[10px] uppercase tracking-wide text-zinc-500">
              <th />
              <th className="text-right pr-1">
                {showProj
                  ? "Scored / Projected / Potential / Left"
                  : "Scored / Potential / Left"}
              </th>
              {weeks.map((w) => {
                const t = perWeekTotals[w] || {
                  actual: 0,
                  projected: 0,
                  potential: 0,
                  left: 0,
                };
                return (
                  <th key={`band-${w}`} className="text-center font-normal">
                    <div className="tabular-nums">{__fmtPts(t.actual)}</div>

                    {showProj ? (
                      <div className="tabular-nums opacity-90">
                        {__fmtPts(t.projected)}
                      </div>
                    ) : null}

                    <div className="tabular-nums opacity-80">
                      {__fmtPts(t.potential)}
                    </div>
                    <div className="tabular-nums opacity-60">
                      {__fmtPts(t.left)}
                    </div>
                  </th>
                );
              })}
            </tr>
          </thead>
          <tbody>
            {rowSpecs.map((rs, i) => (
              <tr key={`${rs.slotId}-${rs.index}`}>
                <td className="text-center opacity-70">{i + 1}</td>
                <td className="font-medium">{rs.label}</td>
                {weeks.map((w) => {
                  const entries = wkMap?.[w] || [];
                  const e = __pickEntryForRow(entries, rs, teamId);
                  return (
                    <td key={w} className="text-xs align-top">
                      {e ? (
                        <NameCell entry={e} />
                      ) : (
                        <span className="opacity-40">—</span>
                      )}
                    </td>
                  );
                })}
              </tr>
            ))}
          </tbody>
        </TableBox>
      </Card>
    );
  };

  return (
    <>
      <Card
        title={
          <div className="flex items-center gap-2">
            <span>Bench Points Summary</span>
            <span
              className="inline-flex items-center justify-center w-4 h-4 rounded-full border border-zinc-500/60 text-[10px] leading-none cursor-help hover:bg-zinc-700/40"
              title="Bench Points Summary shows how many points a manager left on the bench. It compares the lineup that was actually played vs. the optimal lineup for that week’s roster. Higher bars/values mean more points left on the bench (worse lineup decisions)."
              aria-label="Help: Bench Points Summary explanation"
            >
              ?
            </span>
          </div>
        }
        subtitle={
          summaryMode === "weekly"
            ? `Managers × Weeks — points left on bench (season ${season})`
            : `Managers × Years — season totals of points left on bench`
        }
        right={
          <div className="flex items-center gap-2">
            {/* view toggle */}
            <select
              className="px-2 py-1 rounded border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-950"
              value={summaryView}
              onChange={(e) => setSummaryView(e.target.value)}
              title="View"
            >
              <option value="table">Data</option>
              <option value="chart">Graph</option>
            </select>

            {/* mode toggle */}
            <select
              className="px-2 py-1 rounded border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-950"
              value={summaryMode}
              onChange={(e) => setSummaryMode(e.target.value)}
              title="Mode"
            >
              <option value="weekly">Weekly</option>
              <option value="yearly">Yearly</option>
            </select>

            {/* year picker only for weekly */}
            {summaryMode === "weekly" && seasons.length > 0 ? (
              <select
                className="px-2 py-1 rounded border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-950"
                value={season}
                onChange={(e) => setSeason(Number(e.target.value))}
                title="Season"
              >
                {seasons.map((y) => (
                  <option key={y} value={y}>
                    {y}
                  </option>
                ))}
              </select>
            ) : null}
          </div>
        }
      >
        {summaryView === "table" ? (
          summaryMode === "weekly" ? (
            <TableBox>
              <thead>
                <tr>
                  <SortHeader
                    label="Manager"
                    active={weeklySort.key === "manager"}
                    dir={weeklySort.dir}
                    onClick={() =>
                      toggleSort(weeklySort, setWeeklySort, "manager")
                    }
                    className="w-44"
                  />
                  {weeklySummary.weeks.map((w) => (
                    <SortHeader
                      key={`w${w}`}
                      label={`W${w}`}
                      active={weeklySort.key === `w:${w}`}
                      dir={weeklySort.dir}
                      onClick={() =>
                        toggleSort(weeklySort, setWeeklySort, `w:${w}`)
                      }
                      className="text-center"
                    />
                  ))}
                  <SortHeader
                    label="Season Sum"
                    active={weeklySort.key === "sum"}
                    dir={weeklySort.dir}
                    onClick={() => toggleSort(weeklySort, setWeeklySort, "sum")}
                    className="text-right"
                  />
                </tr>
              </thead>
              <tbody>
                {weeklyRowsSorted.map((r) => (
                  <tr key={r.manager}>
                    <td className="font-medium">{r.manager}</td>
                    {r.values.map((v, i) => (
                      <td key={i} className="text-center tabular-nums">
                        {__fmtPts(v)}
                      </td>
                    ))}
                    <td className="text-right tabular-nums font-semibold">
                      {__fmtPts(r.sum)}
                    </td>
                  </tr>
                ))}
              </tbody>
            </TableBox>
          ) : (
            <TableBox>
              <thead>
                <tr>
                  <SortHeader
                    label="Manager"
                    active={yearlySort.key === "manager"}
                    dir={yearlySort.dir}
                    onClick={() =>
                      toggleSort(yearlySort, setYearlySort, "manager")
                    }
                    className="w-44"
                  />
                  {yearlySummary.years.map((y) => (
                    <SortHeader
                      key={`y${y}`}
                      label={y}
                      active={yearlySort.key === `y:${y}`}
                      dir={yearlySort.dir}
                      onClick={() =>
                        toggleSort(yearlySort, setYearlySort, `y:${y}`)
                      }
                      className="text-center"
                    />
                  ))}
                  <SortHeader
                    label="Total"
                    active={yearlySort.key === "total"}
                    dir={yearlySort.dir}
                    onClick={() =>
                      toggleSort(yearlySort, setYearlySort, "total")
                    }
                    className="text-right"
                  />
                  <SortHeader
                    label="Avg/Season"
                    active={yearlySort.key === "avg"}
                    dir={yearlySort.dir}
                    onClick={() => toggleSort(yearlySort, setYearlySort, "avg")}
                    className="text-right"
                  />
                </tr>
              </thead>
              <tbody>
                {yearlyRowsSorted.map((r) => (
                  <tr key={r.manager}>
                    <td className="font-medium">{r.manager}</td>
                    {r.perYear.map((v, i) => (
                      <td key={i} className="text-center tabular-nums">
                        {__fmtPts(v)}
                      </td>
                    ))}
                    <td className="text-right tabular-nums font-semibold">
                      {__fmtPts(r.total)}
                    </td>
                    <td className="text-right tabular-nums">
                      {__fmtPts(r.avg)}
                    </td>
                  </tr>
                ))}
              </tbody>
            </TableBox>
          )
        ) : (
          <div className="h-[520px] w-full">
            <ResponsiveContainer width="100%" height={480}>
              <BarChart
                data={
                  summaryMode === "weekly" ? weeklyChartData : yearlyChartData
                }
                margin={{ top: 8, right: 24, bottom: 56, left: 8 }}
              >
                <CartesianGrid
                  strokeDasharray="3 3"
                  opacity={0.25}
                  vertical={false}
                />
                <XAxis
                  dataKey="manager"
                  interval={0}
                  angle={-20}
                  textAnchor="end"
                  tick={{ fill: "#e5e7eb", fontSize: 12 }}
                  axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                  tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
                />
                <YAxis
                  tick={{ fill: "#e5e7eb", fontSize: 12 }}
                  axisLine={{ stroke: "rgba(255,255,255,0.28)" }}
                  tickLine={{ stroke: "rgba(255,255,255,0.28)" }}
                />
                <Tooltip
                  contentStyle={{
                    background: "rgba(24,24,27,0.95)",
                    border: "1px solid rgba(255,255,255,0.12)",
                    color: "#e5e7eb",
                  }}
                  formatter={(v, k) => [__fmtPts(v), k]}
                />
                {(summaryMode === "weekly" ? weekKeys : yearKeys).map(
                  (key, i) => (
                    <Bar
                      key={key}
                      dataKey={key}
                      stackId="bench"
                      fill={
                        (summaryMode === "weekly" ? weekColors : yearColors)[i]
                      }
                    />
                  )
                )}
              </BarChart>
            </ResponsiveContainer>
          </div>
        )}
      </Card>

      <Card
        title="Roster"
        subtitle={`Weekly lineups by team. Rows follow the league's roster settings; columns are weeks${
          weekCap ? ` (through W${weekCap})` : ""
        }.`}
        right={
          <div className="flex items-center gap-3">
            <label className="inline-flex items-center gap-2 text-sm">
              <input
                type="checkbox"
                className="checkbox checkbox-sm"
                checked={showProj}
                onChange={(e) => setShowProj(e.target.checked)}
              />
              <span>Show projections</span>
            </label>

            {seasons.length > 0 ? (
              <select
                className="px-2 py-1 rounded border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-950"
                value={season}
                onChange={(e) => setSeason(Number(e.target.value))}
              >
                {seasons.map((y) => (
                  <option key={y} value={y}>
                    {y}
                  </option>
                ))}
              </select>
            ) : null}
          </div>
        }
      >
        {teamIds.length ? (
          teamIds.map((tid) => (
            <TeamTable key={tid} teamId={tid} showProj={showProj} />
          ))
        ) : (
          <div className="text-sm opacity-70">
            No roster data found for {season}.
          </div>
        )}
      </Card>
    </>
  );
}
/* DraftTab — per-year draft picks grouped by manager (owner names canonicalized on read) */
export function DraftTab({ draftByYear, hiddenManagers }) {
  const draftWithFinish = React.useMemo(
    () =>
      window.FL_attachFinishPosFromLocal
        ? window.FL_attachFinishPosFromLocal(draftByYear, "PPR")
        : draftByYear,
    [draftByYear]
  );

  const canonicalize =
    (typeof window !== "undefined" &&
      window.__ownerMaps &&
      typeof window.__ownerMaps.canon === "function" &&
      window.__ownerMaps.canon.bind(window.__ownerMaps)) ||
    ((s) => (s == null ? "" : String(s)));

  // canonical hidden managers set (compare using canonicalize)
  const hiddenSet = React.useMemo(() => {
    const list = Array.isArray(hiddenManagers) ? hiddenManagers : [];
    return new Set(list.map((n) => canonicalize(n)));
  }, [hiddenManagers, canonicalize]);

  // also keep a normalized (case/spacing/punct stripped) set for robustness
  const normName = React.useCallback(
    (s) =>
      String(s || "")
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, "")
        .replace(/\s+/g, " ")
        .trim(),
    []
  );
  const hiddenNormSet = React.useMemo(() => {
    const list = Array.isArray(hiddenManagers) ? hiddenManagers : [];
    return new Set(list.map((n) => normName(canonicalize(n))));
  }, [hiddenManagers, canonicalize, normName]);

  function groupByOwner(rows = []) {
    const m = new Map();
    rows.forEach((r) => {
      const rawOwner =
        r?.owner ??
        r?.manager ??
        r?.manager_name ??
        r?.ownerName ??
        r?.owner_full ??
        "";
      const owner = canonicalize(rawOwner) || "—";
      const ownerNorm = normName(rawOwner) || normName(owner);
      if (hiddenSet.has(owner) || hiddenNormSet.has(ownerNorm)) return; // skip hidden
      if (!m.has(owner)) m.set(owner, []);
      m.get(owner).push(r);
    });
    return Array.from(m.entries()).map(([owner, picks]) => ({ owner, picks }));
  }

  const [weighted, setWeighted] = React.useState(true);
  const [alpha, setAlpha] = React.useState(0.5);
  const [includeKeepers, setIncludeKeepers] = React.useState(true);
  const [includeKDst, setIncludeKDst] = React.useState(true);
  const [showExplain, setShowExplain] = React.useState(false);

  // NEW: breakdown modal
  const [showBreakdown, setShowBreakdown] = React.useState(false);
  const [breakdownTitle, setBreakdownTitle] = React.useState("");
  const [breakdownRows, setBreakdownRows] = React.useState([]);

  const [year, setYear] = React.useState(() => {
    const years = Object.keys(draftByYear || {})
      .map((y) => Number(y))
      .sort((a, b) => b - a);
    return years[0] || new Date().getFullYear();
  });
  React.useEffect(() => {
    const years = Object.keys(draftByYear || {})
      .map((y) => Number(y))
      .sort((a, b) => b - a);
    if (years.length && !years.includes(Number(year))) setYear(years[0]);
  }, [draftByYear]);
  const years = React.useMemo(
    () =>
      Object.keys(draftByYear || {})
        .map((y) => Number(y))
        .sort((a, b) => b - a),
    [draftByYear]
  );
  // Local "Drafted Points" year selection (adds All Years without affecting your global Year)
  const [dpYear, setDpYear] = React.useState(() =>
    String((years && years[0]) || new Date().getFullYear())
  );
  const dpIsAllYears = dpYear === "ALL";

  // Week selection (only used when a single year is selected)
  const [week, setWeek] = React.useState(0); // 0 = All Weeks
  React.useEffect(() => {
    setWeek(0); // reset when the Drafted Points year changes
  }, [dpYear]);

  // Current week by season (from sources if present; else infer from rosters)
  const currentWeekByYear = React.useMemo(() => {
    const S = (typeof window !== "undefined" && (window.__sources || {})) || {};
    const out = {};
    const fromSrc = S.currentWeekBySeason || S.espnCurrentWeekBySeason || {};
    Object.entries(fromSrc || {}).forEach(([yrStr, wk]) => {
      const yr = Number(yrStr);
      const n = Number(wk);
      if (Number.isFinite(yr) && Number.isFinite(n) && n > 0) out[yr] = n;
    });

    // Fallback: highest week with any starter having numeric points
    const rosters = S.rostersByYear || {};
    Object.entries(rosters || {}).forEach(([yrStr, teams]) => {
      const yr = Number(yrStr);
      if (out[yr] != null) return;
      let maxW = 0;
      Object.values(teams || {}).forEach((weeksObj) => {
        Object.entries(weeksObj || {}).forEach(([wStr, entries]) => {
          const w = Number(wStr);
          const arr = Array.isArray(entries) ? entries : [];
          const played = arr.some((e) => {
            const sid = e?.lineupSlotId ?? e?.slotId ?? e?.slot;
            const isStarter = Number(sid) !== 20 && Number(sid) !== 21; // Bench/IR
            const pts = Number(
              e?.pts ??
                e?.appliedTotal ??
                e?.playerPoints?.appliedTotal ??
                e?.appliedStatTotal ??
                NaN
            );
            return isStarter && Number.isFinite(pts);
          });
          if (played && w > maxW) maxW = w;
        });
      });
      if (maxW > 0) out[yr] = maxW;
    });
    return out;
  }, []);

  const availableWeeks = React.useMemo(() => {
    if (dpIsAllYears) return [];
    const S = (typeof window !== "undefined" && (window.__sources || {})) || {};
    const rostersByYear = S.rostersByYear || {};
    const byTeam = rostersByYear?.[Number(dpYear)] || {};
    const set = new Set();
    Object.keys(byTeam || {}).forEach((tid) => {
      const weeksObj = byTeam[tid] || {};
      Object.keys(weeksObj || {}).forEach((w) => set.add(Number(w)));
    });
    const weeks = Array.from(set).sort((a, b) => a - b);
    const cap = currentWeekByYear[Number(dpYear)];
    return Number.isFinite(cap) ? weeks.filter((w) => w <= cap) : weeks;
  }, [dpYear, dpIsAllYears, currentWeekByYear]);

  const ownerDisplay = React.useCallback((s) => canonicalize(s) || "—", []);

  const rows = React.useMemo(() => {
    const arr = draftWithFinish?.[year] || [];
    return arr.slice().sort((a, b) => {
      const ra = Number(a.round || 0),
        rb = Number(b.round || 0);
      if (ra !== rb) return ra - rb;
      const oa = Number(a.overall || 0),
        ob = Number(b.overall || 0);
      return oa - ob;
    });
  }, [draftWithFinish, year]);

  const fmtADP = (v) => {
    if (v == null || Number.isNaN(Number(v))) return "—";
    const n = Number(v);
    return Number.isInteger(n) ? String(n) : n.toFixed(1);
  };
  const fmtPts = (n) =>
    n == null || !Number.isFinite(Number(n)) ? "—" : Number(n).toFixed(1);
  const fmtPct = (x) =>
    x == null || !Number.isFinite(Number(x)) ? "—" : `${Math.round(x * 100)}%`;

  const baseFromAdpPos = (s) => {
    if (!s || typeof s !== "string") return "";
    const m = s.match(/^([A-Za-z]+)\s*\d*$/);
    return m ? m[1].toUpperCase() : "";
  };
  const getPos = (r) => {
    if (r.adpPos && typeof r.adpPos === "string") return r.adpPos;
    const code = (
      r.fp_posCode ||
      r.posCode ||
      r.pos ||
      baseFromAdpPos(r.fp_pos) ||
      ""
    )
      .toString()
      .toUpperCase()
      .replace(/\s+/g, "");
    const rank =
      r.adpPosRank ??
      r.fp_posRank ??
      r.posRank ??
      r.posAtPick ??
      r.pos_at_pick ??
      null;
    if (code && rank != null && String(rank).trim() !== "")
      return `${code}${rank}`;
    if (code) return code;
    return "—";
  };
  const getFinishPos = (r) => {
    const fp = r.finishPos ?? r.finish_pos ?? r.finalPos ?? null;
    return fp == null || fp === "" ? "—" : fp;
  };
  const getUnderName = (r) => {
    const code = (r.pos || r.position || baseFromAdpPos(r.adpPos) || "")
      .toString()
      .toUpperCase();
    const team = (r.nfl || r.team || r.proTeam || "").toString().toUpperCase();
    const bits = [code || null, team || null].filter(Boolean);
    return bits.length ? bits.join("—") : "—";
  };
  const getPickPos = (r) => {
    if (typeof r?.posAtPickLabel === "string" && r.posAtPickLabel)
      return r.posAtPickLabel;
    const base = (r.pos || r.position || "").toString().toUpperCase().trim();
    const rank = r?.posAtPick;
    return base && Number.isFinite(rank) ? `${base}${rank}` : "—";
  };
  const posRankFromLabel = (label) => {
    if (!label || typeof label !== "string") return null;
    const m = label
      .toUpperCase()
      .replace(/\s+/g, "")
      .match(/^([A-Z/]+)(\d+)$/);
    if (!m) return null;
    let pos = m[1];
    if (pos === "D/ST") pos = "DST";
    if (pos === "DEF") pos = "DST";
    const rank = Number(m[2]);
    return Number.isFinite(rank) ? { pos, rank } : null;
  };
  const scoreFromPickLabels = (pickLabel, finishLabel) => {
    const p = posRankFromLabel(pickLabel);
    const f = posRankFromLabel(finishLabel);
    if (!p || !f || p.pos !== f.pos) return null;
    if (!includeKDst && (p.pos === "K" || p.pos === "DST")) return null;
    let diff = p.rank - f.rank;
    if (diff > 40) diff = 40;
    if (diff < -40) diff = -40;
    let s = weighted ? diff / Math.pow(p.rank, alpha) : diff;
    if (p.pos === "K" || p.pos === "DST") s *= 0.25;
    return s;
  };
  const meanScoreForPicks = (picks) => {
    let sum = 0,
      cnt = 0;
    for (const r of picks) {
      if (!includeKeepers && r?.keeper) continue;
      const pickLabel = getPickPos(r);
      const finLabel = getFinishPos(r);
      const s = scoreFromPickLabels(pickLabel, finLabel);
      if (s == null) continue;
      sum += s;
      cnt += 1;
    }
    return { sum, count: cnt, mean: cnt ? sum / cnt : 0 };
  };

  const bestYearScores = React.useMemo(() => {
    const groups = groupByOwner(draftWithFinish?.[year] || []);
    const rows = groups
      .map(({ owner, picks }) => ({ owner, ...meanScoreForPicks(picks) }))
      .filter((r) => r.count > 0)
      .sort((a, b) => b.mean - a.mean);
    return rows;
  }, [draftWithFinish, year, weighted, alpha, includeKeepers, includeKDst]);

  // NEW: count all draft seasons per owner (even if not scorable)
  const allDraftYearsByOwner = React.useMemo(() => {
    const map = new Map(); // owner -> Set(years)
    for (const yrStr of Object.keys(draftByYear || {})) {
      const yrRows = draftByYear[yrStr] || [];
      for (const r of yrRows) {
        const raw =
          r?.owner ??
          r?.manager ??
          r?.manager_name ??
          r?.ownerName ??
          r?.owner_full ??
          "";
        const o = ownerDisplay(raw);
        const isHidden =
          hiddenSet.has(canonicalize(o)) || hiddenNormSet.has(normName(o));
        if (isHidden) continue; // skip hidden
        if (!map.has(o)) map.set(o, new Set());
        map.get(o).add(Number(yrStr));
      }
    }
    return map; // Map(owner -> Set(years))
  }, [
    draftByYear,
    ownerDisplay,
    hiddenSet,
    hiddenNormSet,
    canonicalize,
    normName,
  ]);

  const bestOverallScores = React.useMemo(() => {
    const agg = new Map(); // owner -> { sumMeans, scorableYears, allYears }
    // gather scorable means across years
    for (const yrStr of Object.keys(draftWithFinish || {})) {
      const groups = groupByOwner(draftWithFinish?.[yrStr] || []);
      for (const { owner, picks } of groups) {
        const { mean, count } = meanScoreForPicks(picks);
        const cur = agg.get(owner) || {
          sumMeans: 0,
          scorableYears: 0,
          allYears: 0,
        };
        if (count > 0) {
          cur.sumMeans += mean;
          cur.scorableYears += 1;
        }
        agg.set(owner, cur);
      }
    }
    // attach total draft seasons (even if not scorable)
    for (const [owner, setYears] of allDraftYearsByOwner.entries()) {
      const cur = agg.get(owner) || {
        sumMeans: 0,
        scorableYears: 0,
        allYears: 0,
      };
      cur.allYears = setYears.size;
      agg.set(owner, cur);
    }

    const out = Array.from(agg.entries()).map(([owner, v]) => ({
      owner,
      years: v.allYears, // <-- show ALL draft years
      mean: v.scorableYears ? v.sumMeans / v.scorableYears : 0,
    }));
    out.sort((a, b) => b.mean - a.mean);
    return out;
  }, [
    draftWithFinish,
    meanScoreForPicks,
    allDraftYearsByOwner,
    weighted,
    alpha,
    includeKeepers,
    includeKDst,
  ]);
  // ---------- Drafted-points contribution (per owner, per season, and totals)
  const draftedPoints = React.useMemo(() => {
    const S = (typeof window !== "undefined" && (window.__sources || {})) || {};
    const rostersByYear = S.rostersByYear || {};
    const ownerByTeamByYear = S.ownerByTeamByYear || {};

    // Build: owner/year -> Set(playerId) drafted
    const draftedPidByOwnerYear = new Map();
    for (const [yrStr, picks] of Object.entries(draftByYear || {})) {
      const yr = Number(yrStr);
      (picks || []).forEach((r) => {
        if (!includeKeepers && r?.keeper) return;
        const raw =
          r?.owner ??
          r?.manager ??
          r?.manager_name ??
          r?.ownerName ??
          r?.owner_full ??
          "";
        const owner = canonicalize(raw) || "—";
        const ownerNorm = normName(raw) || normName(owner);
        if (hiddenSet.has(owner) || hiddenNormSet.has(ownerNorm)) return;

        const pid = Number(r?.playerId);
        if (!Number.isFinite(pid)) return;

        const key = `${owner}__${yr}`;
        if (!draftedPidByOwnerYear.has(key))
          draftedPidByOwnerYear.set(key, new Set());
        draftedPidByOwnerYear.get(key).add(pid);
      });
    }

    const teamIdForOwner = (yr, owner) => {
      const map = ownerByTeamByYear?.[yr] || {};
      for (const [tid, nm] of Object.entries(map)) {
        if (canonicalize(nm) === owner) return Number(tid);
      }
      return null;
    };

    const isStarterSlot = (slotId) => {
      const n = Number(
        slotId?.lineupSlotId ?? slotId?.slotId ?? slotId?.slot ?? slotId
      );
      // ESPN: 20 = Bench, 21 = IR
      return Number.isFinite(n) && n !== 20 && n !== 21;
    };

    const perSeason = [];
    const perWeek = []; // ADD
    const totals = new Map(); // owner -> { drafted, total, seasons:Set }

    for (const yrStr of Object.keys(draftByYear || {})) {
      const yr = Number(yrStr);

      // owners with picks this year (filtered by hidden)
      const ownersThisYear = new Set();
      (draftByYear?.[yr] || []).forEach((r) => {
        const raw =
          r?.owner ??
          r?.manager ??
          r?.manager_name ??
          r?.ownerName ??
          r?.owner_full ??
          "";
        const o = canonicalize(raw) || "—";
        const oNorm = normName(raw) || normName(o);
        if (hiddenSet.has(o) || hiddenNormSet.has(oNorm)) return;
        ownersThisYear.add(o);
      });

      ownersThisYear.forEach((owner) => {
        const teamId = teamIdForOwner(yr, owner);
        const weeksObj = rostersByYear?.[yr]?.[teamId] || {};
        const pidSet =
          draftedPidByOwnerYear.get(`${owner}__${yr}`) || new Set();

        const capW = currentWeekByYear?.[yr];
        let drafted = 0;
        let teamTotal = 0;

        Object.entries(weeksObj).forEach(([wStr, entries]) => {
          const w = Number(wStr);
          if (Number.isFinite(capW) && w > capW) return; // ignore future weeks

          const arr = Array.isArray(entries) ? entries : [];
          let draftedW = 0;
          let teamW = 0;
          arr.forEach((e) => {
            const sid = e?.lineupSlotId ?? e?.slotId ?? e?.slot;
            if (!isStarterSlot(sid)) return;
            const pts =
              Number(
                e?.pts ??
                  e?.appliedTotal ??
                  e?.playerPoints?.appliedTotal ??
                  e?.appliedStatTotal ??
                  0
              ) || 0;

            teamW += pts;
            const pid = Number(e?.pid ?? e?.playerId ?? e?.player?.id);
            if (Number.isFinite(pid) && pidSet.has(pid)) draftedW += pts;
          });

          perWeek.push({
            owner,
            year: yr,
            week: w,
            draftedPts: draftedW,
            teamPts: teamW,
            pct: teamW > 0 ? draftedW / teamW : null,
          });
          drafted += draftedW;
          teamTotal += teamW;
        });

        perSeason.push({
          owner,
          year: yr,
          draftedPts: drafted,
          teamPts: teamTotal,
          pct: teamTotal > 0 ? drafted / teamTotal : null,
        });
        const cur = totals.get(owner) || {
          drafted: 0,
          total: 0,
          seasons: new Set(),
        };
        cur.drafted += drafted;
        cur.total += teamTotal;
        cur.seasons.add(yr);
        totals.set(owner, cur);
      });
    }

    perSeason.sort((a, b) => b.year - a.year || a.owner.localeCompare(b.owner));

    const totalsRows = Array.from(totals.entries())
      .map(([owner, v]) => ({
        owner,
        seasons: v.seasons.size,
        draftedPts: v.drafted,
        teamPts: v.total,
        pct: v.total > 0 ? v.drafted / v.total : null,
      }))
      .sort((a, b) => (b.pct ?? -1) - (a.pct ?? -1));

    return { perSeason, perWeek, totals: totalsRows }; // ADD perWeek in return
  }, [
    draftByYear,
    includeKeepers,
    hiddenSet,
    hiddenNormSet,
    canonicalize,
    normName,
  ]);
  // ---------- breakdown helpers ----------
  const contribForPick = React.useCallback(
    (r) => {
      if (!includeKeepers && r?.keeper) return null;
      const pickLabel = getPickPos(r);
      const finLabel = getFinishPos(r);
      const s = scoreFromPickLabels(pickLabel, finLabel);
      if (s == null) return null;
      return {
        round: r.round ?? "—",
        player: r.player || "Unknown Player",
        adp: fmtADP(r.adp),
        pickPos: pickLabel || "—",
        finishPos: finLabel || "—",
        contrib: s,
      };
    },
    [includeKeepers, getPickPos, getFinishPos, scoreFromPickLabels]
  );

  const openOwnerBreakdownForYear = React.useCallback(
    (owner) => {
      const allRows = (draftWithFinish?.[year] || []).filter((r) => {
        const rawOwner =
          r?.owner ??
          r?.manager ??
          r?.manager_name ??
          r?.ownerName ??
          r?.owner_full ??
          "";
        return ownerDisplay(rawOwner) === ownerDisplay(owner);
      });
      const items = [];
      for (const r of allRows) {
        const c = contribForPick(r);
        if (c) items.push({ key: `${r.player}-${r.round}-${r.overall}`, ...c });
      }
      items.sort((a, b) => Math.abs(b.contrib) - Math.abs(a.contrib));
      setBreakdownTitle(`${ownerDisplay(owner)} — ${year}`);
      setBreakdownRows(items);
      setShowBreakdown(true);
    },
    [draftWithFinish, year, ownerDisplay, contribForPick]
  );

  const openOwnerBreakdownAllYears = React.useCallback(
    (owner) => {
      const items = [];
      for (const yrStr of Object.keys(draftWithFinish || {})) {
        const yr = Number(yrStr);
        for (const r of draftWithFinish[yrStr] || []) {
          const rawOwner =
            r?.owner ??
            r?.manager ??
            r?.manager_name ??
            r?.ownerName ??
            r?.owner_full ??
            "";
          if (ownerDisplay(rawOwner) !== ownerDisplay(owner)) continue;
          const c = contribForPick(r);
          if (!c) continue;
          items.push({
            key: `${yr}-${r.player}-${r.round}-${r.overall}`,
            year: yr,
            ...c,
          });
        }
      }
      items.sort((a, b) => Math.abs(b.contrib) - Math.abs(a.contrib));
      setBreakdownTitle(`${ownerDisplay(owner)} — All years`);
      setBreakdownRows(items);
      setShowBreakdown(true);
    },
    [draftWithFinish, ownerDisplay, contribForPick]
  );

  return (
    <div className="space-y-4">
      <Card
        title="Draft"
        right={
          <div className="flex items-center gap-2">
            <div className="text-sm text-zinc-500">Year:</div>
            <select
              className="px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
              value={year}
              onChange={(e) => setYear(Number(e.target.value))}
            >
              {years.map((y) => (
                <option key={y} value={y}>
                  {y}
                </option>
              ))}
            </select>
          </div>
        }
      >
        <div className="text-xs text-zinc-500 mb-2">
          Showing each manager’s drafted players for {year}. Columns include
          Round, Overall pick,{" "}
          <span className="font-medium">Pick&nbsp;POS</span> (your league’s
          RB/WR/… order), Player, <span className="font-medium">ADP</span>,{" "}
          <span className="font-medium">POS</span> (FantasyPros position rank
          like <em>WR5</em>), Finish (Pos), and Keeper.
        </div>

        {/* controls */}
        <div className="mb-3 flex flex-wrap items-center gap-4">
          <label className="inline-flex items-center gap-2 text-xs">
            <input
              type="checkbox"
              className="checkbox checkbox-sm"
              checked={weighted}
              onChange={(e) => setWeighted(e.target.checked)}
            />
            Weighted
            <span className="opacity-70">(α)</span>
            <input
              type="number"
              step="0.1"
              min="0.1"
              max="1"
              value={alpha}
              onChange={(e) =>
                setAlpha(
                  Math.min(1, Math.max(0.1, Number(e.target.value) || 0.5))
                )
              }
              className="w-14 px-1 py-0.5 rounded border border-zinc-300 dark:border-zinc-700 bg-transparent text-xs"
              title="Weight exponent (lower = softer, higher = steeper)"
            />
          </label>
          <label className="inline-flex items-center gap-2 text-xs">
            <input
              type="checkbox"
              className="checkbox checkbox-sm"
              checked={includeKeepers}
              onChange={(e) => setIncludeKeepers(e.target.checked)}
            />
            Include keepers
          </label>
          <label className="inline-flex items-center gap-2 text-xs">
            <input
              type="checkbox"
              className="checkbox checkbox-sm"
              checked={includeKDst}
              onChange={(e) => setIncludeKDst(e.target.checked)}
            />
            Include K/DST
          </label>
          <button
            type="button"
            className="btn btn-xs ml-auto"
            title="How the Best Drafter score is calculated"
            onClick={() => setShowExplain(true)}
          >
            ℹ️
          </button>
        </div>

        {/* leaderboards */}
        <div className="grid md:grid-cols-2 gap-3 mb-4">
          <div className="rounded-xl border border-zinc-200 dark:border-zinc-800 p-3">
            <div className="text-sm font-semibold mb-2">
              Best Drafter — {year}
            </div>
            <table className="w-full text-sm">
              <thead className="text-xs uppercase opacity-60">
                <tr>
                  <th className="text-left">Owner</th>
                  <th className="text-right">Score</th>
                  <th className="text-right">Picks</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-zinc-200/50 dark:divide-zinc-800/60">
                {bestYearScores.map((r) => (
                  <tr
                    key={r.owner}
                    className="cursor-pointer hover:bg-zinc-100/60 dark:hover:bg-zinc-800/60"
                    onClick={() => openOwnerBreakdownForYear(r.owner)}
                    title="Click for pick-by-pick breakdown"
                  >
                    <td className="py-1.5" title={r.owner}>
                      {ownerDisplay(r.owner)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {weighted ? r.mean.toFixed(3) : r.mean.toFixed(1)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {r.count}
                    </td>
                  </tr>
                ))}
                {bestYearScores.length === 0 && (
                  <tr>
                    <td colSpan={3} className="py-2 text-center opacity-60">
                      No scorable picks this year.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>

          <div className="rounded-xl border border-zinc-200 dark:border-zinc-800 p-3">
            <div className="text-sm font-semibold mb-2">
              Best Drafter — Overall
            </div>
            <div className="text-[11px] text-zinc-500 mb-1">
              Years = total seasons with any draft picks (score averages only
              across seasons that have Finish POS data).
            </div>
            <table className="w-full text-sm">
              <thead className="text-xs uppercase opacity-60">
                <tr>
                  <th className="text-left">Owner</th>
                  <th className="text-right">Score</th>
                  <th className="text-right">Years</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-zinc-200/50 dark:divide-zinc-800/60">
                {bestOverallScores.map((r) => (
                  <tr
                    key={r.owner}
                    className="cursor-pointer hover:bg-zinc-100/60 dark:hover:bg-zinc-800/60"
                    onClick={() => openOwnerBreakdownAllYears(r.owner)}
                    title="Click for pick-by-pick breakdown"
                  >
                    <td className="py-1.5" title={r.owner}>
                      {ownerDisplay(r.owner)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {weighted ? r.mean.toFixed(3) : r.mean.toFixed(1)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {r.years}
                    </td>
                  </tr>
                ))}
                {bestOverallScores.length === 0 && (
                  <tr>
                    <td colSpan={3} className="py-2 text-center opacity-60">
                      No seasons found.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>
        {/* Drafted points contribution */}
        <div className="grid md:grid-cols-2 gap-3 mb-4">
          {/* Per-season (single year) or ALL YEARS total, plus optional specific week */}
          <div className="rounded-xl border border-zinc-200 dark:border-zinc-800 p-3">
            <div className="flex items-center justify-between mb-2">
              <div className="text-sm font-semibold">
                Drafted Points — {dpIsAllYears ? "All Years" : dpYear}
                {!dpIsAllYears && week ? ` (Week ${week})` : ""}
              </div>

              <div className="flex items-center gap-2 text-xs">
                <span className="text-zinc-500">Year:</span>
                <select
                  className="px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
                  value={dpYear}
                  onChange={(e) => setDpYear(e.target.value)}
                >
                  <option value="ALL">All Years</option>
                  {years.map((y) => (
                    <option key={y} value={String(y)}>
                      {y}
                    </option>
                  ))}
                </select>

                {!dpIsAllYears && (
                  <>
                    <span className="text-zinc-500">Week:</span>
                    <select
                      className="px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
                      value={week}
                      onChange={(e) => setWeek(Number(e.target.value))}
                    >
                      <option value={0}>All Weeks</option>
                      {availableWeeks.map((w) => (
                        <option key={w} value={w}>
                          Week {w}
                        </option>
                      ))}
                    </select>
                  </>
                )}
              </div>
            </div>

            <table className="w-full text-sm">
              <thead className="text-xs uppercase opacity-60">
                <tr>
                  <th className="text-left">Owner</th>
                  <th className="text-right">Drafted Pts</th>
                  <th className="text-right">Team Pts</th>
                  <th className="text-right">% of Team</th>
                </tr>
              </thead>

              <tbody className="divide-y divide-zinc-200/50 dark:divide-zinc-800/60">
                {(dpIsAllYears
                  ? draftedPoints.totals
                  : week
                  ? draftedPoints.perWeek.filter(
                      (r) =>
                        r.year === Number(dpYear) && r.week === Number(week)
                    )
                  : draftedPoints.perSeason.filter(
                      (r) => r.year === Number(dpYear)
                    )
                )
                  .sort((a, b) => (b.pct ?? -1) - (a.pct ?? -1))
                  .map((r) => (
                    <tr
                      key={`${r.owner}-${dpIsAllYears ? "ALL" : r.year}${
                        r.week ? `-w${r.week}` : ""
                      }`}
                    >
                      <td className="py-1.5" title={r.owner}>
                        {ownerDisplay(r.owner)}
                      </td>
                      <td className="py-1.5 text-right tabular-nums">
                        {fmtPts(r.draftedPts)}
                      </td>
                      <td className="py-1.5 text-right tabular-nums">
                        {fmtPts(r.teamPts)}
                      </td>
                      <td className="py-1.5 text-right tabular-nums">
                        {fmtPct(r.pct)}
                      </td>
                    </tr>
                  ))}

                {(dpIsAllYears
                  ? draftedPoints.totals
                  : week
                  ? draftedPoints.perWeek.filter(
                      (r) =>
                        r.year === Number(dpYear) && r.week === Number(week)
                    )
                  : draftedPoints.perSeason.filter(
                      (r) => r.year === Number(dpYear)
                    )
                ).length === 0 && (
                  <tr>
                    <td colSpan={4} className="py-2 text-center opacity-60">
                      No drafted-points data for this selection.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>

            <div className="mt-2 text-[11px] text-zinc-500">
              Based on weekly starter lineups (bench/IR excluded). Keepers obey
              the toggle above.
            </div>
          </div>

          {/* Totals across all seasons */}
          <div className="rounded-xl border border-zinc-200 dark:border-zinc-800 p-3">
            <div className="text-sm font-semibold mb-2">
              Drafted Points — Totals (All Years)
            </div>
            <table className="w-full text-sm">
              <thead className="text-xs uppercase opacity-60">
                <tr>
                  <th className="text-left">Owner</th>
                  <th className="text-right">Drafted Pts</th>
                  <th className="text-right">Team Pts</th>
                  <th className="text-right">% of Team</th>
                  <th className="text-right">Seasons</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-zinc-200/50 dark:divide-zinc-800/60">
                {draftedPoints.totals.map((r) => (
                  <tr key={r.owner}>
                    <td className="py-1.5" title={r.owner}>
                      {ownerDisplay(r.owner)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {fmtPts(r.draftedPts)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {fmtPts(r.teamPts)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {fmtPct(r.pct)}
                    </td>
                    <td className="py-1.5 text-right tabular-nums">
                      {r.seasons}
                    </td>
                  </tr>
                ))}
                {draftedPoints.totals.length === 0 && (
                  <tr>
                    <td colSpan={5} className="py-2 text-center opacity-60">
                      No seasons found.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>

        {/* Help modal */}
        {showExplain && (
          <div className="fixed inset-0 z-50 flex items-center justify-center">
            <div
              className="absolute inset-0 bg-black/50"
              onClick={() => setShowExplain(false)}
            />
            <div className="relative w-full max-w-lg rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-xl max-h-[85vh] flex flex-col">
              <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 sticky top-0 bg-white dark:bg-zinc-900 z-10">
                <div className="text-base font-semibold">
                  Best Drafter — How it’s calculated
                </div>
                <button
                  className="btn btn-xs"
                  onClick={() => setShowExplain(false)}
                >
                  Close
                </button>
              </div>
              <div className="text-sm space-y-3 p-4 overflow-y-auto flex-1">
                <p>
                  <strong>Per pick:</strong> (PickRank − FinishRank)
                  {weighted ? " ÷ PickRank^α" : ""}, with ranks capped at ±40.
                  Positive is good; negative is bad. K/DST and Keepers obey the
                  toggles above.
                </p>
                <p>
                  <strong>Owner score:</strong> mean of pick contributions (with
                  your current filters). The Overall table shows <em>Years</em>{" "}
                  = all seasons where that manager made any picks; score still
                  averages only seasons that have Finish POS data available.
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Breakdown modal */}
        {showBreakdown && (
          <div className="fixed inset-0 z-50 flex items-center justify-center">
            <div
              className="absolute inset-0 bg-black/50"
              onClick={() => setShowBreakdown(false)}
            />
            <div className="relative w-full max-w-3xl rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-xl max-h-[85vh] flex flex-col">
              <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 sticky top-0 bg-white dark:bg-zinc-900 z-10">
                <div className="text-base font-semibold">{breakdownTitle}</div>
                <button
                  className="btn btn-xs"
                  onClick={() => setShowBreakdown(false)}
                >
                  Close
                </button>
              </div>

              <div className="p-3 text-xs text-zinc-500">
                Contribution = (Pick POS rank − Finish POS rank)
                {weighted ? (
                  <>
                    {" "}
                    ÷ (Pick POS rank<sup>{alpha}</sup>)
                  </>
                ) : null}
                {includeKDst ? null : "  • K/DST excluded"}
                {!includeKeepers ? "  • Keepers excluded" : null}
              </div>

              <div className="px-3 pb-3">
                <div className="overflow-auto rounded-lg border border-zinc-200 dark:border-zinc-800 max-h-[60vh]">
                  <table className="w-full text-sm">
                    <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
                      <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
                        {breakdownRows.some((r) => r.year) && (
                          <th className="px-3 py-2 text-left w-[68px]">Year</th>
                        )}
                        <th className="px-3 py-2 text-left w-[56px]">Rd</th>
                        <th className="px-3 py-2 text-left">Player</th>
                        <th className="px-3 py-2 text-center w-[70px]">ADP</th>
                        <th className="px-3 py-2 text-center w-[90px]">
                          Pick POS
                        </th>
                        <th className="px-3 py-2 text-center w-[110px]">
                          Finish POS
                        </th>
                        <th className="px-3 py-2 text-right w-[110px]">
                          Contribution
                        </th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-zinc-200 dark:divide-zinc-800">
                      {breakdownRows.map((r) => {
                        const color =
                          r.contrib > 0
                            ? "text-emerald-600"
                            : r.contrib < 0
                            ? "text-rose-600"
                            : "text-zinc-500";
                        return (
                          <tr
                            key={r.key}
                            className="[&:hover]:bg-zinc-100 dark:[&:hover]:bg-zinc-800"
                          >
                            {r.year && <td className="px-3 py-2">{r.year}</td>}
                            <td className="px-3 py-2">{r.round}</td>
                            <td className="px-3 py-2">{r.player}</td>
                            <td className="px-3 py-2 text-center tabular-nums">
                              {r.adp}
                            </td>
                            <td className="px-3 py-2 text-center">
                              {r.pickPos}
                            </td>
                            <td className="px-3 py-2 text-center">
                              {r.finishPos}
                            </td>
                            <td
                              className={`px-3 py-2 text-right tabular-nums font-medium ${
                                r.contrib > 0
                                  ? "text-emerald-600"
                                  : r.contrib < 0
                                  ? "text-rose-600"
                                  : "text-zinc-500"
                              }`}
                            >
                              {weighted
                                ? r.contrib.toFixed(3)
                                : r.contrib.toFixed(1)}
                            </td>
                          </tr>
                        );
                      })}
                      {breakdownRows.length === 0 && (
                        <tr>
                          <td
                            colSpan={7}
                            className="px-3 py-8 text-center text-zinc-500"
                          >
                            No scorable picks with current filters.
                          </td>
                        </tr>
                      )}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        )}

        {groupByOwner(rows).map(({ owner, picks }) => (
          <div key={owner} className="mb-6">
            <button
              type="button"
              className="text-base font-medium mb-2 hover:underline hover:opacity-90"
              title="Show pick-by-pick breakdown"
              onClick={() => openOwnerBreakdownForYear(owner)}
            >
              {ownerDisplay(owner)}
            </button>
            <div className="overflow-x-auto rounded-xl border border-zinc-200 dark:border-zinc-800">
              <table className="w-full text-sm">
                <thead className="bg-zinc-50 dark:bg-zinc-800">
                  <tr className="border-b-2 border-zinc-300 dark:border-zinc-700">
                    <th className="px-3 py-2 text-left w-[56px]">Rd</th>
                    <th className="px-3 py-2 text-left w-[88px]">Overall</th>
                    <th className="px-3 py-2 text-left w-[90px]">
                      Pick&nbsp;POS
                    </th>
                    <th className="px-3 py-2 text-left">Player</th>
                    <th className="px-3 py-2 text-center w-[90px]">ADP</th>
                    <th className="px-3 py-2 text-center w-[90px]">POS</th>
                    <th className="px-3 py-2 text-center w-[120px]">
                      Finish (Pos)
                    </th>
                    <th className="px-3 py-2 text-center w-[90px]">Keeper</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-zinc-200 dark:divide-zinc-800 [&>tr:nth-child(odd)]:bg-zinc-50 dark:[&>tr:nth-child(odd)]:bg-zinc-900">
                  {picks.map((r, i) => (
                    <tr
                      key={i}
                      className="[&:hover]:bg-zinc-100 dark:[&:hover]:bg-zinc-800"
                    >
                      <td className="px-3 py-2">{r.round ?? "—"}</td>
                      <td className="px-3 py-2">{r.overall ?? "—"}</td>
                      <td className="px-3 py-2">{getPickPos(r)}</td>
                      <td className="px-3 py-2">
                        <div className="font-medium">
                          {r.player || "Unknown Player"}
                        </div>
                        <div className="text-xs text-zinc-500">
                          {getUnderName(r)}
                        </div>
                      </td>
                      <td className="px-3 py-2 text-center">{fmtADP(r.adp)}</td>
                      <td className="px-3 py-2 text-center">{getPos(r)}</td>
                      <td className="px-3 py-2 text-center">
                        {getFinishPos(r)}
                      </td>
                      <td className="px-3 py-2 text-center">
                        {r.keeper ? "Yes" : "No"}
                      </td>
                    </tr>
                  ))}
                  {picks.length === 0 && (
                    <tr>
                      <td
                        colSpan={8}
                        className="px-3 py-8 text-center text-zinc-500"
                      >
                        No draft picks found for {owner}.
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>
        ))}
      </Card>
    </div>
  );
}

/* ---------------- PlayoffProbTab — Prob of making playoffs by record after week N -------- */
export function PlayoffProbTab({
  league,
  playoffTeamsBase = {},
  playoffTeamsOverrides = {},
}) {
  if (!league) return null;
  const owners = league.owners || [];
  const seasonsAll = league.seasonsAll || [];
  const mergedPlayoffTeams = React.useMemo(() => {
    const out = {};
    seasonsAll.forEach((yr) => {
      const base = Number(playoffTeamsBase?.[yr] ?? 0) || 0;
      const ovrd = Number(playoffTeamsOverrides?.[yr] ?? 0) || 0;
      out[yr] = ovrd || base || 0;
    });
    return out;
  }, [seasonsAll, playoffTeamsBase, playoffTeamsOverrides]);
  const [strictWeekGames, setStrictWeekGames] = React.useState(true);
  const completedSeasons = React.useMemo(() => {
    const set = new Set();
    (owners || []).forEach((o) => {
      const bySeason = league.placementMap?.[o] || {};
      Object.entries(bySeason).forEach(([yrStr, p]) => {
        const yr = Number(yrStr);
        if (yr && Number.isFinite(Number(p))) set.add(yr);
      });
    });
    return set;
  }, [owners, league.placementMap]);
  const madePO = React.useMemo(() => {
    const map = new Map(); // key: "owner__year" -> boolean
    (owners || []).forEach((o) => {
      const bySeason = league.placementMap?.[o] || {};
      Object.entries(bySeason).forEach(([yrStr, place]) => {
        const yr = Number(yrStr);
        if (!completedSeasons.has(yr)) return;
        const poCnt = Number(mergedPlayoffTeams?.[yr] || 0);
        if (!poCnt) return; // skip seasons we don't know playoff count for
        const made = Number(place) > 0 && Number(place) <= poCnt;
        map.set(`${o}__${yr}`, made);
      });
    });
    return map;
  }, [owners, league.placementMap, completedSeasons, mergedPlayoffTeams]);
  const { perOwnerSeasonWeek, maxWeekByYear } = React.useMemo(() => {
    const m = new Map(); // "owner__year" -> Map(week -> {w,l,t})
    const maxByYr = new Map(); // year -> max regular-season week seen
    for (const g of league.games || []) {
      const yr = Number(g?.season);
      const wk = Number(g?.week);
      if (!Number.isFinite(yr) || !Number.isFinite(wk)) continue;
      if (!completedSeasons.has(yr)) continue;
      if (!mergedPlayoffTeams?.[yr]) continue;
      if (g?.is_playoff === true) continue;
      const owner = g?.owner;
      const res = String(g?.res || "").toUpperCase();
      if (!owner || !res) continue;
      const key = `${owner}__${yr}`;
      if (!m.has(key)) m.set(key, new Map());
      const wkMap = m.get(key);
      if (!wkMap.has(wk)) wkMap.set(wk, { w: 0, l: 0 });
      const slot = wkMap.get(wk);
      if (res === "W") slot.w += 1;
      else if (res === "L") slot.l += 1;
      const prevMax = maxByYr.get(yr) || 0;
      if (wk > prevMax) maxByYr.set(yr, wk);
    }
    return { perOwnerSeasonWeek: m, maxWeekByYear: maxByYr };
  }, [league.games, completedSeasons, mergedPlayoffTeams]);
  const { aggAll, aggByGames, examplesAll, examplesByGames } =
    React.useMemo(() => {
      const aggAll = new Map(); // week -> Map(recordKey -> {made,total})
      const aggByGames = new Map(); // week -> Map(gamesPlayed -> Map(recordKey -> {made,total}))
      const examplesAll = new Map(); // week -> Map(recordKey -> Array<{owner,year,finalRec}>)
      const examplesByGames = new Map(); // week -> Map(gamesPlayed -> Map(recordKey -> Array<...>))
      const bumpAll = (week, key, made) => {
        if (!aggAll.has(week)) aggAll.set(week, new Map());
        const m = aggAll.get(week);
        const row = m.get(key) || { made: 0, total: 0 };
        row.total += 1;
        if (made) row.made += 1;
        m.set(key, row);
      };
      const bumpBy = (week, games, key, made) => {
        if (!aggByGames.has(week)) aggByGames.set(week, new Map());
        const gm = aggByGames.get(week);
        if (!gm.has(games)) gm.set(games, new Map());
        const recMap = gm.get(games);
        const row = recMap.get(key) || { made: 0, total: 0 };
        row.total += 1;
        if (made) row.made += 1;
        recMap.set(key, row);
      };
      const pushExAll = (week, key, item) => {
        if (!examplesAll.has(week)) examplesAll.set(week, new Map());
        const m = examplesAll.get(week);
        if (!m.has(key)) m.set(key, []);
        m.get(key).push(item);
      };
      const pushExBy = (week, games, key, item) => {
        if (!examplesByGames.has(week)) examplesByGames.set(week, new Map());
        const gm = examplesByGames.get(week);
        if (!gm.has(games)) gm.set(games, new Map());
        const recMap = gm.get(games);
        if (!recMap.has(key)) recMap.set(key, []);
        recMap.get(key).push(item);
      };
      perOwnerSeasonWeek.forEach((wkMap, ownerSeasonKey) => {
        const made = madePO.get(ownerSeasonKey);
        if (made === undefined) return;
        const [owner, yrStr] = ownerSeasonKey.split("__");
        const year = Number(yrStr);
        let Wfin = 0,
          Lfin = 0;
        wkMap.forEach((slot) => {
          Wfin += slot.w;
          Lfin += slot.l;
        });
        const finalRec = `${Wfin}-${Lfin}`;
        const weeks = Array.from(wkMap.keys()).sort((a, b) => a - b);
        let W = 0,
          L = 0;
        for (const w of weeks) {
          const slot = wkMap.get(w);
          W += slot.w;
          L += slot.l;
          const gamesPlayed = W + L; // strict filter key (no ties)
          const recKey = `${W}-${L}`;
          bumpAll(w, recKey, made === true);
          bumpBy(w, gamesPlayed, recKey, made === true);
          const item = { owner, year, finalRec, made: made === true }; // <- add Y/N flag
          pushExAll(w, recKey, item);
          pushExBy(w, gamesPlayed, recKey, item);
        }
      });
      return { aggAll, aggByGames, examplesAll, examplesByGames };
    }, [perOwnerSeasonWeek, madePO]);
  const weeksSorted = React.useMemo(() => {
    const s = new Set([...aggAll.keys(), ...aggByGames.keys()]);
    return Array.from(s).sort((a, b) => a - b);
  }, [aggAll, aggByGames]);
  const sortRecordKeys = (a, b) => {
    const [aw, al] = a.split("-").map(Number);
    const [bw, bl] = b.split("-").map(Number);
    if (aw !== bw) return bw - aw; // more wins first
    if (al !== bl) return al - bl; // fewer losses next
    return 0;
  };
  const getRecMapForWeek = React.useCallback(
    (wk) =>
      strictWeekGames
        ? aggByGames.get(wk)?.get(wk) || new Map() // exactly N games after week N
        : aggAll.get(wk) || new Map(), // any games after week N
    [strictWeekGames, aggByGames, aggAll]
  );
  const [selectedWeek, setSelectedWeek] = React.useState(() => {
    return weeksSorted.length ? weeksSorted[weeksSorted.length - 1] : null;
  });
  React.useEffect(() => {
    if (!weeksSorted.length) return;
    if (!weeksSorted.includes(selectedWeek)) {
      setSelectedWeek(weeksSorted[weeksSorted.length - 1]);
    }
  }, [weeksSorted, selectedWeek]);
  const currentRecMap = React.useMemo(
    () => (selectedWeek != null ? getRecMapForWeek(selectedWeek) : new Map()),
    [getRecMapForWeek, selectedWeek]
  );
  const currentKeys = React.useMemo(
    () => Array.from(currentRecMap.keys()).sort(sortRecordKeys),
    [currentRecMap]
  );
  const [detail, setDetail] = React.useState(null);
  React.useEffect(() => {
    if (!detail) return;
    const el = document.getElementById(
      `pp-detail-${detail.week}-${detail.record}`
    );
    if (el) el.scrollIntoView({ behavior: "smooth", block: "start" });
  }, [detail]);
  const detailRows = React.useMemo(() => {
    if (!detail) return [];
    const { week, record } = detail;
    return strictWeekGames
      ? examplesByGames.get(week)?.get(week)?.get(record) || []
      : examplesAll.get(week)?.get(record) || [];
  }, [detail, strictWeekGames, examplesAll, examplesByGames]);
  const detailStat = React.useMemo(() => {
    if (!detail) return null;
    const recMap = strictWeekGames
      ? aggByGames.get(detail.week)?.get(detail.week) || new Map()
      : aggAll.get(detail.week) || new Map();
    const stat = recMap.get(detail.record);
    if (!stat) return null;
    const { made, total } = stat;
    const pct = total ? Math.round((made / total) * 100) : null;
    return { made, total, pct };
  }, [detail, strictWeekGames, aggAll, aggByGames]);
  const pctToBarColor = (p) => {
    if (p == null) return "hsl(0, 0%, 75%)"; // no data, light gray
    if (p === 0.5) return "hsl(0, 0%, 60%)"; // mid gray
    if (p > 0.5) {
      const t = Math.min(1, (p - 0.5) / 0.5); // 0..1 over 50..100
      const light = 60 - t * 25; // 60% -> 35% (darker = stronger)
      return `hsl(120, 70%, ${light}%)`; // green
    }
    const t = Math.min(1, (0.5 - p) / 0.5); // 0..1 over 50..0
    const light = 60 - t * 25; // 60% -> 35%
    return `hsl(0, 70%, ${light}%)`; // red
  };
  if (!weeksSorted.length) {
    return (
      <div className="rounded-xl bg-white dark:bg-zinc-900 p-4 shadow">
        <h2 className="text-lg font-semibold mb-2">
          Playoff Probability by Record
        </h2>
        <p className="text-sm opacity-70">
          No data yet. This view only includes completed seasons where the
          number of playoff teams is known (from ESPN or your overrides) and
          uses regular-season games only.
        </p>
      </div>
    );
  }
  return (
    <div className="space-y-4">
      <div className="rounded-xl bg-white dark:bg-zinc-900 p-4 shadow">
        <h2 className="text-lg font-semibold">Playoff Probability by Record</h2>
        <p className="text-sm opacity-70">
          For each week N, this shows the probability of making the playoffs
          conditional on the record after week N. Records are built from
          regular-season games only (playoffs excluded), and a playoff
          appearance is determined by placement ≤ the playoff-team count for
          that season.
        </p>
        {/* (5) toggle: only show records with N games after week N */}
        <div className="mt-3">
          <label className="inline-flex items-center gap-2 text-sm">
            <input
              type="checkbox"
              className="checkbox checkbox-sm"
              checked={strictWeekGames}
              onChange={(e) => setStrictWeekGames(e.target.checked)}
            />
            Exclude Bye Weeks
          </label>
        </div>
        {/* BAR CHART */}
        <div className="rounded-xl bg-white dark:bg-zinc-900 p-4 shadow">
          <div className="mb-3 flex items-center justify-between gap-3">
            <div className="text-base font-semibold">
              Playoff Odds by Record
            </div>
            <div className="flex items-center gap-3">
              <label className="text-sm opacity-70">Week</label>
              <select
                className="select select-sm"
                value={selectedWeek ?? ""}
                onChange={(e) => setSelectedWeek(Number(e.target.value))}
              >
                {weeksSorted.map((w) => (
                  <option key={w} value={w}>
                    {w}
                  </option>
                ))}
              </select>
            </div>
          </div>
          <div className="h-64">
            <div className="flex items-end gap-3 h-full">
              {currentKeys.map((k) => {
                const { made, total } = currentRecMap.get(k) || {
                  made: 0,
                  total: 0,
                };
                const p = total ? made / total : null;
                const pctLabel = p == null ? "—" : `${Math.round(p * 100)}%`;
                const h = p == null ? 0 : Math.max(2, Math.round(p * 100)); // 0..100%, min 2px
                return (
                  <div
                    key={k}
                    className="flex flex-col items-center w-12 h-full"
                  >
                    {/* rail with definite height so the % bar can size correctly */}
                    <div className="h-full flex items-end">
                      <div
                        className="w-8 rounded-md transition-all"
                        style={{
                          height: `${h}%`,
                          backgroundColor: pctToBarColor(p),
                        }}
                        title={
                          p == null
                            ? "No data"
                            : `${pctLabel} (${made}/${total})`
                        }
                      />
                    </div>
                    <div className="mt-1 text-xs font-semibold">{k}</div>
                    <div className="text-[11px] opacity-70">{pctLabel}</div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      </div>
      {weeksSorted.map((wk) => {
        const recMap = strictWeekGames
          ? aggByGames.get(wk)?.get(wk) || new Map() // exactly N games after week N
          : aggAll.get(wk) || new Map(); // all records after week N
        const keys = Array.from(recMap.keys()).sort(sortRecordKeys);
        return (
          <div
            key={`week-${wk}`}
            className="rounded-xl bg-white dark:bg-zinc-900 p-4 shadow"
          >
            <div className="text-base font-semibold mb-3">Week {wk}</div>
            <div className="flex flex-wrap gap-3">
              {keys.map((k) => {
                const { made, total } = recMap.get(k);
                const pct = total ? Math.round((made / total) * 100) : 0;
                return (
                  <div
                    key={k}
                    onClick={() => setDetail({ week: wk, record: k })}
                    className="px-3 py-2 rounded-lg bg-zinc-100 dark:bg-zinc-800 cursor-pointer hover:ring-2 hover:ring-zinc-400/40"
                  >
                    <div className="text-sm font-semibold">{k}</div>
                    <div className="text-xs opacity-70">
                      {pct}% ({made}/{total})
                    </div>
                  </div>
                );
              })}
            </div>
            {detail && detail.week === wk && (
              <div
                id={`pp-detail-${wk}-${detail.record}`}
                className="mt-3 rounded-xl bg-white dark:bg-zinc-900 p-4 shadow"
              >
                <div className="mb-2 flex items-center justify-between">
                  <div className="font-semibold">
                    Week {detail.week} — {detail.record}
                    {detailStat && (
                      <span className="ml-2 text-sm font-normal opacity-75">
                        • {detailStat.pct}% ({detailStat.made}/
                        {detailStat.total})
                      </span>
                    )}
                  </div>
                  <button
                    className="btn btn-xs"
                    onClick={() => setDetail(null)}
                  >
                    Close
                  </button>
                </div>
                {detailRows.length ? (
                  <>
                    {/* header row for alignment */}
                    <div
                      className="px-1 pb-1 text-xs uppercase opacity-60 grid
                        [grid-template-columns:minmax(0,1fr)_72px_84px_86px]"
                    >
                      <div>Manager</div>
                      <div className="text-right">Year</div>
                      <div className="text-right">Finish</div>
                      <div className="text-center">Made PO</div>
                    </div>
                    <ul className="text-sm divide-y divide-zinc-200/30 dark:divide-zinc-700/40">
                      {detailRows.map((r, i) => (
                        <li
                          key={i}
                          className="py-1.5 grid items-center
                         [grid-template-columns:minmax(0,1fr)_72px_84px_86px]"
                        >
                          <div className="font-medium truncate">{r.owner}</div>
                          <div className="text-right tabular-nums">
                            {r.year}
                          </div>
                          <div className="text-right font-mono">
                            {r.finalRec}
                          </div>
                          <div className="text-center">
                            {r.made ? "Y" : "N"}
                          </div>
                        </li>
                      ))}
                    </ul>
                  </>
                ) : (
                  <div className="text-sm opacity-70">No teams matched.</div>
                )}
              </div>
            )}
          </div>
        );
      })}
    </div>
  );
}
// ================== WeeklyOutlookTab ==================
export function WeeklyOutlookTab({
  league,
  seasonThisYear,
  playoffTeamsBase = {},
  playoffTeamsOverrides = {},
  scheduleThisYear = [],
}) {
  if (!league) return null;
  React.useEffect(() => {
    const aliases = window.__FL_ALIASES || {};
    primeOwnerMaps({
      league,
      selectedLeague: league,
      espnOwnerByTeamByYear: league.ownerByTeamByYear || {},
      manualAliases: aliases,
    });
  }, [league]);
  // Canonicalize owner display names everywhere (same as Trades/Draft tabs)
  const canonicalize =
    (typeof window !== "undefined" &&
      window.__ownerMaps &&
      typeof window.__ownerMaps.canon === "function" &&
      window.__ownerMaps.canon.bind(window.__ownerMaps)) ||
    ((s) => (s == null ? "" : String(s)));

  // ---------- tiny helpers ----------
  const pickNum = (...vals) => {
    for (const v of vals) {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
    return null;
  };
  const owners = league.owners || [];
  const seasonsAll = league.seasonsAll || [];
  // Render an owner name on exactly two lines: first word, then the rest.
  // No ellipses; if the second line is too long it clips cleanly.
  const OwnerTwoLine = ({ name }) => {
    const parts = String(name || "")
      .trim()
      .split(/\s+/);
    const first = parts.shift() || "";
    const second = parts.join(" ");
    return (
      <span className="flex flex-col leading-tight text-[13px]">
        <span className="whitespace-nowrap overflow-hidden">{first}</span>
        <span className="whitespace-nowrap overflow-hidden">{second}</span>
      </span>
    );
  };

  // Render exactly two lines: FIRST on line 1, LAST on line 2 (no third line)
  const NameTwoLine = ({ name, className = "" }) => {
    const parts = String(name || "")
      .trim()
      .split(/\s+/);
    const first = parts[0] || "";
    const last = parts.length > 1 ? parts[parts.length - 1] : "";
    return (
      <div className={`leading-tight ${className}`}>
        <div className="whitespace-nowrap overflow-hidden">{first}</div>
        <div className="whitespace-nowrap overflow-hidden">{last}</div>
      </div>
    );
  };
  // Auto-fit: first name on line 1, last name on line 2. Shrinks font until both lines fit.
  const AutoFitTwoLine = ({ name, className = "", maxPx = 22, minPx = 12 }) => {
    const ref = React.useRef(null);

    // split once so we only render First + Last
    const parts = String(name || "")
      .trim()
      .split(/\s+/);
    const first = parts[0] || "";
    const last = parts.length > 1 ? parts[parts.length - 1] : "";

    const fit = React.useCallback(() => {
      const el = ref.current;
      if (!el) return;
      const firstEl = el.querySelector(".fit-first");
      const lastEl = el.querySelector(".fit-last");
      if (!firstEl || !lastEl) return;

      // start at max, reduce until both lines are <= container width
      let s = maxPx;
      el.style.fontSize = `${s}px`;
      const containerW = el.clientWidth || 0;

      const tooWide = () =>
        firstEl.scrollWidth > containerW || lastEl.scrollWidth > containerW;

      while (s > minPx && tooWide()) {
        s -= 0.5;
        el.style.fontSize = `${s}px`;
      }
    }, [name, maxPx, minPx]);

    React.useLayoutEffect(() => {
      const el = ref.current;
      if (!el) return;
      fit();
      const ro = new ResizeObserver(() => fit());
      ro.observe(el);
      return () => ro.disconnect();
    }, [fit]);

    return (
      <div
        ref={ref}
        className={`leading-tight ${className}`}
        style={{ lineHeight: 1.05 }}
      >
        <div className="fit-first whitespace-nowrap">{first}</div>
        <div className="fit-last  whitespace-nowrap">{last}</div>
      </div>
    );
  };
  // ---------- current year / week (no hardcoding) ----------
  const currentYear = React.useMemo(() => {
    const yr = Number(seasonThisYear?.year);
    if (Number.isFinite(yr)) return yr;
    const yrs = Array.from(
      new Set(
        (league?.games || [])
          .map((g) => Number(g?.season))
          .filter(Number.isFinite)
      )
    );
    return yrs.length ? Math.max(...yrs) : new Date().getFullYear();
  }, [seasonThisYear, league?.games]);

  const currentWeek = React.useMemo(() => {
    const wk = Number(seasonThisYear?.currentWeek);
    if (Number.isFinite(wk) && wk > 0) return wk;
    const weeks = (league?.games || [])
      .filter((g) => Number(g?.season) === Number(currentYear))
      .map((g) => Number(g?.week))
      .filter(Number.isFinite);
    return weeks.length ? Math.max(...weeks) : 1;
  }, [seasonThisYear, league?.games, currentYear]);
  // Inline computed styles into a deep clone of a node (so the SVG has everything it needs)
  function cloneWithInlineStyles(root, { filter } = {}) {
    const doc = root.ownerDocument;
    const clone = root.cloneNode(true);

    const walk = (src, dst) => {
      if (filter && filter(src) === false) {
        dst.remove(); // drop ignored nodes
        return;
      }
      // copy computed styles
      const cs = getComputedStyle(src);
      // Some critical properties that affect rendering
      const props = [
        "all",
        "appearance",
        "background",
        "background-color",
        "background-image",
        "background-position",
        "background-size",
        "background-repeat",
        "border",
        "border-radius",
        "box-shadow",
        "color",
        "display",
        "filter",
        "flex",
        "flex-direction",
        "font",
        "font-family",
        "font-size",
        "font-weight",
        "font-style",
        "gap",
        "grid",
        "height",
        "isolation",
        "justify-content",
        "letter-spacing",
        "line-height",
        "margin",
        "opacity",
        "outline",
        "overflow",
        "padding",
        "position",
        "text-shadow",
        "text-transform",
        "transform",
        "transform-origin",
        "white-space",
        "width",
        "word-break",
        "z-index",
      ];
      const style = dst.style;
      props.forEach((p) => {
        const v = cs.getPropertyValue(p);
        if (v) style.setProperty(p, v, cs.getPropertyPriority(p));
      });

      // ensure images/fonts can load
      if (dst.tagName === "IMG") {
        // if cross-origin images cause tainting, you can also filter them out via the filter() option
        dst.setAttribute("crossorigin", "anonymous");
      }

      // recurse
      const srcKids = src.childNodes || [];
      const dstKids = dst.childNodes || [];
      for (let i = 0; i < srcKids.length; i++) {
        if (!dstKids[i]) continue;
        if (srcKids[i].nodeType === 1) walk(srcKids[i], dstKids[i]); // ELEMENT_NODE
      }
    };

    walk(root, clone);
    return clone;
  }

  // Render an element to PNG using SVG <foreignObject> + canvas
  async function exportElementToPNG(
    node,
    { pixelRatio = 2, backgroundColor = "#ffffff", filter } = {}
  ) {
    const rect = node.getBoundingClientRect();
    const width = Math.ceil(rect.width);
    const height = Math.ceil(rect.height);

    // Deep clone with inline styles
    const cloned = cloneWithInlineStyles(node, { filter });

    // Force a solid background so the PNG isn’t transparent in dark mode
    cloned.style.background = backgroundColor;

    // Wrap in a container that fixes relative positioning contexts
    const wrapper = document.createElement("div");
    wrapper.style.width = `${width}px`;
    wrapper.style.height = `${height}px`;
    wrapper.style.position = "relative";
    wrapper.style.isolation = "isolate"; // prevent blending glitches
    wrapper.appendChild(cloned);

    // Build SVG with foreignObject
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttribute("width", String(width));
    svg.setAttribute("height", String(height));
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);

    const fo = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "foreignObject"
    );
    fo.setAttribute("x", "0");
    fo.setAttribute("y", "0");
    fo.setAttribute("width", String(width));
    fo.setAttribute("height", String(height));
    fo.appendChild(wrapper);
    svg.appendChild(fo);

    // Serialize SVG to data URL
    const serializer = new XMLSerializer();
    const svgStr = serializer.serializeToString(svg);
    const svgDataUrl =
      "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgStr);

    // Draw to canvas
    const img = new Image();
    img.decoding = "async";
    img.crossOrigin = "anonymous";
    await new Promise((res, rej) => {
      img.onload = () => res();
      img.onerror = (e) => rej(e);
      img.src = svgDataUrl;
    });

    const canvas = document.createElement("canvas");
    canvas.width = Math.max(1, Math.floor(width * pixelRatio));
    canvas.height = Math.max(1, Math.floor(height * pixelRatio));
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    // fill bg
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    return canvas.toDataURL("image/png");
  }

  // Screenshot: capture target + handler (robust clone-in-place + html2canvas)
  // Screenshot: capture target + handler (clone + targeted color normalization)
  const captureRef = React.useRef(null);

  const onSnap = React.useCallback(async () => {
    try {
      const node = captureRef.current;
      if (!node) return;

      // fonts first to avoid reflow in the clone
      try {
        await document.fonts?.ready;
      } catch {}

      const { default: html2canvas } = await import("html2canvas");

      const dark =
        document.documentElement.classList.contains("dark") ||
        window.matchMedia?.("(prefers-color-scheme: dark)")?.matches;

      // off-screen wrapper with same width as live node
      const rect = node.getBoundingClientRect();
      const wrapper = document.createElement("div");
      wrapper.style.position = "fixed";
      wrapper.style.left = "-100000px";
      wrapper.style.top = "0";
      wrapper.style.width = `${Math.ceil(rect.width)}px`;
      wrapper.style.pointerEvents = "none";
      wrapper.style.background = dark ? "rgb(17,17,20)" : "rgb(255,255,255)";
      document.body.appendChild(wrapper);

      // deep clone into wrapper so browser lays it out naturally
      const clone = node.cloneNode(true);
      wrapper.appendChild(clone);

      // targeted OKLCH → RGB normalization (preserve other styling)
      const ctx = document.createElement("canvas").getContext("2d");
      const toRGB = (val) => {
        if (!val) return val;
        try {
          ctx.fillStyle = "#000";
          ctx.fillStyle = val;
          return ctx.fillStyle;
        } catch {
          return val;
        }
      };
      const hasOK = (s) => typeof s === "string" && /okl(ch|ab)/i.test(s);
      const COLOR_PROPS = [
        "color",
        "backgroundColor",
        "borderColor",
        "borderTopColor",
        "borderRightColor",
        "borderBottomColor",
        "borderLeftColor",
        "outlineColor",
        "textDecorationColor",
        "columnRuleColor",
        "caretColor",
        "accentColor",
        "fill",
        "stroke",
      ];
      const win = document.defaultView || window;

      clone.querySelectorAll("*").forEach((el) => {
        const cs = win.getComputedStyle(el);

        // 1) simple color props
        COLOR_PROPS.forEach((p) => {
          const v = cs[p];
          if (hasOK(v)) el.style[p] = toRGB(v);
        });

        // 2) gradients containing OKLCH → fall back to solid bg
        const bgi = cs.backgroundImage;
        if (hasOK(bgi)) {
          el.style.backgroundImage = "none";
          el.style.backgroundColor =
            toRGB(cs.backgroundColor) ||
            (dark ? "rgb(24,24,27)" : "rgb(255,255,255)");
        }

        // 3) shadows containing OKLCH only
        if (hasOK(cs.boxShadow)) el.style.boxShadow = "none";
        if (hasOK(cs.textShadow)) el.style.textShadow = "none";
      });

      // let styles apply
      await new Promise((r) => requestAnimationFrame(r));

      // render the CLONE at full height
      const fullW = Math.ceil(clone.scrollWidth || clone.clientWidth);
      const fullH = Math.ceil(clone.scrollHeight || clone.clientHeight);

      const canvas = await html2canvas(clone, {
        backgroundColor: dark ? "rgb(17,17,20)" : "rgb(255,255,255)",
        scale: Math.max(2, window.devicePixelRatio || 1),
        useCORS: true,
        removeContainer: true,
        width: fullW,
        height: fullH,
        windowWidth: fullW,
        windowHeight: fullH,
        scrollX: 0,
        scrollY: 0,
        ignoreElements: (el) =>
          el?.getAttribute?.("data-snapshot-ignore") === "true",
      });

      wrapper.remove();

      const dataUrl = canvas.toDataURL("image/png");
      const wk = Number(currentWeek) || 0;
      const yr = Number(currentYear) || new Date().getFullYear();
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = `weekly-outlook-wk${wk}-${yr}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (err) {
      console.error("Snapshot failed:", err);
      alert("Snapshot failed. See console for details.");
    }
  }, [currentWeek, currentYear]);

  // Pull projections directly from stored rows in localStorage
  const projByOwner = React.useMemo(() => {
    try {
      const STORE_KEY = "FL_STORE_v1";
      const store = JSON.parse(localStorage.getItem(STORE_KEY) || "{}");
      const lid =
        store.lastSelectedLeagueId || Object.keys(store.leaguesById || {})[0];
      const L = (store.leaguesById || {})[lid] || {};

      const yr = Number(currentYear) || 0;
      const wk = Number(currentWeek) || 0;

      const rows = (L.rows || []).filter(
        (r) => Number(r.season) === yr && Number(r.week) === wk
      );

      const m = new Map();
      rows.forEach((r) => {
        const owner = (r.manager || r.owner || "").trim();
        const p = Number(r?.proj_for ?? r?.projFor);
        if (owner && Number.isFinite(p)) m.set(owner, p);
      });
      return m;
    } catch {
      return new Map();
    }
  }, [currentYear, currentWeek]);

  // ---------- live/current score from ESPN schedule (Week N) ----------
  const scoreByOwner = React.useMemo(() => {
    const wk = Number(currentWeek);
    const S = (typeof window !== "undefined" && window.__FL_SOURCES) || {};
    const seasonObj =
      S.seasonsByYear?.[currentYear] ||
      S.seasonsByYear?.[String(currentYear)] ||
      {};
    const sched =
      (Array.isArray(seasonObj?.schedule) && seasonObj.schedule.length
        ? seasonObj.schedule
        : Array.isArray(scheduleThisYear)
        ? scheduleThisYear
        : []) || [];

    if (!wk || !sched.length) return new Map();

    const ownerNameFromMap =
      typeof window !== "undefined" &&
      window.__ownerMaps &&
      typeof window.__ownerMaps.name === "function"
        ? window.__ownerMaps.name.bind(window.__ownerMaps)
        : null;

    const nameForTeam = (tid) => {
      const nm = ownerNameFromMap
        ? ownerNameFromMap(Number(currentYear), Number(tid))
        : null;
      return nm ? canonicalize(nm) : null;
    };

    const readScore = (side) =>
      Number(
        side?.totalPointsLive ??
          side?.rosterForMatchupPeriod?.appliedStatTotal ??
          side?.totalPoints ??
          side?.score ??
          0
      ) || 0;

    const out = new Map();
    for (const g of sched) {
      const period = Number(g?.matchupPeriodId ?? g?.scoringPeriodId);
      if (period !== wk) continue;

      const hId = Number(g?.home?.teamId ?? g?.homeTeamId ?? g?.homeId);
      const aId = Number(g?.away?.teamId ?? g?.awayTeamId ?? g?.awayId);

      if (Number.isFinite(hId)) {
        const owner = nameForTeam(hId);
        if (owner) out.set(owner, readScore(g.home));
      }
      if (Number.isFinite(aId)) {
        const owner = nameForTeam(aId);
        if (owner) out.set(owner, readScore(g.away));
      }
    }
    return out;
  }, [currentWeek, currentYear, canonicalize, scheduleThisYear]);

  // A) This week's REGULAR-SEASON matchups from league.games (keep 0–0 & ties)
  const rowsThisWeek = React.useMemo(() => {
    const all = Array.isArray(league?.games) ? league.games : [];
    return all
      .filter(
        (g) =>
          Number(g?.season) === Number(currentYear) &&
          g?.is_playoff !== true &&
          Number(g?.week) === Number(currentWeek)
      )
      .map((g) => {
        const ownerPts = pickNum(
          g.pf,
          g.points_for,
          g.points,
          g.score,
          g.owner_points,
          g.pts,
          g.fpts
        );
        const oppPts = pickNum(
          g.pa,
          g.points_against,
          g.opp_points,
          g.oppPts,
          g.against,
          g.opp_score
        );
        return {
          owner: canonicalize(g?.owner ?? g?.manager ?? ""),
          opp: canonicalize(g?.opp ?? g?.opponent ?? ""),
          res: (g?.res || g?.result || "").toUpperCase(), // W/L/T or ''
          ownerPts,
          oppPts,
          week: Number(g?.week) || null,
        };
      })
      .sort(
        (a, b) =>
          (a.week ?? 0) - (b.week ?? 0) ||
          a.owner.localeCompare(b.owner) ||
          a.opp.localeCompare(b.opp)
      );
  }, [league?.games, currentYear, currentWeek]);
  const matchupsThisWeek = React.useMemo(() => {
    const byKey = new Map(); // `${week}|A|B` sorted
    const keyOf = (week, a, b) => {
      const [A, B] = [a || "", b || ""].map(String).sort();
      return `${week}|${A}|${B}`;
    };

    for (const r of rowsThisWeek) {
      const A = (r.owner || "").trim();
      const B = (r.opp || "").trim();
      if (!A || !B || !r.week) continue;
      const key = keyOf(r.week, A, B);
      const cur = byKey.get(key) || { week: r.week, A: null, B: null };
      if (!cur.A) cur.A = r;
      else if (!cur.B) cur.B = r;
      byKey.set(key, cur);
    }

    const out = [];
    byKey.forEach(({ week, A, B }) => {
      if (!A && !B) return;
      const left = A || B;
      const right = B || A;
      const aName = canonicalize(left?.owner || "");
      const bName = canonicalize(left?.opp || right?.owner || "");
      // current live score from schedule (fallback to historical rows)
      const sA = scoreByOwner.get(aName);
      const sB = scoreByOwner.get(bName);
      const aPts = Number.isFinite(sA)
        ? sA
        : Number.isFinite(left?.ownerPts)
        ? left.ownerPts
        : 0;
      const bPts = Number.isFinite(sB)
        ? sB
        : Number.isFinite(right?.ownerPts)
        ? right.ownerPts
        : Number.isFinite(left?.oppPts)
        ? left.oppPts
        : 0;

      const projA = projByOwner.get(aName) ?? null;
      const projB = projByOwner.get(bName) ?? null;

      out.push({ week, aName, bName, aPts, bPts, projA, projB });
    });

    // ...end of matchupsThisWeek memo
    out.sort(
      (x, y) =>
        (x.week ?? 0) - (y.week ?? 0) ||
        x.aName.localeCompare(y.aName) ||
        x.bName.localeCompare(y.bName)
    );
    return out;
  }, [
    rowsThisWeek,
    currentYear,
    currentWeek,
    seasonThisYear,
    projByOwner,
    scoreByOwner,
  ]);
  // ---------- head-to-head history (REG season only; deduped per game) ----------
  const h2hIndex = React.useMemo(() => {
    // key: "ownerA|ownerB" (sorted) -> { total, aWins, bWins, rows:[latest first] }
    const idx = new Map();

    // 1) Pair mirror rows into a single game per (season, week, pair)
    //    Only regular season (ignore playoffs), keep ties.
    const bucket = new Map(); // season|week|A__B -> { Arow, Brow }
    const keyForGame = (yr, wk, a, b) =>
      `${yr}|${wk}|${[String(a || ""), String(b || "")].sort().join("__")}`;

    for (const r of league.games || []) {
      const yr = Number(r?.season);
      const wk = Number(r?.week);
      if (!Number.isFinite(yr) || !Number.isFinite(wk)) continue;
      if (r?.is_playoff === true) continue; // REG only

      const a = (r?.owner || r?.manager || "").trim();
      const b = (r?.opp || r?.opponent || "").trim();
      if (!a || !b) continue;

      const k = keyForGame(yr, wk, a, b);
      const cur = bucket.get(k) || { Arow: null, Brow: null };

      // Put the first perspective we see into Arow; the other perspective into Brow
      if (!cur.Arow) cur.Arow = r;
      else if (!cur.Brow) cur.Brow = r;

      bucket.set(k, cur);
    }

    // 2) Fold each game into the lifetime pair aggregates (count once per game)
    bucket.forEach(({ Arow, Brow }) => {
      // Pick a consistent "left/right" (A = first row we saw)
      const row = Arow || Brow;
      if (!row) return;

      const yr = Number(row.season);
      const wk = Number(row.week);
      const a = (row.owner || row.manager || "").trim();
      const b = (row.opp || row.opponent || "").trim();
      if (!a || !b) return;

      const pairKey = [a, b].sort().join("|");

      // Scores from both sides if available (don’t double-count)
      const aPts =
        Number(
          Arow?.pf ??
            Arow?.points_for ??
            Arow?.points ??
            Arow?.score ??
            Arow?.owner_points ??
            Arow?.pts ??
            Arow?.fpts
        ) || 0;

      let bPts = 0;
      if (Brow) {
        bPts =
          Number(
            Brow?.pf ??
              Brow?.points_for ??
              Brow?.points ??
              Brow?.score ??
              Brow?.owner_points ??
              Brow?.pts ??
              Brow?.fpts
          ) || 0;
      } else {
        // If we only had one perspective, try to use its "opponent points" fields
        bPts =
          Number(
            row?.pa ??
              row?.points_against ??
              row?.opp_points ??
              row?.oppPts ??
              row?.against ??
              row?.opp_score
          ) || 0;
      }

      // Decide winner for THIS GAME (ties allowed)
      const resA = String(
        Arow?.res ?? Arow?.result ?? row?.res ?? row?.result ?? ""
      ).toUpperCase();
      let aWin = null;
      if (resA === "W") aWin = true;
      else if (resA === "L") aWin = false;
      else if (Number.isFinite(aPts) && Number.isFinite(bPts)) {
        aWin = aPts > bPts ? true : aPts < bPts ? false : null;
      }

      // Prepare per-pair record container
      const rec = idx.get(pairKey) || {
        total: 0,
        aWins: 0,
        bWins: 0,
        rows: [], // most-recent first
      };

      // Figure out which side of the sorted pair is "A" for counts
      const [left, right] = [a, b].sort();
      const aIsLeft = left === a;

      rec.total += 1;
      if (aWin === true) {
        if (aIsLeft) rec.aWins += 1;
        else rec.bWins += 1;
      } else if (aWin === false) {
        if (aIsLeft) rec.bWins += 1;
        else rec.aWins += 1;
      }

      rec.rows.push({ year: yr, week: wk, a, b, aPts, bPts });

      idx.set(pairKey, rec);
    });

    return idx;
  }, [league.games]);

  // helper: get h2h summary for two owners (REG-season only, deduped)
  const h2hSummary = React.useCallback(
    (ownerA, ownerB) => {
      const key = [ownerA, ownerB].sort().join("|");
      const rec = h2hIndex.get(key);
      if (!rec) return { total: 0, wA: 0, wB: 0, last3: [] };

      // Convert counts to the caller’s (ownerA, ownerB) orientation
      const [left] = [ownerA, ownerB].sort();
      const aIsLeft = left === ownerA;
      const wA = aIsLeft ? rec.aWins : rec.bWins;
      const wB = aIsLeft ? rec.bWins : rec.aWins;

      const last3 = rec.rows
        .filter(
          (r) =>
            (r.a === ownerA && r.b === ownerB) ||
            (r.a === ownerB && r.b === ownerA)
        )
        .slice(0, 3)
        .map((r) => {
          const viewA = r.a === ownerA;
          const myPts = viewA ? r.aPts : r.bPts;
          const oppPts = viewA ? r.bPts : r.aPts;
          const result = myPts > oppPts ? "W" : myPts < oppPts ? "L" : "T";
          return { year: r.year, week: r.week, result };
        });

      return { total: rec.total, wA, wB, last3 };
    },
    [h2hIndex]
  );
  const h2hFor = h2hSummary;
  // Most-recent meeting (year, week, scores) in the caller's A/B orientation
  // Most-recent meeting (year, week, scores) BEFORE the current week
  const lastMeeting = React.useCallback(
    (A, B) => {
      const key = [A, B].sort().join("|");
      const rec = h2hIndex.get(key);
      if (!rec || !rec.rows?.length) return null;

      // Only consider games strictly before the current (year, week)
      const cutY = Number(currentYear) || 0;
      const cutW = Number(currentWeek) || 0;
      const rowsBeforeNow = rec.rows.filter((r) => {
        const y = Number(r.year) || 0;
        const w = Number(r.week) || 0;
        return y < cutY || (y === cutY && w < cutW);
      });

      // If there are no prior meetings, bail
      if (!rowsBeforeNow.length) return null;

      // Latest by (year, week)
      const r = rowsBeforeNow.reduce((best, cur) => {
        if (!best) return cur;
        const by = Number(best.year) || 0,
          bw = Number(best.week) || 0;
        const cy = Number(cur.year) || 0,
          cw = Number(cur.week) || 0;
        return cy > by || (cy === by && cw > bw) ? cur : best;
      }, null);

      const aFirst = r.a === A && r.b === B;
      const aPts = aFirst ? r.aPts : r.bPts;
      const bPts = aFirst ? r.bPts : r.aPts;
      let winner = null;
      if (Number.isFinite(aPts) && Number.isFinite(bPts)) {
        winner = aPts > bPts ? A : aPts < bPts ? B : null;
      }
      return {
        year: r.year,
        week: r.week,
        aName: A,
        bName: B,
        aPts,
        bPts,
        winner,
      };
    },
    [h2hIndex, currentYear, currentWeek]
  );

  // =====================================================================
  // C) Playoff probability engine (same approach as before)
  // =====================================================================
  const mergedPlayoffTeams = React.useMemo(() => {
    const out = {};
    (seasonsAll || []).forEach((yr) => {
      const base = Number(playoffTeamsBase?.[yr] ?? 0) || 0;
      const ovrd = Number(playoffTeamsOverrides?.[yr] ?? 0) || 0;
      out[yr] = ovrd || base || 0;
    });
    return out;
  }, [seasonsAll, playoffTeamsBase, playoffTeamsOverrides]);

  const { recProbByWeekStrict, ownerRecordNow } = React.useMemo(() => {
    // completed seasons, only those with known # playoff teams
    const completedSeasons = new Set();
    (owners || []).forEach((o) => {
      const bySeason = league.placementMap?.[o] || {};
      Object.entries(bySeason).forEach(([yrStr, place]) => {
        const yr = Number(yrStr);
        if (yr && Number.isFinite(Number(place))) completedSeasons.add(yr);
      });
    });

    const madePO = new Map(); // "owner__year" -> boolean
    (owners || []).forEach((o) => {
      const bySeason = league.placementMap?.[o] || {};
      Object.entries(bySeason).forEach(([yrStr, place]) => {
        const yr = Number(yrStr);
        const poCnt = Number(mergedPlayoffTeams?.[yr] || 0);
        if (!completedSeasons.has(yr) || !poCnt) return;
        const made = Number(place) > 0 && Number(place) <= poCnt;
        madePO.set(`${o}__${yr}`, made);
      });
    });

    // per-owner current season record through (currentWeek-1)
    const ownerRecordNow = new Map(); // owner -> {W,L}
    (league.games || []).forEach((g) => {
      const yr = Number(g?.season);
      const wk = Number(g?.week);
      if (yr !== currentYear) return;
      if (!Number.isFinite(wk) || wk >= currentWeek) return; // completed weeks only
      const owner = g?.owner || g?.manager;
      const res = String(g?.res || g?.result || "").toUpperCase();
      if (!owner || !res) return;
      const slot = ownerRecordNow.get(owner) || { W: 0, L: 0 };
      if (res === "W") slot.W += 1;
      else if (res === "L") slot.L += 1;
      ownerRecordNow.set(owner, slot);
    });

    // aggregate history (strict sample: exactly N games after week N)
    const perOwnerSeasonWeek = new Map(); // "owner__year" -> Map(week -> {w,l})
    for (const g of league.games || []) {
      const yr = Number(g?.season);
      if (!completedSeasons.has(yr)) continue;
      if (!mergedPlayoffTeams?.[yr]) continue;
      const wk = Number(g?.week);
      if (!Number.isFinite(wk)) continue;
      if (g?.is_playoff === true) continue; // only regular-season path for sample
      const owner = g?.owner || g?.manager;
      const res = String(g?.res || g?.result || "").toUpperCase();
      if (!owner || !res) continue;
      const key = `${owner}__${yr}`;
      if (!perOwnerSeasonWeek.has(key)) perOwnerSeasonWeek.set(key, new Map());
      const wkMap = perOwnerSeasonWeek.get(key);
      if (!wkMap.has(wk)) wkMap.set(wk, { w: 0, l: 0 });
      const slot = wkMap.get(wk);
      if (res === "W") slot.w += 1;
      else if (res === "L") slot.l += 1;
    }

    const recProbByWeekStrict = new Map(); // week -> Map("W-L" -> {made,total})
    const bump = (week, recKey, made) => {
      if (!recProbByWeekStrict.has(week))
        recProbByWeekStrict.set(week, new Map());
      const m = recProbByWeekStrict.get(week);
      const row = m.get(recKey) || { made: 0, total: 0 };
      row.total += 1;
      if (made) row.made += 1;
      m.set(recKey, row);
    };

    perOwnerSeasonWeek.forEach((wkMap, ownerSeasonKey) => {
      const made = madePO.get(ownerSeasonKey);
      if (made === undefined) return;
      let W = 0,
        L = 0;
      const weeks = Array.from(wkMap.keys()).sort((a, b) => a - b);
      for (const w of weeks) {
        const slot = wkMap.get(w);
        W += slot.w;
        L += slot.l;
        if (W + L === w) bump(w, `${W}-${L}`, made === true);
      }
    });

    return { recProbByWeekStrict, ownerRecordNow };
  }, [
    league.games,
    league.placementMap,
    owners,
    mergedPlayoffTeams,
    currentYear,
    currentWeek,
  ]);

  const probAt = React.useCallback(
    (week, W, L) => {
      const map = recProbByWeekStrict.get(Number(week));
      if (!map) return null;
      const row = map.get(`${W}-${L}`);
      if (!row || !row.total) return null;
      return row.made / row.total; // 0..1
    },
    [recProbByWeekStrict]
  );

  // Build playoff-prob deltas for owners appearing this week
  const swingRows = React.useMemo(() => {
    const out = [];
    const inWeekOwners = new Set();
    matchupsThisWeek.forEach((m) => {
      inWeekOwners.add(m.aName);
      inWeekOwners.add(m.bName);
    });
    inWeekOwners.forEach((owner) => {
      const rec = ownerRecordNow.get(owner) || { W: 0, L: 0 };
      const P_now = probAt(currentWeek - 1, rec.W, rec.L);
      const P_win = probAt(currentWeek, rec.W + 1, rec.L);
      const P_loss = probAt(currentWeek, rec.W, rec.L + 1);
      if (P_win == null && P_loss == null && P_now == null) return;
      out.push({
        owner,
        now: P_now,
        win: P_win,
        loss: P_loss,
        gain: P_win != null && P_now != null ? P_win - P_now : null,
        drop: P_loss != null && P_now != null ? P_now - P_loss : null,
        swing: P_win != null && P_loss != null ? P_win - P_loss : null,
      });
    });
    const mostGain = [...out]
      .filter((r) => r.gain != null)
      .sort((a, b) => b.gain - a.gain)
      .slice(0, 3);
    const mostDrop = [...out]
      .filter((r) => r.drop != null)
      .sort((a, b) => b.drop - a.drop)
      .slice(0, 3);
    return { rows: out, mostGain, mostDrop };
  }, [matchupsThisWeek, ownerRecordNow, currentWeek, probAt]);

  const outlookFor = React.useCallback(
    (owner) => swingRows.rows.find((r) => r.owner === owner) || {},
    [swingRows.rows]
  );

  // =====================================================================
  // D) Picks: Rivalry (closest) and Dad/Son (most lopsided)
  // =====================================================================
  const rivalryPick = React.useMemo(() => {
    let best = null;
    for (const m of matchupsThisWeek) {
      const { wA, wB, total } = h2hFor(m.aName, m.bName);
      if (!total) continue;
      const diff = Math.abs(wA - wB);
      const row = { A: m.aName, B: m.bName, wA, wB, total, diff };
      if (
        !best ||
        diff < best.diff ||
        (diff === best.diff && total > best.total) ||
        (diff === best.diff &&
          total === best.total &&
          m.aName.localeCompare(best.A) < 0)
      ) {
        best = row;
      }
    }
    return best;
  }, [matchupsThisWeek, h2hFor]);

  const dadSonPick = React.useMemo(() => {
    let best = null;
    for (const m of matchupsThisWeek) {
      const { wA, wB, total } = h2hFor(m.aName, m.bName);
      if (!total) continue; // require at least one meeting
      const diff = Math.abs(wA - wB);
      const dad = wA >= wB ? m.aName : m.bName;
      const son = dad === m.aName ? m.bName : m.aName;
      const dadWins = Math.max(wA, wB);
      const sonWins = Math.min(wA, wB);
      const row = { dad, son, dadWins, sonWins, total, diff };
      if (
        !best ||
        diff > best.diff ||
        (diff === best.diff && total > best.total)
      ) {
        best = row;
      }
    }
    return best;
  }, [matchupsThisWeek, h2hFor]);

  const pct = (x) =>
    x == null || !Number.isFinite(Number(x))
      ? "—"
      : `${Math.round(Number(x) * 100)}%`;

  const pctNum = (x) =>
    x == null || !Number.isFinite(Number(x))
      ? null
      : Math.round(Number(x) * 100);

  const winColor = (isUp) =>
    isUp == null
      ? "text-zinc-500"
      : isUp
      ? "text-emerald-500"
      : "text-rose-500";

  // convenience for H2H line styling
  const h2hLine = (myWins, oppWins) => {
    const total = Number(myWins) + Number(oppWins);
    const myPct = total > 0 ? Math.round((myWins / total) * 100) : null;
    const mineUp = myWins > oppWins ? true : myWins < oppWins ? false : null;
    return {
      text: `H2H: ${myWins}–${oppWins}${myPct == null ? "" : ` (${myPct}%)`}`,
      cls: winColor(mineUp),
    };
  };

  // =====================================================================
  // UI
  // =====================================================================
  return (
    <div ref={captureRef} className="space-y-6">
      <Card
        title={
          <div className="flex items-center justify-between gap-2">
            <span>{`Weekly Outlook — Week ${currentWeek} (${currentYear})`}</span>

            {/* Camera button (ignored in snapshot) */}
            <button
              type="button"
              onClick={onSnap}
              data-snapshot-ignore="true"
              className="inline-flex items-center gap-2 rounded-full px-2.5 py-1.5 text-xs
                         border border-zinc-300/60 dark:border-zinc-700/60
                         bg-white/70 dark:bg-zinc-900/70
                         hover:bg-white/90 hover:dark:bg-zinc-900/90
                         shadow-sm"
              title="Save snapshot"
            >
              <svg
                viewBox="0 0 24 24"
                className="h-4 w-4"
                fill="currentColor"
                aria-hidden="true"
              >
                <path d="M9 3l1.5 2H14l1.5-2H19a2 2 0 012 2v12a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h4zM12 18a5 5 0 100-10 5 5 0 000 10zm0-2.5a2.5 2.5 0 110-5 2.5 2.5 0 010 5z" />
              </svg>
              <span className="hidden sm:inline">Snapshot</span>
            </button>
          </div>
        }
        subtitle="Matchups, rivalries, and playoff-odds swings"
      >
        <div className="grid md:grid-cols-3 gap-4">
          {/* Rivalry — fiery, centered, VS coin, last meeting */}
          <div
            className="
    rounded-2xl p-4 text-center
    bg-gradient-to-br from-orange-500/10 via-rose-500/10 to-amber-400/10
    border border-orange-400/30 dark:border-orange-400/30
    shadow-[0_10px_28px_-10px_rgba(234,88,12,.35)]
  "
          >
            <div
              className="
      text-xl md:text-2xl font-extrabold tracking-tight
      bg-gradient-to-r from-orange-400 via-red-500 to-amber-300
      bg-clip-text text-transparent drop-shadow
    "
            >
              Rivalry of the Week
            </div>

            {rivalryPick ? (
              (() => {
                const last = lastMeeting(rivalryPick.A, rivalryPick.B);
                const winsCls = (mine, theirs) =>
                  mine > theirs
                    ? "bg-emerald-600/20 text-emerald-400 ring-1 ring-emerald-500/40"
                    : mine < theirs
                    ? "bg-rose-600/20 text-rose-400 ring-1 ring-rose-500/40"
                    : "bg-zinc-600/20 text-zinc-300 ring-1 ring-zinc-500/30";

                return (
                  <>
                    <div className="mt-3 text-sm opacity-90">
                      Lifetime record
                    </div>

                    <div className="mt-2 grid grid-cols-[1fr_auto_1fr] items-center gap-3">
                      {/* Left name + centered wins */}
                      <div className="flex flex-col items-center">
                        <div className="text-base md:text-lg font-semibold">
                          {rivalryPick.A}
                        </div>
                        <span
                          className={`mt-1 inline-block text-[11px] px-2 py-0.5 rounded-full tabular-nums ${winsCls(
                            rivalryPick.wA,
                            rivalryPick.wB
                          )}`}
                        >
                          {rivalryPick.wA} wins
                        </span>
                      </div>

                      {/* Pronounced VS coin */}
                      <div
                        className="
                relative mx-1 h-12 w-12 rounded-full grid place-items-center
                bg-white/95 dark:bg-zinc-900
                ring-2 ring-zinc-200 dark:ring-zinc-700
                shadow-[0_14px_36px_-10px_rgba(0,0,0,0.45)]
              "
                        aria-hidden="true"
                        title="VS"
                      >
                        <span
                          className="
                text-lg font-black uppercase tracking-wider
                bg-gradient-to-br from-orange-400 via-yellow-300 to-red-400
                bg-clip-text text-transparent drop-shadow-[0_1px_0_rgba(0,0,0,0.4)]
              "
                        >
                          VS
                        </span>
                      </div>

                      {/* Right name + centered wins */}
                      <div className="flex flex-col items-center">
                        <div className="text-base md:text-lg font-semibold">
                          {rivalryPick.B}
                        </div>
                        <span
                          className={`mt-1 inline-block text-[11px] px-2 py-0.5 rounded-full tabular-nums ${winsCls(
                            rivalryPick.wB,
                            rivalryPick.wA
                          )}`}
                        >
                          {rivalryPick.wB} wins
                        </span>
                      </div>
                    </div>

                    {/* Last meeting instead of Δ */}
                    {last && (
                      <div className="mt-3 text-xs text-zinc-300">
                        Last meeting: {last.year} Wk {last.week} —{" "}
                        {last.winner ? (
                          <>
                            <span className="font-medium">{last.winner}</span>{" "}
                            {Math.round(Math.max(last.aPts, last.bPts))}–
                            {Math.round(Math.min(last.aPts, last.bPts))}
                          </>
                        ) : (
                          <>
                            Tie {Math.round(last.aPts)}–{Math.round(last.bPts)}
                          </>
                        )}
                      </div>
                    )}
                  </>
                );
              })()
            ) : (
              <div className="mt-2 text-sm opacity-80">
                No prior meetings among this week’s pairs.
              </div>
            )}
          </div>

          {/* Dad / Son — cool blue, icons, VS coin, last meeting */}
          <div
            className="rounded-2xl border border-zinc-200/30 dark:border-zinc-800/50 p-5 overflow-hidden
                bg-[radial-gradient(120%_140%_at_0%_0%,rgba(59,130,246,.15),transparent_60%),radial-gradient(120%_140%_at_100%_100%,rgba(147,197,253,.12),transparent_60%)]"
          >
            <div className="text-2xl md:text-3xl font-extrabold tracking-tight text-center">
              Dad / Son Matchup
            </div>
            <div className="mt-1 text-center text-sm text-zinc-400">
              Lifetime record
            </div>

            {dadSonPick ? (
              <>
                <div className="mt-4 grid grid-cols-[minmax(0,1.35fr)_auto_minmax(0,1.35fr)] items-stretch gap-1 md:gap-3">
                  {/* DAD side */}
                  <div className="min-w-0 w-full h-full rounded-2xl bg-zinc-900/20 border border-zinc-800/60 px-4 md:px-5 py-3 text-center">
                    <div className="text-2xl mb-1">👨</div>
                    <div className="text-[11px] tracking-wide uppercase text-zinc-400">
                      Dad
                    </div>
                    <AutoFitTwoLine
                      name={dadSonPick.dad}
                      className="mt-1 font-semibold tracking-tight"
                    />
                    {/* wins pill (green) */}
                    <div className="mt-3">
                      <span
                        className="inline-flex items-center px-3 py-1 rounded-full
                             bg-emerald-900/25 text-emerald-300 ring-1 ring-emerald-700/40
                             text-sm tabular-nums"
                      >
                        {dadSonPick.dadWins} wins
                      </span>
                    </div>
                  </div>

                  {/* VS badge */}
                  <div
                    className="mx-1 h-12 w-12 md:h-14 md:w-14 rounded-full grid place-items-center
   bg-zinc-900/60 text-white
   ring-2 ring-zinc-700/60 shadow-[0_10px_28px_-6px_rgba(0,0,0,0.35)]"
                  >
                    <span
                      className="text-lg font-black uppercase tracking-wider
                           bg-gradient-to-br from-orange-400 via-yellow-300 to-red-400
                           bg-clip-text text-transparent"
                    >
                      VS
                    </span>
                  </div>

                  {/* SON side */}
                  <div className="min-w-0 w-full h-full rounded-2xl bg-zinc-900/20 border border-zinc-800/60 px-4 md:px-5 py-3 text-center">
                    <div className="text-2xl mb-1">👦</div>
                    <div className="text-[11px] tracking-wide uppercase text-zinc-400">
                      Son
                    </div>
                    <AutoFitTwoLine
                      name={dadSonPick.son}
                      className="mt-1 font-semibold tracking-tight"
                    />
                    {/* wins pill (red) */}
                    <div className="mt-3">
                      <span
                        className="inline-flex items-center px-3 py-1 rounded-full
                             bg-rose-900/25 text-rose-300 ring-1 ring-rose-700/40
                             text-sm tabular-nums"
                      >
                        {dadSonPick.sonWins} wins
                      </span>
                    </div>
                  </div>
                </div>

                {/* Last meeting line — same format as Rivalry */}
                {(() => {
                  const lm = lastMeeting(dadSonPick.dad, dadSonPick.son);
                  return (
                    lm && (
                      <div className="mt-4 text-center text-sm text-zinc-300/90">
                        Last meeting: {lm.year} Wk {lm.week} —{" "}
                        {lm.winner ? (
                          <>
                            <span className="font-medium">{lm.winner}</span>{" "}
                            {Math.round(Math.max(lm.aPts, lm.bPts))}–
                            {Math.round(Math.min(lm.aPts, lm.bPts))}
                          </>
                        ) : (
                          <>
                            Tie {Math.round(lm.aPts)}–{Math.round(lm.bPts)}
                          </>
                        )}
                      </div>
                    )
                  );
                })()}
              </>
            ) : (
              <div className="mt-3 text-center text-sm opacity-70">
                Not enough history yet.
              </div>
            )}
          </div>
          {/* Playoff-Prob Swings — centered, aligned, no ellipses */}
          <div
            className="
  rounded-2xl p-4 text-center
  bg-gradient-to-br from-indigo-500/10 via-violet-500/10 to-fuchsia-500/10
  border border-indigo-400/30 dark:border-indigo-400/30
"
          >
            <div className="text-base font-semibold mb-2">
              Playoff-Prob Swings
            </div>

            <div className="grid grid-cols-2 gap-8">
              {/* Gainers */}
              <div>
                <div className="text-xs uppercase font-semibold text-emerald-400 mb-2">
                  Most to gain (win)
                </div>

                {swingRows.mostGain.length ? (
                  <ul className="space-y-1">
                    {swingRows.mostGain.map((r) => (
                      <li
                        key={`gain-${r.owner}`}
                        className="grid items-center gap-2
                         grid-cols-[minmax(0,1fr)_3rem]"
                      >
                        {/* exactly two lines */}
                        <OwnerTwoLine name={r.owner} />
                        {/* fixed-width %, right-aligned, tabular digits */}
                        <span className="text-sm tabular-nums text-right font-semibold text-emerald-400 w-12">
                          {pct(r.gain)}
                        </span>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <div className="text-xs opacity-70">—</div>
                )}
              </div>

              {/* Droppers */}
              <div>
                <div className="text-xs uppercase font-semibold text-rose-400 mb-2">
                  Most to lose (loss)
                </div>

                {swingRows.mostDrop.length ? (
                  <ul className="space-y-1">
                    {swingRows.mostDrop.map((r) => (
                      <li
                        key={`drop-${r.owner}`}
                        className="grid items-center gap-2
                         grid-cols-[minmax(0,1fr)_3rem]"
                      >
                        <OwnerTwoLine name={r.owner} />
                        <span className="text-sm tabular-nums text-right font-semibold text-rose-400 w-12">
                          {pct(r.drop)}
                        </span>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <div className="text-xs opacity-70">—</div>
                )}
              </div>
            </div>

            <div className="mt-3 text-[11px] text-zinc-500">
              Probabilities are historical P(make playoffs) by record after Week
              N (strict Week-N sample).
            </div>
          </div>
        </div>
      </Card>

      {/* Matchups */}
      <Card>
        <div className="mb-4 text-center">
          <div
            className="text-2xl md:text-3xl font-extrabold tracking-tight leading-tight
                    bg-gradient-to-r from-indigo-400 via-sky-400 to-emerald-400 bg-clip-text text-transparent
                    drop-shadow"
          >
            Matchups &amp; Outlook
          </div>
          <div className="mt-1 text-sm md:text-base font-semibold opacity-80">
            Regular-season slate for Week {currentWeek}.
          </div>
        </div>

        {matchupsThisWeek.length === 0 ? (
          <div className="text-sm opacity-70">
            No pairable matchups for this week.
          </div>
        ) : (
          <div className="grid lg:grid-cols-2 gap-4">
            {matchupsThisWeek.map((m, i) => {
              const h = h2hFor(m.aName, m.bName);
              const Ao = outlookFor(m.aName);
              const Bo = outlookFor(m.bName);

              return (
                <div
                  key={i}
                  className="
                  group relative transform-gpu
                  rounded-2xl
                  bg-gradient-to-br from-white to-zinc-50
                  dark:from-zinc-900 dark:to-zinc-950
                  border border-zinc-200/70 dark:border-zinc-700
                  shadow-md
                  hover:shadow-xl hover:scale-[1.02]
                  active:scale-[0.99] active:shadow-md
                  transition-transform transition-shadow duration-300 ease-[cubic-bezier(.2,.8,.2,1)]
                  p-4
                "
                >
                  {/* faint highlight edge */}
                  <div
                    className="absolute inset-0 rounded-2xl pointer-events-none
                              shadow-[inset_1px_1px_0_rgba(255,255,255,0.5)]
                              dark:shadow-[inset_1px_1px_0_rgba(255,255,255,0.08)]"
                  />
                  {/* Top row: names + records + VS badge */}
                  <div className="relative grid grid-cols-[1fr_auto_1fr] items-center gap-3">
                    {/* left side */}
                    <div className="text-left">
                      <div className="text-base md:text-lg font-semibold tracking-tight drop-shadow-sm">
                        {m.aName}
                        <span className="ml-2 text-xs md:text-sm font-medium text-zinc-500">
                          ({ownerRecordNow.get(m.aName)?.W || 0}-
                          {ownerRecordNow.get(m.aName)?.L || 0})
                        </span>
                      </div>
                      {(() => {
                        const row = h2hLine(h.wA, h.wB);
                        return (
                          <div className={`mt-1 text-[11px] ${row.cls}`}>
                            {row.text}
                          </div>
                        );
                      })()}
                    </div>

                    {/* VS badge */}
                    <div
                      className="
    relative mx-1 h-12 w-12 rounded-full grid place-items-center
    bg-white/95 dark:bg-zinc-900
    ring-2 ring-zinc-200 dark:ring-zinc-700
    shadow-[0_10px_28px_-6px_rgba(0,0,0,0.35)]
    group-hover:shadow-[0_16px_36px_-6px_rgba(0,0,0,0.45)]
    transition-shadow duration-300
    after:absolute after:inset-0 after:rounded-full
    after:bg-[radial-gradient(closest-side,rgba(255,255,255,0.5),transparent)]
  "
                      aria-hidden="true"
                      title="VS"
                    >
                      {/* If you want an image, set window.__FL_VS_IMAGE = 'https://.../vs.png' */}
                      {typeof window !== "undefined" && window.__FL_VS_IMAGE ? (
                        <img
                          src={window.__FL_VS_IMAGE}
                          crossOrigin="anonymous"
                          alt="VS"
                          className="h-8 w-8 object-contain opacity-95"
                        />
                      ) : (
                        <span
                          className="
        text-lg font-black uppercase tracking-wider
        bg-gradient-to-br from-orange-400 via-yellow-300 to-red-400
        bg-clip-text text-transparent drop-shadow-[0_1px_0_rgba(0,0,0,0.4)]
      "
                          style={{ letterSpacing: "0.08em" }}
                        >
                          VS
                        </span>
                      )}
                    </div>

                    {/* right side */}
                    <div className="text-right">
                      <div className="text-base md:text-lg font-semibold tracking-tight drop-shadow-sm">
                        {m.bName}
                        <span className="ml-2 text-xs md:text-sm font-medium text-zinc-500">
                          ({ownerRecordNow.get(m.bName)?.W || 0}-
                          {ownerRecordNow.get(m.bName)?.L || 0})
                        </span>
                      </div>
                      {(() => {
                        const row = h2hLine(h.wB, h.wA);

                        return (
                          <div className={`mt-1 text-[11px] ${row.cls}`}>
                            {row.text}
                          </div>
                        );
                      })()}
                    </div>
                  </div>

                  {/* Score + projections row */}
                  <div className="mt-4 grid grid-cols-2 gap-3 text-sm">
                    <div
                      className="
    p-3 rounded-xl
    bg-gradient-to-b from-white/90 to-zinc-50/80
    dark:from-zinc-900/70 dark:to-zinc-900/50
    border border-zinc-200/70 dark:border-zinc-800
    shadow-sm
    group-hover:shadow
    transition-all duration-300
    group-active:translate-y-[1px] group-active:shadow-none
  "
                    >
                      <div className="text-[11px] uppercase tracking-wide opacity-70 font-semibold">
                        Score
                      </div>

                      <div className="mt-0.5 text-lg tabular-nums font-semibold">
                        {(m.aPts ?? 0).toFixed(1)} — {(m.bPts ?? 0).toFixed(1)}
                      </div>
                    </div>

                    <div
                      className="
    p-3 rounded-xl
    bg-gradient-to-b from-white/90 to-zinc-50/80
    dark:from-zinc-900/70 dark:to-zinc-900/50
    border border-zinc-200/70 dark:border-zinc-800
    shadow-sm
    group-hover:shadow
    transition-all duration-300
    group-active:translate-y-[1px] group-active:shadow-none
  "
                    >
                      <div className="text-[11px] uppercase tracking-wide opacity-70 font-semibold">
                        Proj (starters)
                      </div>
                      <div className="mt-0.5 text-lg tabular-nums font-semibold">
                        {Number.isFinite(m?.projA) ? m.projA.toFixed(1) : "—"} —{" "}
                        {Number.isFinite(m?.projB) ? m.projB.toFixed(1) : "—"}
                      </div>
                    </div>
                  </div>

                  {/* Outlook pills */}
                  <div className="mt-4 grid grid-cols-2 gap-3">
                    <div
                      className="
    p-3 rounded-xl
    bg-gradient-to-b from-white/90 to-zinc-50/80
    dark:from-zinc-900/70 dark:to-zinc-900/50
    border border-zinc-200/70 dark:border-zinc-800
    shadow-sm
    group-hover:shadow
    transition-all duration-300
    group-active:translate-y-[1px] group-active:shadow-none
  "
                    >
                      <div className="text-xs font-semibold mb-2">
                        {m.aName}
                      </div>
                      <div className="flex justify-between text-xs">
                        <span className="opacity-70">Current Playoff Odds</span>
                        <span className="tabular-nums">
                          {pct(outlookFor(m.aName).now)}
                        </span>
                      </div>
                      <div className="flex justify-between text-xs">
                        <span className="opacity-70">With Win</span>
                        <span className={`tabular-nums ${winColor(true)}`}>
                          {pct(outlookFor(m.aName).win)}
                        </span>
                      </div>
                      <div className="flex justify-between text-xs">
                        <span className="opacity-70">With Loss</span>
                        <span className={`tabular-nums ${winColor(false)}`}>
                          {pct(outlookFor(m.aName).loss)}
                        </span>
                      </div>
                    </div>

                    <div
                      className="
  p-3 rounded-xl
  bg-gradient-to-b from-white/90 to-zinc-50/80
  dark:from-zinc-900/70 dark:to-zinc-900/50
  border border-zinc-200/70 dark:border-zinc-800
  shadow-sm group-hover:shadow transition-all duration-300
  group-active:translate-y-[1px] group-active:shadow-none
"
                    >
                      <div className="text-xs font-semibold mb-2">
                        {m.bName}
                      </div>
                      <div className="flex justify-between text-xs">
                        <span className="opacity-70">Current Playoff Odds</span>
                        <span className="tabular-nums">
                          {pct(outlookFor(m.bName).now)}
                        </span>
                      </div>
                      <div className="flex justify-between text-xs">
                        <span className="opacity-70">With Win</span>
                        <span className={`tabular-nums ${winColor(true)}`}>
                          {pct(outlookFor(m.bName).win)}
                        </span>
                      </div>
                      <div className="flex justify-between text-xs">
                        <span className="opacity-70">With Loss</span>
                        <span className={`tabular-nums ${winColor(false)}`}>
                          {pct(outlookFor(m.bName).loss)}
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </Card>
    </div>
  );
}
/* ScenarioTab — “Last time X happened” explorer */
export function ScenarioTab({
  league,
  espnOwnerByTeamByYear = {},
  selectedLeague,
  hiddenManagers,

  // optional (kept for future scenarios)
  espnRostersByYear = {},
  rawRows = [],
  espnTeamNamesByOwner = {},
  espnOwnerFullByTeamByYear = {},
  espnRosterAcqByYear: rosterAcqByYearProp = {},
  activityBySeason: activityFromProp = {},
}) {
  if (!league) return null;

  // Make manager name lookups rock-solid
  primeOwnerMaps({
    league,
    selectedLeague,
    espnOwnerByTeamByYear,
    manualAliases: {}, // add overrides if needed later
  });

  // ---------- Basic data + helpers ----------
  const allOwners = Array.isArray(league?.owners) ? league.owners : [];
  const defaultHidden = new Set(
    Array.isArray(hiddenManagers)
      ? hiddenManagers
      : Array.isArray(league?.hiddenManagers)
      ? league.hiddenManagers
      : []
  );

  const [scope, setScope] = React.useState("all"); // "regular" | "playoffs" | "all"
  const [includeHidden, setIncludeHidden] = React.useState(false);
  const [ownerFilter, setOwnerFilter] = React.useState("_ALL_"); // "_ALL_" or one manager name
  const [andOwners, setAndOwners] = React.useState([]); // ["Name A", "Name B", ...]

  const [search, setSearch] = React.useState("");

  // Category & option pickers
  const [category, setCategory] = React.useState("points");
  const [option, setOption] = React.useState("pts_ge_150");

  const ownersBase = includeHidden
    ? allOwners
    : allOwners.filter((o) => !defaultHidden.has(o));

  const ownersSet = new Set(ownersBase);

  const decided = (g) =>
    g &&
    (String(g.res).toUpperCase() === "W" ||
      String(g.res).toUpperCase() === "L");

  const inScopeGame = (g) =>
    scope === "regular"
      ? g.is_playoff !== true
      : scope === "playoffs"
      ? g.is_playoff === true
      : true;

  // finished (decided) games for relevant owners
  const finishedGames = (league.games || []).filter(
    (g) => decided(g) && ownersSet.has(g.owner) && ownersSet.has(g.opp)
  );

  const scopeGames = finishedGames.filter(inScopeGame);

  const pickNum = (...vals) => {
    for (const v of vals) {
      const n = Number(v);
      if (Number.isFinite(n)) return n;
    }
    return null;
  };

  const fmtWeek = (w) => (w == null || isNaN(Number(w)) ? "?" : String(w));

  // quick per-season “last place” max helper
  const maxPlaceBySeason = React.useMemo(() => {
    const out = {};
    Object.values(league?.placementMap || {}).forEach((byYear) => {
      Object.entries(byYear || {}).forEach(([yr, place]) => {
        const y = Number(yr);
        const p = Number(place);
        if (!Number.isFinite(p) || p <= 0) return;
        out[y] = Math.max(out[y] || 0, p);
      });
    });
    return out;
  }, [league?.placementMap]);

  // ---------- Scenario registry ----------
  // Category: "points"
  // Options implement a predicate that returns TRUE if a single game by OWNER matches.
  const POINT_OPTIONS = [
    // highs (≥)
    { key: "pts_ge_130", label: "130+ points", test: (pf) => pf >= 130 },
    { key: "pts_ge_140", label: "140+ points", test: (pf) => pf >= 140 },
    { key: "pts_ge_150", label: "150+ points", test: (pf) => pf >= 150 },
    { key: "pts_ge_160", label: "160+ points", test: (pf) => pf >= 160 },
    { key: "pts_ge_170", label: "170+ points", test: (pf) => pf >= 170 },
    { key: "pts_ge_180", label: "180+ points", test: (pf) => pf >= 180 },
    { key: "pts_ge_190", label: "190+ points", test: (pf) => pf >= 190 },
    { key: "pts_ge_200", label: "200+ points", test: (pf) => pf >= 200 },

    // lows (≤)
    { key: "pts_le_90", label: "90 points or less", test: (pf) => pf <= 90 },
    { key: "pts_le_80", label: "80 points or less", test: (pf) => pf <= 80 },
    { key: "pts_le_70", label: "70 points or less", test: (pf) => pf <= 70 },
    { key: "pts_le_60", label: "60 points or less", test: (pf) => pf <= 60 },
    { key: "pts_le_50", label: "50 points or less", test: (pf) => pf <= 50 },
    { key: "pts_le_40", label: "40 points or less", test: (pf) => pf <= 40 },
    { key: "pts_le_30", label: "30 points or less", test: (pf) => pf <= 30 },
  ];

  // Category: "recordStart"
  // “Started N-0” → owner’s first N games of a season were wins.
  // Helper: given sorted season games for a manager, return the week where they
  // first reached X-0 (wins before first loss), or null if never.
  function weekStartedWins(games, xWinsNeeded) {
    let wins = 0;
    for (const g of games) {
      const res = String(g.res || g.result || "").toUpperCase();
      if (res === "W") {
        wins += 1;
        if (wins === xWinsNeeded) return Number(g.week) || null;
      } else if (res === "L") {
        // streak ended before reaching target
        return null;
      }
    }
    return null;
  }

  // Helper: first reached 0-X (losses before first win)
  function weekStartedLosses(games, xLossesNeeded) {
    let losses = 0;
    for (const g of games) {
      const res = String(g.res || g.result || "").toUpperCase();
      if (res === "L") {
        losses += 1;
        if (losses === xLossesNeeded) return Number(g.week) || null;
      } else if (res === "W") {
        // win breaks the 0-X path
        return null;
      }
    }
    return null;
  }

  const START_RECORD_OPTIONS = [
    // 1-0 .. 8-0
    ...Array.from({ length: 8 }, (_, i) => {
      const n = i + 1;
      return {
        key: `start_${n}_0`,
        label: `${n}-0 start`,
        // testSeason(gamesInSeasonForManager) -> returns week (number) when reached, else null
        seasonWeekPicker: (games) => weekStartedWins(games, n),
      };
    }),
    // 0-1 .. 0-8
    ...Array.from({ length: 8 }, (_, i) => {
      const n = i + 1;
      return {
        key: `start_0_${n}`,
        label: `0-${n} start`,
        seasonWeekPicker: (games) => weekStartedLosses(games, n),
      };
    }),
  ];

  // Category: "placement" — season-level
  const PLACEMENT_OPTIONS = [
    { key: "PLACED_CHAMP", label: "Won the championship (1st)" },
    { key: "PLACED_PLAYOFFS", label: "Made the playoffs (any place > 0)" },
    { key: "PLACED_LAST", label: "Finished last" },
  ];

  // To support a searchable dropdown, filter by text
  const filterBySearch = (arr) =>
    arr.filter((o) => o.label.toLowerCase().includes(search.toLowerCase()));

  const categoryOptions = {
    points: filterBySearch(POINT_OPTIONS),
    recordStart: filterBySearch(START_RECORD_OPTIONS),
    placement: filterBySearch(PLACEMENT_OPTIONS),
  };

  // Ensure `option` stays valid when category changes or search filters it out
  React.useEffect(() => {
    const opts = categoryOptions[category];
    if (!opts.some((o) => o.key === option)) {
      setOption(opts[0]?.key || "");
    }
  }, [category, search]); // eslint-disable-line react-hooks/exhaustive-deps

  // ---------- Core calculators (“last time X happened”) ----------
  // Returns { season, week } for game-based scenarios; { season } for placement
  function lastTimePoints(owner, selectorKey) {
    const opt = POINT_OPTIONS.find((o) => o.key === selectorKey);
    if (!opt) return null;

    // find latest game (by season then week) where owner PF meets condition
    // NOTE: Some rows may be missing week; treat them as week 0 for ordering.
    const rows = scopeGames
      .filter((g) => g.owner === owner)
      .map((g) => ({
        season: Number(g.season),
        week: Number(g.week) || 0,
        pf: pickNum(
          g.pf,
          g.points_for,
          g.points,
          g.score,
          g.owner_points,
          g.pts,
          g.fpts
        ),
      }))
      .filter((r) => Number.isFinite(r.pf))
      .sort((a, b) => a.season - b.season || a.week - b.week);

    let last = null;
    rows.forEach((r) => {
      if (opt.test(r.pf)) last = { season: r.season, week: r.week };
    });
    return last;
  }

  function lastTimeRecordStart(owner, selectorKey) {
    const opt = START_RECORD_OPTIONS.find((o) => o.key === selectorKey);
    if (!opt) return null;

    // group owner's games by season (sorted by week)
    const bySeason = new Map();
    scopeGames
      .filter((g) => g.owner === owner)
      .map((g) => ({
        season: Number(g.season),
        week: Number(g.week) || 0,
        res: String(g.res).toUpperCase(),
      }))
      .sort((a, b) => a.season - b.season || a.week - b.week)
      .forEach((g) => {
        if (!bySeason.has(g.season)) bySeason.set(g.season, []);
        bySeason.get(g.season).push(g);
      });

    // use the option’s picker to decide the week they reached the start
    let last = null;
    for (const [season, games] of bySeason.entries()) {
      const wk = opt.seasonWeekPicker(games); // returns week number or null
      if (wk != null) {
        if (
          !last ||
          season > last.season ||
          (season === last.season && wk > (last.week || 0))
        ) {
          last = { season, week: wk };
        }
      }
    }
    return last;
  }

  function lastTimePlacement(owner, selectorKey) {
    // read straight from placementMap
    const byYear = league?.placementMap?.[owner] || {};
    const entries = Object.entries(byYear)
      .map(([yr, place]) => ({ season: Number(yr), place: Number(place) }))
      .filter((r) => Number.isFinite(r.place) && r.place > 0) // playoffs appearance gate
      .sort((a, b) => a.season - b.season);

    let last = null;
    for (const r of entries) {
      if (selectorKey === "PLACED_CHAMP" && r.place === 1)
        last = { season: r.season };
      else if (selectorKey === "PLACED_PLAYOFFS" && r.place > 0)
        last = { season: r.season };
      else if (
        selectorKey === "PLACED_LAST" &&
        r.place === maxPlaceBySeason[r.season]
      )
        last = { season: r.season };
    }
    return last;
  }
  // ── Occurrence finders (for multi-manager AND) ───────────────────────────────

  // points: list of {season, week}
  function allPointsOccurrences(owner, selectorKey) {
    const opt = POINT_OPTIONS.find((o) => o.key === selectorKey);
    if (!opt) return [];
    return scopeGames
      .filter((g) => g.owner === owner)
      .map((g) => ({
        season: Number(g.season),
        week: Number(g.week) || 0,
        pf: pickNum(
          g.pf,
          g.points_for,
          g.points,
          g.score,
          g.owner_points,
          g.pts,
          g.fpts
        ),
      }))
      .filter((r) => Number.isFinite(r.pf) && opt.test(r.pf))
      .map(({ season, week }) => ({ season, week }));
  }

  // record start: list of {season, weekReached}
  function allRecordStartOccurrences(owner, selectorKey) {
    const opt = START_RECORD_OPTIONS.find((o) => o.key === selectorKey);
    if (!opt) return [];
    const bySeason = new Map();
    scopeGames
      .filter((g) => g.owner === owner)
      .map((g) => ({
        season: Number(g.season),
        week: Number(g.week) || 0,
        res: String(g.res).toUpperCase(),
      }))
      .sort((a, b) => a.season - b.season || a.week - b.week)
      .forEach((g) => {
        if (!bySeason.has(g.season)) bySeason.set(g.season, []);
        bySeason.get(g.season).push(g);
      });

    const out = [];
    for (const [season, games] of bySeason.entries()) {
      const wk = opt.seasonWeekPicker(games);
      if (wk != null) out.push({ season, week: wk });
    }
    return out;
  }

  // placement: list of {season} (week null)
  function allPlacementOccurrences(owner, selectorKey) {
    const byYear = league?.placementMap?.[owner] || {};
    const out = [];
    for (const [yr, placeRaw] of Object.entries(byYear)) {
      const season = Number(yr);
      const place = Number(placeRaw);
      if (!Number.isFinite(season) || !Number.isFinite(place) || place <= 0)
        continue;

      if (selectorKey === "PLACED_CHAMP" && place === 1)
        out.push({ season, week: null });
      else if (selectorKey === "PLACED_PLAYOFFS" && place > 0)
        out.push({ season, week: null });
      else if (selectorKey === "PLACED_LAST") {
        const lastMax = maxPlaceBySeason[season];
        if (lastMax && place === lastMax) out.push({ season, week: null });
      }
    }
    return out;
  }

  // unified getter
  function allOccurrences(owner, cat, optKey) {
    if (cat === "points") return allPointsOccurrences(owner, optKey);
    if (cat === "recordStart") return allRecordStartOccurrences(owner, optKey);
    if (cat === "placement") return allPlacementOccurrences(owner, optKey);
    return [];
  }

  // intersection finder: latest season/week where *all* owners satisfied
  function lastTimeAll(owners, cat, optKey) {
    if (!owners.length) return null;

    // Build maps: cat logic for “same moment”
    // - points: same (season, week)
    // - recordStart: same season (week is deterministic per option for everyone)
    // - placement: same season
    const keyOf = (occ) =>
      cat === "points" ? `${occ.season}|${occ.week ?? 0}` : `${occ.season}|*`; // season-only match

    const sets = owners.map(
      (o) => new Set(allOccurrences(o, cat, optKey).map(keyOf))
    );
    if (sets.some((s) => s.size === 0)) return null;

    // intersect
    const [first, ...rest] = sets;
    const inter = [];
    for (const k of first) {
      if (rest.every((s) => s.has(k))) inter.push(k);
    }
    if (!inter.length) return null;

    // pick latest by season/week
    inter.sort((a, b) => {
      const [sa, wa] = a.split("|").map((x) => Number(x === "*" ? 0 : x));
      const [sb, wb] = b.split("|").map((x) => Number(x === "*" ? 0 : x));
      return sa - sb || wa - wb;
    });
    const best = inter[inter.length - 1];
    const [seasonStr, weekStr] = best.split("|");
    const season = Number(seasonStr);
    const week = weekStr === "*" ? null : Number(weekStr);
    return { season, week };
  }

  // Dispatcher per category
  function lastTime(owner, cat, optKey) {
    if (!owner || !optKey) return null;
    if (cat === "points") return lastTimePoints(owner, optKey);
    if (cat === "recordStart") return lastTimeRecordStart(owner, optKey);
    if (cat === "placement") return lastTimePlacement(owner, optKey);
    return null;
  }

  // ---------- Build table rows ----------
  const rows = React.useMemo(() => {
    const targetOwners =
      ownerFilter === "_ALL_"
        ? ownersBase
        : ownersBase.filter((o) => o === ownerFilter);

    return targetOwners.map((o) => {
      const when = lastTime(o, category, option);
      return {
        owner: o,
        season: when?.season ?? null,
        week: when?.week ?? null,
        has: Boolean(when),
      };
    });
  }, [
    ownersBase,
    ownerFilter,
    category,
    option,
    scopeGames,
    league?.placementMap,
    maxPlaceBySeason,
  ]);

  // sorting
  const [sortKey, setSortKey] = React.useState("owner"); // "owner" | "when"
  const [sortDir, setSortDir] = React.useState("asc"); // "asc" | "desc"
  const toggleSort = (key) => {
    if (sortKey === key) setSortDir((d) => (d === "asc" ? "desc" : "asc"));
    else {
      setSortKey(key);
      setSortDir("asc");
    }
  };

  const sortedRows = rows.slice().sort((a, b) => {
    if (sortKey === "owner") {
      const cmp = a.owner.localeCompare(b.owner);
      return sortDir === "asc" ? cmp : -cmp;
    }
    // when: nulls last (asc), first (desc)
    const aKey = a.has
      ? `${a.season.toString().padStart(4, "0")}-${(a.week || 0)
          .toString()
          .padStart(2, "0")}`
      : null;
    const bKey = b.has
      ? `${b.season.toString().padStart(4, "0")}-${(b.week || 0)
          .toString()
          .padStart(2, "0")}`
      : null;

    if (aKey === bKey) return a.owner.localeCompare(b.owner);
    if (aKey == null) return sortDir === "asc" ? 1 : -1;
    if (bKey == null) return sortDir === "asc" ? -1 : 1;
    return sortDir === "asc"
      ? aKey.localeCompare(bKey)
      : bKey.localeCompare(aKey);
  });

  // labels
  const categoryLabel = {
    points: "Points",
    recordStart: "Record start",
    placement: "Placement",
  }[category];

  const optionLabel =
    (categoryOptions[category].find((o) => o.key === option) || {}).label || "";

  // ---------- UI ----------
  return (
    <div className="space-y-4">
      {/* Controls */}
      <Card
        title="Scenarios"
        subtitle="Find the last time each manager hit a condition."
        right={
          <div className="flex items-center gap-2">
            <span className="text-xs text-zinc-500">Scope:</span>
            <select
              className="px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
              value={scope}
              onChange={(e) => setScope(e.target.value)}
            >
              <option value="regular">Regular season</option>
              <option value="playoffs">Playoffs</option>
              <option value="all">All games</option>
            </select>
          </div>
        }
      >
        <div className="grid grid-cols-1 md:grid-cols-5 gap-3">
          <div className="md:col-span-2">
            <div className="text-xs mb-1 opacity-70">Category</div>
            <select
              className="w-full px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
              value={category}
              onChange={(e) => {
                setCategory(e.target.value);
              }}
            >
              <option value="points">Points</option>
              <option value="recordStart">Record start</option>
              <option value="placement">Placement</option>
            </select>
          </div>

          <div className="md:col-span-2">
            <div className="text-xs mb-1 opacity-70">Option</div>
            <div className="flex gap-2">
              <input
                type="text"
                placeholder="Search options…"
                className="flex-1 px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
                value={search}
                onChange={(e) => setSearch(e.target.value)}
              />
              <select
                className="flex-1 px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
                value={option}
                onChange={(e) => setOption(e.target.value)}
              >
                {categoryOptions[category].map((o) => (
                  <option key={o.key} value={o.key}>
                    {o.label}
                  </option>
                ))}
              </select>
            </div>
          </div>

          <div className="md:col-span-1">
            <div className="text-xs mb-1 opacity-70">Manager</div>
            <select
              className="w-full px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700"
              value={ownerFilter}
              onChange={(e) => {
                setOwnerFilter(e.target.value);
                setAndOwners([]); // reset AND list if primary changes
              }}
            >
              <option value="_ALL_">All managers</option>
              {ownersBase.map((o) => (
                <option key={o} value={o}>
                  {o}
                </option>
              ))}
            </select>

            {/* AND selectors */}
            <div className="mt-2 space-y-2">
              {andOwners.map((name, idx) => (
                <div key={idx} className="flex items-center gap-2">
                  <span className="text-xs opacity-70">+ And</span>
                  <select
                    className="flex-1 px-2 py-1 rounded-md bg-white dark:bg-zinc-950 border border-zinc-300 dark:border-zinc-700 text-xs"
                    value={name}
                    onChange={(e) => {
                      const next = andOwners.slice();
                      next[idx] = e.target.value;
                      setAndOwners(next);
                    }}
                  >
                    <option value="">— select —</option>
                    {ownersBase
                      .filter(
                        (o) =>
                          o !== ownerFilter &&
                          !andOwners.some((x, i) => i !== idx && x === o)
                      )
                      .map((o) => (
                        <option key={o} value={o}>
                          {o}
                        </option>
                      ))}
                  </select>
                  <button
                    className="px-2 py-1 rounded-md border border-zinc-300 dark:border-zinc-700 text-xs"
                    onClick={() =>
                      setAndOwners(andOwners.filter((_, i) => i !== idx))
                    }
                    title="Remove"
                  >
                    ✕
                  </button>
                </div>
              ))}

              <button
                className="px-2 py-1 rounded-md border border-zinc-300 dark:border-zinc-700 text-xs"
                onClick={() => setAndOwners([...andOwners, ""])}
                disabled={ownerFilter === "_ALL_"}
                title={
                  ownerFilter === "_ALL_"
                    ? "Pick a primary manager first"
                    : "Add another manager to AND together"
                }
              >
                + Add manager
              </button>
            </div>

            <label className="mt-3 flex items-center gap-2 text-xs">
              <input
                type="checkbox"
                className="checkbox checkbox-xs"
                checked={includeHidden}
                onChange={(e) => setIncludeHidden(e.target.checked)}
              />
              Include hidden managers
            </label>
          </div>
        </div>
      </Card>

      {/* Results */}
      <Card title="Results" subtitle={`${categoryLabel} — ${optionLabel}`}>
        {/* AND summary (only when ownerFilter is a single manager and extra managers are chosen) */}
        {ownerFilter !== "_ALL_" &&
          andOwners.filter(Boolean).length > 0 &&
          (() => {
            const group = [ownerFilter, ...andOwners.filter(Boolean)];
            const joint = lastTimeAll(group, category, option);
            return (
              <div className="mb-3 text-sm">
                <span className="opacity-70">Last time </span>
                <span className="font-medium">{group.join(" + ")}</span>
                <span className="opacity-70"> all matched: </span>
                {joint ? (
                  category === "points" ? (
                    <>
                      S{joint.season} W{fmtWeek(joint.week)}
                    </>
                  ) : (
                    <>S{joint.season}</>
                  )
                ) : (
                  <span className="opacity-60">— never —</span>
                )}
              </div>
            );
          })()}

        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead>
              <tr className="text-left border-b border-zinc-200 dark:border-zinc-800">
                <th
                  className="py-2 pr-3 cursor-pointer select-none"
                  onClick={() => toggleSort("owner")}
                >
                  Manager{" "}
                  {sortKey === "owner" ? (sortDir === "asc" ? "▲" : "▼") : ""}
                </th>
                <th
                  className="py-2 pr-3 cursor-pointer select-none"
                  onClick={() => toggleSort("when")}
                >
                  Last time{" "}
                  {sortKey === "when" ? (sortDir === "asc" ? "▲" : "▼") : ""}
                </th>
              </tr>
            </thead>
            <tbody>
              {(() => {
                // Decide which names to render
                const names =
                  ownerFilter !== "_ALL_" &&
                  andOwners.filter(Boolean).length > 0
                    ? [ownerFilter, ...andOwners.filter(Boolean)]
                    : sortedRows.map((r) => r.owner);

                // De-dupe (just in case)
                const uniqueNames = Array.from(new Set(names));

                if (uniqueNames.length === 0) {
                  return (
                    <tr>
                      <td colSpan={2} className="py-6 text-center opacity-70">
                        No managers to show.
                      </td>
                    </tr>
                  );
                }

                return uniqueNames.map((name) => {
                  // Find the computed row for this manager (or a blank fallback)
                  const r = sortedRows.find((x) => x.owner === name) || {
                    has: false,
                    season: null,
                    week: null,
                  };

                  return (
                    <tr
                      key={name}
                      className="border-b border-zinc-100/50 dark:border-zinc-800"
                    >
                      <td className="py-2 pr-3">{name}</td>
                      <td className="py-2 pr-3 text-zinc-200">
                        {r.has ? (
                          category === "placement" ? (
                            <>S{r.season}</>
                          ) : (
                            <>
                              S{r.season} W{fmtWeek(r.week)}
                            </>
                          )
                        ) : (
                          <span className="opacity-60">— never —</span>
                        )}
                      </td>
                    </tr>
                  );
                });
              })()}
            </tbody>
          </table>
        </div>
      </Card>

      {/* Footnote */}
      <Card>
        <div className="text-xs text-zinc-500">
          Notes: Points scenarios use finished games in the selected scope.
          “Record start” checks the first N weeks of each season (per manager).
          “Placement” uses final standings from your data.
        </div>
      </Card>
    </div>
  );
}
//---------------------------------LuckIndex-------------------
export function LuckIndexTab({
  league,
  rawRows = [],
  rostersByYear = {},
  playerProjByYear = {},
  currentWeekByYear: currentWeekByYearOverride = {},
  draftByYear = {},
}) {
  if (!league) return null;
  const hiddenManagersSet = React.useMemo(
    () =>
      new Set(
        Array.isArray(league?.hiddenManagers) ? league.hiddenManagers : []
      ),
    [league?.hiddenManagers]
  );
  if (typeof window !== "undefined") {
    window.__LDEBUG = {
      rostersByYear,
      seasonsByYear: league?.seasonsByYear,
      ownerByTeamByYear: league?.ownerByTeamByYear,
      currentWeekByYear:
        league?.currentWeekByYear || currentWeekByYearOverride || {},
    };
  }

  // unified owner resolver: prefer ownerMaps; fallback to league.ownerByTeamByYear
  const ownerNameOf = React.useCallback(
    (season, teamId) => {
      try {
        if (window.__ownerMaps?.name) {
          const nm = window.__ownerMaps.name(Number(season), Number(teamId));
          if (nm) return nm;
        }
      } catch {}
      const g = (obj, ...ks) =>
        ks.reduce((o, k) => (o == null ? o : o[k]), obj);
      return (
        g(league, "ownerByTeamByYear", season, teamId) ||
        g(league, "ownerByTeamByYear", String(season), teamId) ||
        g(league, "ownerByTeamByYear", season, String(teamId)) ||
        g(league, "ownerByTeamByYear", String(season), String(teamId)) ||
        null
      );
    },
    [league]
  );

  function getGamesFlexible(league) {
    const out = [];

    // 1) Already-normalized games (must include team objects/ids)
    if (Array.isArray(league?.games) && league.games.length) {
      const normalized = [];
      for (const g of league.games) {
        const season = Number(g?.season ?? g?.year);
        const week = Number(
          g?.week ?? g?.matchupPeriodId ?? g?.scoringPeriodId ?? g?.period
        );
        const raw1 = g?.team1 ?? g?.home ?? g?.homeTeam ?? g?.team1Id ?? null;
        const raw2 = g?.team2 ?? g?.away ?? g?.awayTeam ?? g?.team2Id ?? null;

        const teamId1 = Number(
          raw1?.teamId ?? raw1?.team?.id ?? raw1?.id ?? raw1
        );
        const teamId2 = Number(
          raw2?.teamId ?? raw2?.team?.id ?? raw2?.id ?? raw2
        );

        if (!season || !week || !teamId1 || !teamId2) continue;

        const score1 = Number(
          raw1?.score ??
            raw1?.totalPoints ??
            g?.team1Score ??
            g?.homeScore ??
            g?.pf ??
            g?.pointsFor ??
            0
        );
        const score2 = Number(
          raw2?.score ??
            raw2?.totalPoints ??
            g?.team2Score ??
            g?.awayScore ??
            g?.pa ??
            g?.pointsAgainst ??
            0
        );

        normalized.push({
          season,
          week,
          team1: {
            teamId: teamId1,
            score: Number.isFinite(score1) ? score1 : 0,
            projected: Number.isFinite(projected1) ? projected1 : null,
          },
          team2: {
            teamId: teamId2,
            score: Number.isFinite(score2) ? score2 : 0,
            projected: Number.isFinite(projected2) ? projected2 : null,
          },
          is_playoff:
            g?.is_playoff ??
            g?.isPlayoff ??
            g?.playoffMatchup ??
            (typeof g?.playoffTierType === "string" &&
              g.playoffTierType.toUpperCase() !== "NONE"),
        });
      }
      if (normalized.length) {
        console.log(
          "[Luck] using league.games (normalized):",
          normalized.length
        );
        return normalized;
      }
    }

    // 2) seasonsByYear[year].schedule[]
    const sb = league?.seasonsByYear;
    if (sb && typeof sb === "object") {
      for (const [yStr, seasonObj] of Object.entries(sb)) {
        const y = Number(yStr);
        const sched = seasonObj?.schedule || [];
        for (const m of sched) {
          const w = Number(
            m?.matchupPeriodId ?? m?.scoringPeriodId ?? m?.week ?? 0
          );
          const h = m?.home ?? m?.homeTeam ?? {};
          const a = m?.away ?? m?.awayTeam ?? {};

          const t1 = Number(h?.teamId ?? h?.team?.id ?? h?.id);
          const t2 = Number(a?.teamId ?? a?.team?.id ?? a?.id);

          // prefer totalPoints for each side; fall back to pointsByScoringPeriod[week]
          const pickSideScore = (side) => {
            const total = Number(side?.totalPoints);
            if (Number.isFinite(total)) return total;
            const byWk = side?.pointsByScoringPeriod;
            const wkVal = Number(byWk?.[w]);
            return Number.isFinite(wkVal) ? wkVal : 0;
          };
          const s1 = pickSideScore(h);
          const s2 = pickSideScore(a);
          const p1 = pickSideProjected(h);
          const p2 = pickSideProjected(a);

          if (y && w && t1 && t2) {
            out.push({
              season: y,
              week: w,
              team1: { teamId: t1, score: s1, projected: p1 },
              team2: { teamId: t2, score: s2, projected: p2 },
              is_playoff: m?.playoffTierType && m.playoffTierType !== "NONE",
            });
          }
        }
      }
      if (out.length) {
        console.log("[Luck] using seasonsByYear.schedule:", out.length);
        return out;
      }
    }

    // 3) window.name seasons (fallback)
    try {
      const payload = JSON.parse(window.name || "{}");
      const seasons = payload?.seasons || payload?.seasonObjs || [];
      for (const s of seasons) {
        const y = Number(s?.seasonId);
        for (const m of s?.schedule || []) {
          const w = Number(
            m?.matchupPeriodId ?? m?.scoringPeriodId ?? m?.week ?? 0
          );
          const h = m?.home ?? m?.homeTeam ?? {};
          const a = m?.away ?? m?.awayTeam ?? {};
          const t1 = Number(h?.teamId ?? h?.team?.id ?? h?.id);
          const t2 = Number(a?.teamId ?? a?.team?.id ?? a?.id);
          const s1 = Number(h?.totalPoints ?? 0) || 0;
          const s2 = Number(a?.totalPoints ?? 0) || 0;
          if (y && w && t1 && t2) {
            out.push({
              season: y,
              week: w,
              team1: { teamId: t1, score: s1 },
              team2: { teamId: t2, score: s2 },
              is_playoff: m?.playoffTierType && m.playoffTierType !== "NONE",
            });
          }
        }
      }
      if (out.length) {
        console.log("[Luck] using window.name seasons:", out.length);
        return out;
      }
    } catch {}

    console.warn(
      "[Luck] No games found. Expect league.seasonsByYear[year].schedule[]"
    );
    return out;
  }
  const get = React.useCallback(
    (obj, ...keys) => keys.reduce((o, k) => (o == null ? o : o[k]), obj),
    []
  );
  const yn = (y) => [y, String(y)];
  const tn = (t) => [t, String(t)];
  const wn = (w) => [w, String(w)];
  const resolveCurrentWeekExclusive = React.useCallback(
    (seasonKey) => {
      const candidates = new Set();
      const pushCandidate = (value) => {
        const n = Number(value);
        if (Number.isFinite(n) && n > 0) {
          candidates.add(Math.floor(n));
        }
      };

      const possibleKeys = (() => {
        const num = Number(seasonKey);
        const list = [seasonKey];
        if (Number.isFinite(num)) list.push(num);
        const str = String(seasonKey);
        if (str !== seasonKey) list.push(str);
        if (Number.isFinite(num)) {
          const numStr = String(num);
          if (!list.includes(numStr)) list.push(numStr);
        }
        return Array.from(new Set(list.filter((k) => k != null)));
      })();

      const pushFromSource = (source, key) => {
        if (source == null) return;
        if (typeof source === "number" || typeof source === "string") {
          pushCandidate(source);
          return;
        }
        if (typeof source.get === "function") {
          const direct = source.get(key);
          if (direct != null) pushCandidate(direct);
          const alt = source.get(String(key));
          if (alt != null) pushCandidate(alt);
        }
        if (typeof source === "object") {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            pushCandidate(source[key]);
          }
          const keyStr = String(key);
          if (Object.prototype.hasOwnProperty.call(source, keyStr)) {
            pushCandidate(source[keyStr]);
          }
        }
      };

      for (const key of possibleKeys) {
        pushFromSource(league?.currentWeekByYear, key);
        pushFromSource(league?.espnCurrentWeekBySeason, key);
        pushFromSource(league?.currentWeekBySeason, key);
        pushFromSource(currentWeekByYearOverride, key);
        pushFromSource(league?.currentWeek, key);
      }

      for (const key of possibleKeys) {
        const seasonInfo =
          get(league, "seasonsByYear", key) ??
          get(league, "seasonsByYear", Number(key));
        if (!seasonInfo) continue;
        pushCandidate(seasonInfo?.currentWeek);
        pushCandidate(seasonInfo?.currentMatchupPeriod);
        pushCandidate(seasonInfo?.currentMatchupPeriodId);
        pushCandidate(seasonInfo?.status?.currentMatchupPeriod);
        pushCandidate(seasonInfo?.status?.currentScoringPeriod);
        pushCandidate(seasonInfo?.status?.latestScoringPeriod);
        pushCandidate(seasonInfo?.status?.matchupPeriodId);
      }

      if (!candidates.size) return 0;
      return Math.max(...candidates);
    },
    [league, get, currentWeekByYearOverride]
  );

  // --- Build name index (playerId → name) from existing rosters ---
  const nameIndex = React.useMemo(() => {
    const idx = new Map();
    for (const [season, byTeam] of Object.entries(rostersByYear || {})) {
      for (const byWeek of Object.values(byTeam || {})) {
        for (const arr of Object.values(byWeek || {})) {
          for (const r of arr || []) {
            const key = `${season}|${r.pid}`;
            if (!idx.has(key) && r?.name) idx.set(key, r.name);
          }
        }
      }
    }
    return idx;
  }, [rostersByYear]);

  const seasons = React.useMemo(() => {
    const set = new Set();
    (rawRows || []).forEach((row) => {
      if (row?.season) set.add(Number(row.season));
    });
    if (Array.isArray(league?.seasons)) {
      league.seasons.forEach((s) => set.add(Number(s)));
    }
    Object.keys(league?.ownerByTeamByYear || {}).forEach((s) =>
      set.add(Number(s))
    );
    return Array.from(set).sort((a, b) => a - b);
  }, [league, rawRows]);

  const ownersBase = React.useMemo(() => {
    const set = new Set();
    (rawRows || []).forEach((row) => {
      if (row?.manager) set.add(row.manager);
    });
    Object.values(league?.ownerByTeamByYear || {}).forEach((byTeam) => {
      Object.values(byTeam || {}).forEach((owner) => {
        if (owner) set.add(owner);
      });
    });
    return Array.from(set)
      .filter((name) => !hiddenManagersSet.has(name))
      .sort((a, b) => a.localeCompare(b));
  }, [league, rawRows, hiddenManagersSet]);
  const START_SLOTS = React.useMemo(
    () => new Set([0, 2, 3, 4, 5, 6, 7, 16, 17, 23]),
    []
  );

  // build starters-only totals per (year, teamId, week)
  const teamWeekTotals = React.useMemo(() => {
    const totals = {};
    for (const [yStr, byTeam] of Object.entries(rostersByYear || {})) {
      const y = Number(yStr);
      const capExclusive = resolveCurrentWeekExclusive(yStr);
      totals[y] = totals[y] || {};
      for (const [tidStr, byWeek] of Object.entries(byTeam || {})) {
        const tid = Number(tidStr);
        totals[y][tid] = totals[y][tid] || {};
        for (const [wStr, entries] of Object.entries(byWeek || {})) {
          const w = Number(wStr);
          if (capExclusive > 0 && w >= capExclusive) continue;
          let proj = 0,
            actual = 0;
          for (const e of entries || []) {
            const sid = Number(__entrySlotId(e));
            if (!START_SLOTS.has(sid)) continue;
            proj += __entryProj(e);
            actual += __entryPts(e);
          }
          totals[y][tid][w] = { proj, actual };
        }
      }
    }
    return totals;
  }, [rostersByYear, resolveCurrentWeekExclusive]);

  const games = React.useMemo(() => getGamesFlexible(league), [league]);
  const draftIndexByYear = React.useMemo(() => {
    const map = new Map();
    const toNumber = (v) => {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    };

    for (const [seasonKey, picks] of Object.entries(draftByYear || {})) {
      const seasonNum = Number(seasonKey);
      if (!Number.isFinite(seasonNum)) continue;

      const pidMap = new Map();
      let maxRound = 0;

      for (const pick of picks || []) {
        const pid = toNumber(
          pick?.playerId ??
            pick?.pid ??
            pick?.player?.id ??
            pick?.player?.playerId
        );
        if (!Number.isFinite(pid)) continue;

        let round = toNumber(
          pick?.round ??
            pick?.roundNumber ??
            pick?.round_num ??
            pick?.roundId ??
            pick?.roundIndex
        );
        if (round != null && round <= 0) round = null;

        const overall = toNumber(
          pick?.overall ??
            pick?.overallPick ??
            pick?.pick ??
            pick?.pickNumber ??
            pick?.overallSelection ??
            pick?.overall_index
        );

        if (round != null && round > maxRound) {
          maxRound = round;
        }

        const existing = pidMap.get(pid);
        const record = {
          round: round != null ? round : null,
          overall: overall != null && overall > 0 ? overall : null,
        };

        if (!existing) {
          pidMap.set(pid, record);
        } else {
          const prevRound = existing.round;
          if (
            record.round != null &&
            (prevRound == null || record.round < prevRound)
          ) {
            pidMap.set(pid, record);
          } else if (prevRound == null && record.round == null) {
            const prevOverall = existing.overall;
            if (
              record.overall != null &&
              (prevOverall == null || record.overall < prevOverall)
            ) {
              pidMap.set(pid, record);
            }
          }
        }
      }

      map.set(seasonNum, {
        pidMap,
        maxRound: maxRound > 0 ? maxRound : null,
      });
    }

    return map;
  }, [draftByYear]);

  const comp1Data = React.useMemo(() => {
    const totals = {};
    const details = {};
    const num = (v) => (Number.isFinite(+v) ? +v : 0);

    // helper to fetch totals with string/number keys
    const getTotals = (y, t, w) =>
      get(teamWeekTotals, y, t, w) ??
      get(teamWeekTotals, y, t, String(w)) ??
      get(teamWeekTotals, y, String(t), w) ??
      get(teamWeekTotals, y, String(t), String(w)) ??
      get(teamWeekTotals, String(y), t, w) ??
      get(teamWeekTotals, String(y), t, String(w)) ??
      get(teamWeekTotals, String(y), String(t), w) ??
      get(teamWeekTotals, String(y), String(t), String(w)) ??
      null;

    for (const g of games || []) {
      const y = num(g?.season);
      const w = num(g?.week);
      const t1 = num(g?.team1?.teamId ?? g?.t1 ?? g?.team1);
      const t2 = num(g?.team2?.teamId ?? g?.t2 ?? g?.team2);
      if (!y || !w || !t1 || !t2) continue;

      // respect currentWeek cap
      const capExclusive = resolveCurrentWeekExclusive(y);
      if (capExclusive > 0 && w >= capExclusive) continue;
      // resolve owners
      const o1 = ownerNameOf(y, t1);
      const o2 = ownerNameOf(y, t2);
      if (!o1 || !o2) continue;

      // opponent totals (proj/actual); if missing, fall back to boxscore actual and proj=0
      const tOpp1 = getTotals(y, t2, w);
      const tOpp2 = getTotals(y, t1, w);

      const opp1Proj = num(tOpp1?.proj ?? 0);
      const opp1Act = num(tOpp1?.actual ?? g?.team2?.score ?? 0);

      const opp2Proj = num(tOpp2?.proj ?? 0);
      const opp2Act = num(tOpp2?.actual ?? g?.team1?.score ?? 0);

      const d1 = opp1Proj - opp1Act; // + means your opponent underperformed (you were lucky)
      const d2 = opp2Proj - opp2Act;

      totals[o1] ??= {};
      totals[o1][y] = (totals[o1][y] || 0) + d1;
      totals[o2] ??= {};
      totals[o2][y] = (totals[o2][y] || 0) + d2;

      const pushDetail = (owner, yr, entry) => {
        details[owner] ??= {};
        details[owner][yr] ??= [];
        details[owner][yr].push(entry);
      };

      pushDetail(o1, y, {
        week: w,
        opponentOwner: o2,
        opponentTeamId: t2,
        opponentProjected: opp1Proj,
        opponentActual: opp1Act,
        diff: d1,
      });

      pushDetail(o2, y, {
        week: w,
        opponentOwner: o1,
        opponentTeamId: t1,
        opponentProjected: opp2Proj,
        opponentActual: opp2Act,
        diff: d2,
      });
    }

    console.log("[Luck] comp1 (opp proj - opp actual) by owner/year:", totals);
    return { totals, details };
  }, [games, teamWeekTotals, resolveCurrentWeekExclusive, ownerNameOf]);
  const comp2Data = React.useMemo(() => {
    const totals = {};
    const details = {};
    const proTeamLookupCache = new Map();
    const getProTeamLookup = (seasonKey) => {
      const cacheKey = String(seasonKey ?? "");
      if (proTeamLookupCache.has(cacheKey)) {
        return proTeamLookupCache.get(cacheKey);
      }
      const lookup = __buildProTeamLookup(
        __resolveProTeamsForSeason(seasonKey, league)
      );
      proTeamLookupCache.set(cacheKey, lookup);
      return lookup;
    };

    const resolvePlayerId = (entry) => {
      const cand =
        entry?.pid ??
        entry?.playerId ??
        entry?.player?.id ??
        entry?.playerPoolEntry?.player?.id;
      const id = Number(cand);
      return Number.isFinite(id) ? id : null;
    };

    const resolvePlayerName = (seasonKey, seasonNum, entry) => {
      const playerNameParts = [
        entry?.player?.firstName,
        entry?.player?.lastName,
      ]
        .filter(Boolean)
        .join(" ")
        .trim();
      const poolNameParts = [
        entry?.playerPoolEntry?.player?.firstName,
        entry?.playerPoolEntry?.player?.lastName,
      ]
        .filter(Boolean)
        .join(" ")
        .trim();

      const direct =
        entry?.name ??
        entry?.playerName ??
        entry?.player?.fullName ??
        entry?.player?.name ??
        (playerNameParts ? playerNameParts : undefined) ??
        entry?.playerPoolEntry?.player?.fullName ??
        entry?.playerPoolEntry?.player?.name ??
        (poolNameParts ? poolNameParts : undefined);
      if (direct) return direct;

      const pid = resolvePlayerId(entry);
      if (pid != null) {
        const keyA = `${seasonKey}|${pid}`;
        const keyB = `${seasonNum}|${pid}`;
        if (nameIndex.has(keyA)) return nameIndex.get(keyA);
        if (nameIndex.has(keyB)) return nameIndex.get(keyB);
      }
      return "Unknown Player";
    };

    const pushDetail = (owner, season, row) => {
      details[owner] ??= {};
      details[owner][season] ??= [];
      details[owner][season].push(row);
    };

    for (const [seasonKey, byTeam] of Object.entries(rostersByYear || {})) {
      const seasonNum = Number(seasonKey);
      const currentWeekExclusive = resolveCurrentWeekExclusive(seasonKey);
      const proTeamLookup = getProTeamLookup(seasonKey);
      for (const [teamKey, byWeek] of Object.entries(byTeam || {})) {
        const teamId = Number(teamKey);
        const owner = ownerNameOf(seasonNum, teamId) || `Team ${teamId}`;
        if (!owner) continue;

        for (const [weekKey, entries] of Object.entries(byWeek || {})) {
          const weekNum = Number(weekKey);
          if (currentWeekExclusive > 0 && weekNum >= currentWeekExclusive)
            continue; // only completed weeks (match comp1 logic)
          const seen = new Set();

          for (const entry of entries || []) {
            const slotId = Number(__entrySlotId(entry));
            if (__entryIsOnByeForWeek(entry, weekNum)) continue;
            const proj = __entryProj(entry);
            if (proj > 0) continue;
            if (__entryHasTeamBye(entry, weekNum, proTeamLookup)) continue;

            const pid = resolvePlayerId(entry);
            const seenKey =
              pid != null ? `pid:${pid}` : `slot:${slotId}|${weekNum}`;
            if (seen.has(seenKey)) continue;
            seen.add(seenKey);

            totals[owner] ??= {};
            totals[owner][seasonNum] = (totals[owner][seasonNum] || 0) + 1;

            pushDetail(owner, seasonNum, {
              week: weekNum,
              player: resolvePlayerName(seasonKey, seasonNum, entry),
              slot: __SLOT_LABEL[slotId] || `Slot ${slotId}`,
              pid,
              projection: proj,
            });
          }
        }
      }
    }

    console.log(
      "[Luck] comp2 (injury weeks via proj=0) by owner/year:",
      totals
    );
    return { totals, details };
  }, [
    rostersByYear,
    league?.currentWeekByYear,
    resolveCurrentWeekExclusive,
    ownerNameOf,
    nameIndex,
    START_SLOTS,
    league?.proTeamsByYear,
    league?.seasonsByYear,
    league?.proTeams,
  ]);

  // This IS the Luck Index for now
  const comp1ByOwnerYear = comp1Data.totals;
  const comp1DetailByOwnerYear = comp1Data.details;
  const injuryByOwnerYear = comp2Data.totals;
  const injuryDetailByOwnerYear = comp2Data.details;
  const [injuryViewMode, setInjuryViewMode] = React.useState("raw");
  const [injuryWeightAlpha, setInjuryWeightAlpha] = React.useState(1);
  const [injuryWaiverRound, setInjuryWaiverRound] = React.useState(12);
  const normalizedWaiverRound = React.useMemo(
    () =>
      Math.max(
        1,
        Math.round(Number.isFinite(injuryWaiverRound) ? injuryWaiverRound : 12)
      ),
    [injuryWaiverRound]
  );
  const getBaseRoundForSeason = React.useCallback(
    (season) => {
      const seasonNum = Number(season);
      const meta = draftIndexByYear.get(seasonNum);
      const maxRound =
        meta && Number.isFinite(meta.maxRound) && meta.maxRound > 0
          ? Math.round(meta.maxRound)
          : null;
      return Math.max(1, normalizedWaiverRound, maxRound ?? 0);
    },
    [draftIndexByYear, normalizedWaiverRound]
  );
  const injuryWeightedByOwnerYear = React.useMemo(() => {
    const totals = {};
    const details = {};

    for (const [owner, seasons] of Object.entries(
      injuryDetailByOwnerYear || {}
    )) {
      for (const [seasonKey, rows] of Object.entries(seasons || {})) {
        const seasonNum = Number(seasonKey);
        const meta = draftIndexByYear.get(seasonNum);
        const baseRound = getBaseRoundForSeason(seasonNum);
        let sum = 0;
        const detailRows = (rows || []).map((row) => {
          const pid = Number(row?.pid);
          const info =
            Number.isFinite(pid) && meta?.pidMap ? meta.pidMap.get(pid) : null;
          const draftedRound =
            info && Number.isFinite(info.round) && info.round > 0
              ? Number(info.round)
              : null;
          const draftedOverall =
            info && Number.isFinite(info.overall) && info.overall > 0
              ? Number(info.overall)
              : null;
          const fallbackRound =
            draftedRound != null ? draftedRound : normalizedWaiverRound;
          const roundClamped = Math.min(
            Math.max(1, Math.round(fallbackRound)),
            baseRound
          );
          const base = baseRound + 1 - roundClamped;
          const weight = Math.pow(base, injuryWeightAlpha);
          sum += weight;
          return {
            ...row,
            draftRound: draftedRound,
            draftOverall: draftedOverall,
            weight,
            weightRound: roundClamped,
            weightBaseRound: baseRound,
            weightSource: draftedRound != null ? "draft" : "waiver",
          };
        });

        if (!totals[owner]) totals[owner] = {};
        if (!details[owner]) details[owner] = {};
        totals[owner][seasonNum] = sum;
        details[owner][seasonNum] = detailRows;
      }
    }

    return { totals, details };
  }, [
    injuryDetailByOwnerYear,
    draftIndexByYear,
    getBaseRoundForSeason,
    injuryWeightAlpha,
    normalizedWaiverRound,
  ]);
  const luckByOwnerYear = comp1ByOwnerYear;
  // Now that comp1 exists, build the owners list (base + any seen in results)
  // Now that comp1 exists, build the owners list (base + any seen in results), sorted
  const owners = React.useMemo(() => {
    const s = new Set(ownersBase);
    Object.keys(comp1ByOwnerYear || {}).forEach((o) => s.add(o));
    Object.keys(injuryByOwnerYear || {}).forEach((o) => s.add(o));
    return Array.from(s)
      .filter((name) => !hiddenManagersSet.has(name))
      .sort((a, b) => a.localeCompare(b));
  }, [ownersBase, comp1ByOwnerYear, injuryByOwnerYear, hiddenManagersSet]);
  const [comp1Detail, setComp1Detail] = React.useState(null);
  React.useEffect(() => {
    if (comp1Detail?.owner && hiddenManagersSet.has(comp1Detail.owner)) {
      setComp1Detail(null);
    }
  }, [comp1Detail, hiddenManagersSet]);
  const [comp2Detail, setComp2Detail] = React.useState(null);
  React.useEffect(() => {
    if (comp2Detail?.owner && hiddenManagersSet.has(comp2Detail.owner)) {
      setComp2Detail(null);
    }
  }, [comp2Detail, hiddenManagersSet]);

  // --- Table helper ---
  const fmt = (n) => (Number.isFinite(n) ? n.toFixed(1) : "—");
  const fmtInjuryValue = React.useCallback(
    (v) => {
      if (!Number.isFinite(v)) return "—";
      return injuryViewMode === "weighted"
        ? Number(v).toFixed(2)
        : Math.round(Number(v)).toString();
    },
    [injuryViewMode]
  );
  const isWeightedView = injuryViewMode === "weighted";
  const injuryTotalsSource = isWeightedView
    ? injuryWeightedByOwnerYear.totals
    : injuryByOwnerYear;
  const injuryDetailSource = isWeightedView
    ? injuryWeightedByOwnerYear.details
    : injuryDetailByOwnerYear;
  const comp2RawRowsForDetail =
    comp2Detail?.owner != null && comp2Detail?.season != null
      ? injuryDetailByOwnerYear?.[comp2Detail.owner]?.[comp2Detail.season] || []
      : [];
  const comp2WeightedRowsForDetail =
    comp2Detail?.owner != null && comp2Detail?.season != null
      ? injuryWeightedByOwnerYear.details?.[comp2Detail.owner]?.[
          comp2Detail.season
        ] || []
      : [];
  const comp2DetailRows = isWeightedView
    ? comp2WeightedRowsForDetail
    : comp2RawRowsForDetail;
  const comp2RawCount = comp2RawRowsForDetail.length;
  const comp2WeightedTotal =
    comp2Detail?.owner != null && comp2Detail?.season != null
      ? injuryWeightedByOwnerYear.totals?.[comp2Detail.owner]?.[
          comp2Detail.season
        ] ?? 0
      : 0;
  const comp2BaseRoundForDetail =
    comp2Detail?.season != null
      ? getBaseRoundForSeason(comp2Detail.season)
      : normalizedWaiverRound;
  return (
    <div className="space-y-6">
      {/* ===== Master Luck Index Table ===== */}
      <Card title="Luck Index (Experimental)">
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm border-collapse">
            <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
              <tr className="border-b border-zinc-300 dark:border-zinc-700">
                <th className="px-3 py-2 text-left">Manager</th>
                {seasons.map((y) => (
                  <th key={y} className="px-3 py-2 text-center">
                    {y}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700">
              {owners.map((o) => (
                <tr key={o}>
                  <td className="px-3 py-2 font-medium">{o}</td>
                  {seasons.map((y) => (
                    <td key={y} className="px-3 py-2 text-center tabular-nums">
                      {fmt(luckByOwnerYear[o]?.[y])}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </Card>

      {/* ===== Component Breakdown ===== */}
      <Card title="Luck Components (Preview)">
        <Card title="Component 1 — Opponent vs Projection (sum to date)">
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm border-collapse">
              <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
                <tr className="border-b border-zinc-300 dark:border-zinc-700">
                  <th className="px-3 py-2 text-left">Manager</th>
                  {seasons.map((y) => (
                    <th key={y} className="px-3 py-2 text-center">
                      {y}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700">
                {owners.map((o) => (
                  <tr key={o}>
                    <td className="px-3 py-2 font-medium">{o}</td>
                    {seasons.map((y) => {
                      const v = comp1ByOwnerYear?.[o]?.[y];
                      return (
                        <td
                          key={y}
                          className="px-3 py-2 text-center tabular-nums"
                        >
                          {Number.isFinite(v) &&
                          (comp1DetailByOwnerYear?.[o]?.[y] || []).length ? (
                            <button
                              type="button"
                              className="underline decoration-dotted text-blue-600 hover:text-blue-800 dark:text-blue-300"
                              onClick={() =>
                                setComp1Detail({
                                  owner: o,
                                  season: y,
                                  rows: (
                                    comp1DetailByOwnerYear?.[o]?.[y] || []
                                  ).slice(),
                                })
                              }
                            >
                              {v.toFixed(1)}
                            </button>
                          ) : Number.isFinite(v) ? (
                            v.toFixed(1)
                          ) : (
                            "—"
                          )}
                        </td>
                      );
                    })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </Card>
        <Card title="Component 2 — Injury Index (Player-Weeks Lost)">
          <div className="px-3 pt-3 pb-2 flex flex-wrap items-center gap-3 text-sm text-zinc-600 dark:text-zinc-400">
            <div className="flex items-center gap-2">
              <span className="font-medium">View:</span>
              <button
                type="button"
                className={`px-2.5 py-1 rounded border text-sm font-medium transition-colors ${
                  injuryViewMode === "raw"
                    ? "bg-blue-600 text-white border-blue-600 hover:bg-blue-500 dark:bg-blue-500 dark:border-blue-500 dark:hover:bg-blue-400"
                    : "bg-zinc-100 text-zinc-700 border-zinc-200 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-200 dark:border-zinc-700 dark:hover:bg-zinc-700"
                }`}
                onClick={() => setInjuryViewMode("raw")}
              >
                Raw count
              </button>
              <button
                type="button"
                className={`px-2.5 py-1 rounded border text-sm font-medium transition-colors ${
                  injuryViewMode === "weighted"
                    ? "bg-blue-600 text-white border-blue-600 hover:bg-blue-500 dark:bg-blue-500 dark:border-blue-500 dark:hover:bg-blue-400"
                    : "bg-zinc-100 text-zinc-700 border-zinc-200 hover:bg-zinc-200 dark:bg-zinc-800 dark:text-zinc-200 dark:border-zinc-700 dark:hover:bg-zinc-700"
                }`}
                onClick={() => setInjuryViewMode("weighted")}
              >
                Weighted
              </button>
            </div>
            {isWeightedView && (
              <>
                <label className="flex items-center gap-2">
                  <span className="whitespace-nowrap">Waiver round</span>
                  <input
                    type="number"
                    min={1}
                    max={30}
                    step={1}
                    value={injuryWaiverRound}
                    onChange={(e) => {
                      const raw = e.target.value;
                      if (raw === "") {
                        setInjuryWaiverRound(1);
                        return;
                      }
                      const next = Number(raw);
                      if (Number.isFinite(next)) {
                        const clamped = Math.min(
                          30,
                          Math.max(1, Math.round(next))
                        );
                        setInjuryWaiverRound(clamped);
                      }
                    }}
                    className="w-16 rounded border border-zinc-300 bg-white px-2 py-1 text-sm text-zinc-700 focus:outline-none focus:ring-2 focus:ring-blue-500 dark:border-zinc-700 dark:bg-zinc-900 dark:text-zinc-100"
                  />
                </label>
                <label className="flex items-center gap-2">
                  <span>α</span>
                  <input
                    type="range"
                    min={0}
                    max={3}
                    step={0.1}
                    value={injuryWeightAlpha}
                    onChange={(e) =>
                      setInjuryWeightAlpha(Number(e.target.value))
                    }
                    className="w-32 accent-blue-600"
                  />
                  <span className="tabular-nums w-10 text-right">
                    {injuryWeightAlpha.toFixed(2)}
                  </span>
                </label>
              </>
            )}
          </div>
          {isWeightedView && (
            <div className="px-3 pb-2 text-xs text-zinc-500 dark:text-zinc-400">
              Weight = (baseRound + 1 {"\u2212"} round)^α; baseRound is the
              larger of a season’s max draft round and the waiver round
              (currently treated as R{normalizedWaiverRound}). Players without
              draft data use the waiver round.
            </div>
          )}
          <div className="overflow-x-auto">
            <table className="min-w-full text-sm border-collapse">
              <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
                <tr className="border-b border-zinc-300 dark:border-zinc-700">
                  <th className="px-3 py-2 text-left">Manager</th>
                  {seasons.map((y) => (
                    <th key={y} className="px-3 py-2 text-center">
                      {y}
                    </th>
                  ))}
                </tr>
              </thead>
              <tbody className="divide-y divide-zinc-200 dark:divide-zinc-700">
                {owners.map((o) => (
                  <tr key={`${o}-injury`}>
                    <td className="px-3 py-2 font-medium">{o}</td>
                    {seasons.map((y) => {
                      const v = injuryTotalsSource?.[o]?.[y];
                      const detailRows = injuryDetailSource?.[o]?.[y] || [];
                      const hasDetail =
                        Number.isFinite(v) && detailRows.length > 0;
                      return (
                        <td
                          key={`${y}-injury`}
                          className="px-3 py-2 text-center tabular-nums"
                        >
                          {hasDetail ? (
                            <button
                              type="button"
                              className="underline decoration-dotted text-blue-600 hover:text-blue-800 dark:text-blue-300"
                              onClick={() =>
                                setComp2Detail({
                                  owner: o,
                                  season: y,
                                })
                              }
                            >
                              {fmtInjuryValue(v)}
                            </button>
                          ) : Number.isFinite(v) ? (
                            fmtInjuryValue(v)
                          ) : (
                            "—"
                          )}
                        </td>
                      );
                    })}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </Card>

        <div className="text-sm text-zinc-500 space-y-2">
          <p>
            Component 1: Opponent Overperformance — how much opponents exceeded
            projections.
          </p>
          <p>
            Component 2: Injury Index — total starter player-weeks with a zero
            projection (proxy for weeks lost to injury). Weighted view applies a
            draft-round multiplier to emphasize early picks.
          </p>
          <p>Component 3: TBD (future feature).</p>
          <p>Additional ideas below.</p>
        </div>
      </Card>

      {comp1Detail && (
        <div className="fixed inset-0 z-50 flex items-center justify-center">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setComp1Detail(null)}
          />
          <div className="relative w-full max-w-3xl rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-xl max-h-[85vh] flex flex-col">
            <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 sticky top-0 bg-white dark:bg-zinc-900 z-10">
              <div className="text-base font-semibold">
                {comp1Detail.owner} — {comp1Detail.season} Opponent Luck
                Breakdown
              </div>
              <button
                className="btn btn-xs"
                onClick={() => setComp1Detail(null)}
              >
                Close
              </button>
            </div>

            <div className="px-4 py-3 text-sm text-zinc-600 dark:text-zinc-400 border-b border-zinc-200 dark:border-zinc-800">
              Total:{" "}
              {fmt(
                comp1Detail.rows.reduce(
                  (sum, r) => sum + (Number.isFinite(r?.diff) ? r.diff : 0),
                  0
                )
              )}
            </div>

            <div className="px-4 py-3 overflow-auto">
              <table className="w-full text-sm">
                <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
                  <tr className="border-b border-zinc-200 dark:border-zinc-700">
                    <th className="px-3 py-2 text-left">Week</th>
                    <th className="px-3 py-2 text-left">Opponent</th>
                    <th className="px-3 py-2 text-right">Proj</th>
                    <th className="px-3 py-2 text-right">Actual</th>
                    <th className="px-3 py-2 text-right">Diff</th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-zinc-200 dark:divide-zinc-800">
                  {comp1Detail.rows
                    .slice()
                    .sort((a, b) => Number(a?.week || 0) - Number(b?.week || 0))
                    .map((row, idx) => (
                      <tr key={`${row.week}-${row.opponentTeamId}-${idx}`}>
                        <td className="px-3 py-2 tabular-nums">W{row.week}</td>
                        <td className="px-3 py-2">{row.opponentOwner}</td>
                        <td className="px-3 py-2 text-right tabular-nums">
                          {Number.isFinite(row?.opponentProjected)
                            ? row.opponentProjected.toFixed(1)
                            : "—"}
                        </td>
                        <td className="px-3 py-2 text-right tabular-nums">
                          {Number.isFinite(row?.opponentActual)
                            ? row.opponentActual.toFixed(1)
                            : "—"}
                        </td>
                        <td className="px-3 py-2 text-right tabular-nums">
                          {Number.isFinite(row?.diff)
                            ? row.diff.toFixed(1)
                            : "—"}
                        </td>
                      </tr>
                    ))}
                  {comp1Detail.rows.length === 0 && (
                    <tr>
                      <td
                        colSpan={5}
                        className="px-3 py-4 text-center opacity-60"
                      >
                        No weekly results available.
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      )}
      {comp2Detail && (
        <div className="fixed inset-0 z-50 flex items-center justify-center">
          <div
            className="absolute inset-0 bg-black/50"
            onClick={() => setComp2Detail(null)}
          />
          <div className="relative w-full max-w-2xl rounded-xl bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 shadow-xl max-h-[85vh] flex flex-col">
            <div className="flex items-center justify-between px-4 py-3 border-b border-zinc-200 dark:border-zinc-800 sticky top-0 bg-white dark:bg-zinc-900 z-10">
              <div className="text-base font-semibold">
                {comp2Detail.owner} — {comp2Detail.season}{" "}
                {isWeightedView
                  ? "Weighted Injury Impact"
                  : "Injury Weeks Lost"}
              </div>
              <button
                className="btn btn-xs"
                onClick={() => setComp2Detail(null)}
              >
                Close
              </button>
            </div>

            <div className="px-4 py-3 text-sm text-zinc-600 dark:text-zinc-400 border-b border-zinc-200 dark:border-zinc-800">
              {isWeightedView ? (
                <div className="space-y-1">
                  <div>Raw player-weeks flagged: {comp2RawCount}</div>
                  <div>
                    Weighted total: {fmtInjuryValue(comp2WeightedTotal)} (α ={" "}
                    {injuryWeightAlpha.toFixed(2)}, waiver R
                    {normalizedWaiverRound}, base R{comp2BaseRoundForDetail})
                  </div>
                </div>
              ) : (
                <>Total player-weeks flagged as injured: {comp2RawCount}</>
              )}
            </div>

            <div className="px-4 py-3 overflow-auto">
              <table className="w-full text-sm">
                <thead className="bg-zinc-50 dark:bg-zinc-800 sticky top-0">
                  <tr className="border-b border-zinc-200 dark:border-zinc-700">
                    <th className="px-3 py-2 text-left">Week</th>
                    <th className="px-3 py-2 text-left">Player</th>
                    <th className="px-3 py-2 text-left">Slot</th>
                    {isWeightedView && (
                      <th className="px-3 py-2 text-left">Draft</th>
                    )}
                    {isWeightedView && (
                      <th className="px-3 py-2 text-right">Weight</th>
                    )}
                  </tr>
                </thead>
                <tbody className="divide-y divide-zinc-200 dark:divide-zinc-800">
                  {comp2DetailRows
                    .slice()
                    .sort((a, b) => {
                      const wDiff = Number(a?.week || 0) - Number(b?.week || 0);
                      if (wDiff !== 0) return wDiff;
                      return (a?.player || "").localeCompare(b?.player || "");
                    })
                    .map((row, idx) => {
                      const draftLabel =
                        isWeightedView && row
                          ? row.draftRound != null
                            ? `R${row.draftRound}${
                                row.draftOverall != null
                                  ? ` (#${row.draftOverall})`
                                  : ""
                              }`
                            : row.weightRound != null
                            ? `Waiver (R${row.weightRound})`
                            : "—"
                          : null;
                      return (
                        <tr key={`${row.week}-${row.pid ?? row.player}-${idx}`}>
                          <td className="px-3 py-2 tabular-nums">
                            W{row.week}
                          </td>
                          <td className="px-3 py-2">{row.player}</td>
                          <td className="px-3 py-2">{row.slot || "—"}</td>
                          {isWeightedView && (
                            <td className="px-3 py-2">{draftLabel}</td>
                          )}
                          {isWeightedView && (
                            <td className="px-3 py-2 text-right tabular-nums">
                              {Number.isFinite(row?.weight)
                                ? row.weight.toFixed(2)
                                : "—"}
                            </td>
                          )}
                        </tr>
                      );
                    })}
                  {comp2DetailRows.length === 0 && (
                    <tr>
                      <td
                        colSpan={isWeightedView ? 5 : 3}
                        className="px-3 py-4 text-center opacity-60"
                      >
                        No injury weeks recorded.
                      </td>
                    </tr>
                  )}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// ---------- tiny subcomponents / utils ----------
function TeamOutlook({ label, now, win, loss }) {
  const pct = (p) => (p == null ? "—" : `${Math.round(p * 100)}%`);
  const diffUp =
    now != null && win != null ? Math.round((win - now) * 100) : null;
  const diffDn =
    now != null && loss != null ? Math.round((now - loss) * 100) : null;
  return (
    <div className="rounded-lg border border-zinc-200 dark:border-zinc-800 p-2">
      <div className="text-xs font-semibold mb-1">{label}</div>
      <div className="text-xs grid grid-cols-3 gap-2">
        <div>
          <div className="opacity-60">Now</div>
          <div className="tabular-nums">{pct(now)}</div>
        </div>
        <div>
          <div className="opacity-60">With Win</div>
          <div className="tabular-nums">
            {pct(win)}
            {diffUp != null ? (
              <span className="ml-1 text-emerald-600">(+{diffUp})</span>
            ) : null}
          </div>
        </div>
        <div>
          <div className="opacity-60">With Loss</div>
          <div className="tabular-nums">
            {pct(loss)}
            {diffDn != null ? (
              <span className="ml-1 text-rose-600">(-{diffDn})</span>
            ) : null}
          </div>
        </div>
      </div>
    </div>
  );
}

function fmtProj(n) {
  if (n == null || !Number.isFinite(Number(n))) return "—";
  const v = Number(n);
  return v.toFixed(v % 1 ? 1 : 0);
}

// Best-effort: team/owner names and projections from ESPN side object
function __ownerNameForTeam(seasonObj, teamId) {
  try {
    const t = (seasonObj?.teams || []).find(
      (x) => Number(x?.id) === Number(teamId)
    );
    const ownerId =
      t?.primaryOwner || (Array.isArray(t?.owners) && t.owners[0]) || null;
    const members = seasonObj?.members || [];
    const m = members.find((mm) => mm?.id === ownerId);
    const dn = (m?.displayName || "").trim();
    const fn = (m?.firstName || "").trim();
    const ln = (m?.lastName || "").trim();
    return dn || [fn, ln].filter(Boolean).join(" ").trim() || `Team ${teamId}`;
  } catch {
    return `Team ${teamId}`;
  }
}
function __teamNameForSide(side) {
  try {
    const t = side?.team || {};
    if (t.location && t.nickname) return `${t.location} ${t.nickname}`.trim();
    return t.name || "";
  } catch {
    return "";
  }
}
function __projectedPointsForSide(side, seasonId, week) {
  // ESPN often places projected totals on roster entries as appliedStatTotal for the week
  // Sum any numeric appliedStatTotal on rosterForMatchupPeriod/ScoringPeriod entries.
  try {
    const roster =
      side?.rosterForCurrentScoringPeriod ??
      side?.rosterForScoringPeriod ??
      side?.rosterForMatchupPeriod ??
      side?.roster;
    const entries = Array.isArray(roster?.entries)
      ? roster.entries
      : Array.isArray(roster?.players)
      ? roster.players
      : [];
    let sum = 0;
    let hit = false;
    for (const e of entries) {
      let v =
        e?.appliedTotal ??
        e?.appliedStatTotal ??
        e?.playerPoints?.appliedTotal ??
        (e?.playerPoolEntry ? e.playerPoolEntry.appliedStatTotal : undefined);
      // fallback: player.stats row for this week/season
      if (v == null || !Number.isFinite(Number(v))) {
        const pe = e?.playerPoolEntry || e;
        const p = pe?.player || pe;
        const stat = (Array.isArray(p?.stats) ? p.stats : []).find(
          (s) =>
            Number(s?.seasonId) === Number(seasonId) &&
            Number(s?.scoringPeriodId) === Number(week)
        );
        v = stat?.appliedStatTotal ?? stat?.appliedTotal ?? stat?.total;
      }
      if (Number.isFinite(Number(v))) {
        sum += Number(v);
        hit = true;
      }
    }
    return hit ? sum : null;
  } catch {
    return null;
  }
}

function groupByOwner(rows) {
  const map = new Map();
  (rows || []).forEach((r) => {
    const key = r.owner || r.team || r.team_name || r.manager || "—";
    if (!map.has(key)) map.set(key, []);
    map.get(key).push(r);
  });
  return Array.from(map.entries()).map(([owner, picks]) => ({ owner, picks }));
}
